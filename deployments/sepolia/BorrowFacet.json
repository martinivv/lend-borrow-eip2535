{
  "address": "0x2B2e7cA1318a9d8E587A2C24BD68de0EB628cB79",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "AddressEmptyCode",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "AddressInsufficientBalance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_caller",
          "type": "address"
        }
      ],
      "name": "AmountShouldBePositive",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint80",
          "name": "roundId",
          "type": "uint80"
        },
        {
          "internalType": "int256",
          "name": "answer",
          "type": "int256"
        }
      ],
      "name": "AnswerShouldBePositiveNum",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_caller",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "maxAmountToBorrowInUsd",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountToBeBorrowedInUsd",
          "type": "uint256"
        }
      ],
      "name": "CannotBorrowAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CollateralMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_caller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_tokenAddress",
          "type": "address"
        }
      ],
      "name": "CollateralNotEnabled",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FailedInnerCall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientProtocolFunds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint80",
          "name": "roundId",
          "type": "uint80"
        },
        {
          "internalType": "uint256",
          "name": "updatedAt",
          "type": "uint256"
        }
      ],
      "name": "InvalidTime",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "contract IAggregatorV3",
          "name": "dataFeed",
          "type": "address"
        }
      ],
      "name": "OracleNotAvailable",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ReentrantCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint80",
          "name": "roundId",
          "type": "uint80"
        }
      ],
      "name": "StalePrice",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TokenAlreadyThere",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_caller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_tokenAddress",
          "type": "address"
        }
      ],
      "name": "TokenNotAllowed",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrowedToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_borrowedAmount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_borrower",
          "type": "address"
        }
      ],
      "name": "Borrow",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_collateralAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenAmount",
          "type": "uint256"
        }
      ],
      "name": "borrow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xc3bc2928b7ed0e3d33904b6054d2de5d9ccf45e2a3ccc042a73c9664c1a1d39f",
  "receipt": {
    "to": null,
    "from": "0x8dfD6AE6d263262da0E4a2634d899a0085923Fbc",
    "contractAddress": "0x2B2e7cA1318a9d8E587A2C24BD68de0EB628cB79",
    "transactionIndex": 21,
    "gasUsed": "891042",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x3dac5c9509dc7282f0daa7bd0cc38322551b38e828b0b6d2a058b4664494f65c",
    "transactionHash": "0xc3bc2928b7ed0e3d33904b6054d2de5d9ccf45e2a3ccc042a73c9664c1a1d39f",
    "logs": [],
    "blockNumber": 4624266,
    "cumulativeGasUsed": "3397993",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "bf3ace87e0080de70e4c37f388c527e3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"AmountShouldBePositive\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"}],\"name\":\"AnswerShouldBePositiveNum\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountToBorrowInUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToBeBorrowedInUsd\",\"type\":\"uint256\"}],\"name\":\"CannotBorrowAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollateralMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"CollateralNotEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientProtocolFunds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IAggregatorV3\",\"name\":\"dataFeed\",\"type\":\"address\"}],\"name\":\"OracleNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"}],\"name\":\"StalePrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAlreadyThere\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowedToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_borrowedAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:version\":\"0.0.1\",\"details\":\"Keep in mind that *most* of the functions should be symmetric with `RepayFacet` ones\",\"errors\":{\"AddressEmptyCode(address)\":[{\"details\":\"There's no code at `target` (it is not a contract).\"}],\"AddressInsufficientBalance(address)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}],\"SafeERC20FailedOperation(address)\":[{\"details\":\"An operation with an ERC20 token failed.\"}]},\"kind\":\"dev\",\"methods\":{\"borrow(address,address,uint256)\":{\"custom:exec\":\"Sanity checks -> internal state changes, returns the scaled amount (currently) -> transfer\",\"custom:security\":\"`_tokenAmount` should be properly handled in the front-end; whole number\",\"params\":{\"_collateralAddress\":\"The address of the token which is going to be used as a collateral\",\"_tokenAmount\":\"The amount of tokens to borrow\",\"tokenAddress\":\"The address of the wanted token\"}}},\"title\":\"BorrowFacet\",\"version\":1},\"userdoc\":{\"events\":{\"Borrow(address,uint256,address)\":{\"notice\":\"Emitted on a successful borrow from the protocol\"}},\"kind\":\"user\",\"methods\":{\"borrow(address,address,uint256)\":{\"notice\":\"Borrows a token amount\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/domain/facets/BorrowFacet.sol\":\"BorrowFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":600},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"src/contracts/diamond/interfaces/IDiamondCutFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IDiamondCutFacet\\n/// @notice Interface that allows modifications to diamond function selector mapping\\ninterface IDiamondCutFacet {\\n    /// @notice Struct used as a mapping of facet to function selectors\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Available diamond operations\\n    /// @dev Add=0, Replace=1, Remove=2\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n\\n    /// @notice Emitted when facet selectors are modified\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    /// @notice Adds/replaces/removes any number of functions and optionally executes\\n    /// a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute `_calldata`\\n    /// @param _calldata A function call, including function selector and arguments\\n    /// @dev Be aware that `_calldata` is executed with delegatecall on the `_init` contract\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n}\\n\",\"keccak256\":\"0x3acf0660b6a64d0e066525a914763149d9efe9be92ee16e5ce90acd5a1b09009\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/DiamondState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {LibDiamondCut} from \\\"./logic/LibDiamondCut.sol\\\";\\nimport {LibDiamondOwnership} from \\\"./logic/LibDiamondOwnership.sol\\\";\\n\\nusing LibDiamondCut for DiamondState global;\\nusing LibDiamondOwnership for DiamondState global;\\n\\n/// @notice Struct defining the current diamond state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `DiamondState`\\nstruct DiamondState {\\n    /// @notice Function selector -> address facet and selector positions\\n    mapping(bytes4 => bytes32) facets;\\n    /// @notice Array of slots of function selectors, each slot holds 8 function selectors\\n    mapping(uint256 => bytes32) selectorSlots;\\n    /// @notice The number of function selectors in `selectorSlots`\\n    uint16 selectorCount;\\n    /// @notice ERC-165 implementation; query if a contract implements an interface\\n    mapping(bytes4 => bool) supportedInterfaces;\\n    /// @notice The owner of the Diamond contract\\n    address contractOwner;\\n}\\n\\n// ======================== Pointer ================================================================\\n\\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"martinivv.diamond.storage\\\");\\n\\n/// @notice Used as a shared storage\\n/// @return ds Storage pointer to `DiamondState` struct\\nfunction d() pure returns (DiamondState storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n\\n    assembly {\\n        ds.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0x134f91bbed10b47ed90a102ccbb176c45e8d67521b28aacf6656d40e084cb3b6\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/logic/LibDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable avoid-low-level-calls\\n// solhint-disable code-complexity\\n// solhint-disable custom-errors\\n\\npragma solidity =0.8.20;\\n\\nimport {IDiamondCutFacet} from \\\"../../interfaces/IDiamondCutFacet.sol\\\";\\nimport {DiamondState, d} from \\\"../DiamondState.sol\\\";\\n// Consider adding remappings\\nimport {DiamondEvents} from \\\"../../../helpers/Events.sol\\\";\\nimport {DiamondErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DiamondConstants} from \\\"../../../helpers/Constants.sol\\\";\\n\\n/// @notice See {diamondCut}'s @notice\\n/// @custom:security Will behave like an internal function of the calling contract\\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\\n    if (_init == address(0)) return;\\n\\n    LibDiamondCut.enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n\\n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n    if (!success) {\\n        if (error.length > 0) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(error)\\n                revert(add(32, error), returndata_size)\\n            }\\n        } else {\\n            revert DiamondErrors.InitializationFunctionReverted(_init, _calldata);\\n        }\\n    }\\n}\\n\\n/// @title LibDiamondCut\\n/// @notice Internal function versions of `DiamondCutFacet` ones\\n/// @dev This code is almost the same as the external `DiamondCutFacet` one,\\n/// except it is using `Facet[] memory _diamondCut` instead of\\n/// `Facet[] calldata _diamondCut`. The code is duplicated to prevent\\n/// copying calldata to memory which causes an error for a two dimensional array\\nlibrary LibDiamondCut {\\n    /// @notice Adds/replaces/removes any number of functions and optionally executes\\n    /// a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute `_calldata`\\n    /// @param _calldata A function call, including function selector and arguments\\n    /// @dev Be aware that `_calldata` is executed with delegatecall on the `_init` contract\\n    function diamondCut(\\n        DiamondState storage self,\\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        uint256 originalSelectorCount = self.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n\\n        if (selectorCount & 7 > 0) selectorSlot = self.selectorSlots[selectorCount >> 3];\\n\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n\\n            unchecked {\\n                facetIndex++;\\n            }\\n        }\\n\\n        if (selectorCount != originalSelectorCount) self.selectorCount = uint16(selectorCount);\\n\\n        if (selectorCount & 7 > 0) self.selectorSlots[selectorCount >> 3] = selectorSlot;\\n\\n        emit DiamondEvents.DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    /// @notice See {diamondCut}'s @notice\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCutFacet.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondState storage self = d();\\n\\n        if (_selectors.length < 1) revert DiamondErrors.NoSelectorFound();\\n\\n        if (_action == IDiamondCutFacet.FacetCutAction.Add) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = self.facets[selector];\\n\\n                if (address(bytes20(oldFacet)) != address(0)) revert DiamondErrors.FunctionAlreadyExists();\\n\\n                self.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                _selectorSlot =\\n                    (_selectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n\\n                if (selectorInSlotPosition == 224) {\\n                    self.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n\\n                _selectorCount++;\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCutFacet.FacetCutAction.Replace) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = self.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n\\n                if (oldFacetAddress == address(this)) revert DiamondErrors.ImmutableFunctionDetected();\\n\\n                if (oldFacetAddress == _newFacetAddress) revert DiamondErrors.CannotReplaceTheSameFunction();\\n\\n                if (oldFacetAddress == address(0)) revert DiamondErrors.FunctionDoesNotExist();\\n\\n                self.facets[selector] = (oldFacet & DiamondConstants.CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCutFacet.FacetCutAction.Remove) {\\n            if (_newFacetAddress != address(0)) revert DiamondErrors.MustBeZeroAddress(_newFacetAddress);\\n\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                if (_selectorSlot == 0) {\\n                    selectorSlotCount--;\\n                    _selectorSlot = self.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = self.facets[selector];\\n                    if (address(bytes20(oldFacet)) == address(0)) revert DiamondErrors.FunctionDoesNotExist();\\n\\n                    if (address(bytes20(oldFacet)) == address(this)) revert DiamondErrors.ImmutableFunctionDetected();\\n\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n\\n                    if (lastSelector != selector) {\\n                        self.facets[lastSelector] =\\n                            (oldFacet & DiamondConstants.CLEAR_ADDRESS_MASK) |\\n                            bytes20(self.facets[lastSelector]);\\n                    }\\n\\n                    delete self.facets[selector];\\n\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = self.selectorSlots[oldSelectorsSlotCount];\\n\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\n                    self.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n\\n                if (selectorInSlotIndex == 0) {\\n                    delete self.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert DiamondErrors.IncorrectFacetCutAction(uint8(_action));\\n        }\\n\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    /// @notice Ensures that the @param _contract has code, otherwise throws an @param _errorMessage\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x35d9df95b89c58f00c599f6fea6b6d7d7192428a16e2eb7f6362e6765ac68844\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/logic/LibDiamondOwnership.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {DiamondState} from \\\"../DiamondState.sol\\\";\\nimport {DiamondErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibDiamondOwnership\\n/// @notice Library collection of diamond ownership functions\\nlibrary LibDiamondOwnership {\\n    /// @notice Emitted when diamond owner is updated\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Updates the diamond owner to @param _newOwner's address\\n    function setContractOwner(DiamondState storage self, address _newOwner) internal {\\n        address previousOwner = self.contractOwner;\\n        self.contractOwner = _newOwner;\\n\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    /// @notice Returns the diamond @return contractOwner_'s address\\n    function getContractOwner(DiamondState storage self) internal view returns (address contractOwner_) {\\n        contractOwner_ = self.contractOwner;\\n    }\\n\\n    /// @notice Checks if `msg.sender` is the diamond owner\\n    function enforceIsContractOwner(DiamondState storage self) internal view {\\n        if (msg.sender != self.contractOwner) revert DiamondErrors.MustBeDiamondOwner(msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0xd3f4d72fea315ac0781dfc55f5f2b9d8e11262d360f7578ef591228cc385b8d0\",\"license\":\"MIT\"},\"src/contracts/domain/facets/BorrowFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {AssetsModifiers, a} from \\\"../libraries/AssetsState.sol\\\";\\nimport {ProtocolModifiers} from \\\"../libraries/ProtocolState.sol\\\";\\nimport {SafeERC20} from \\\"../vendor/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\nimport {DomainEvents} from \\\"../../helpers/Events.sol\\\";\\n\\n/// @title BorrowFacet\\n/// @dev Keep in mind that *most* of the functions should be symmetric with `RepayFacet` ones\\n/// @custom:version 0.0.1\\ncontract BorrowFacet is AssetsModifiers, ProtocolModifiers {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice Borrows a token amount\\n    /// @param _collateralAddress The address of the token which is going to be used as a collateral\\n    /// @param tokenAddress The address of the wanted token\\n    /// @param _tokenAmount The amount of tokens to borrow\\n    /// @custom:security `_tokenAmount` should be properly handled in the front-end; whole number\\n    /// @custom:exec Sanity checks -> internal state changes, returns the scaled amount (currently) -> transfer\\n    function borrow(\\n        address _collateralAddress,\\n        address tokenAddress,\\n        uint256 _tokenAmount\\n    ) external enabledCollateral(_collateralAddress) allowed(tokenAddress, _tokenAmount) nonReentrant {\\n        uint256 scaledAmount = a().verifyAndRecordBorrow(_collateralAddress, tokenAddress, _tokenAmount);\\n\\n        emit DomainEvents.Borrow(tokenAddress, _tokenAmount, msg.sender);\\n        IERC20(tokenAddress).safeTransfer(msg.sender, scaledAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x3adea07b5718456150d6d62cede5a46916093ebdd79275f5035311959b21f1be\",\"license\":\"MIT\"},\"src/contracts/domain/interfaces/IAggregatorV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IAggregatorV3\\n/// @notice This interface enables utilization of Chainlink data feeds\\ninterface IAggregatorV3 {\\n    /// @notice Returns the number of decimals in the response\\n    /// @return {uint8}\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Gets data from the latest round\\n    /// @return roundId The round ID\\n    /// @return answer The data that this specific feed provides\\n    /// @return startedAt Timestamp of when the round started\\n    /// @return updatedAt Timestamp of when the round was updated\\n    /// @return answeredInRound Deprecated. Previously used when answers could take multiple rounds to be computed\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\",\"keccak256\":\"0xf6e216dc33b61ef00f056ccd84e6a9ced64db2dd98a604cafbc5193978485bd2\",\"license\":\"MIT\"},\"src/contracts/domain/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IERC20\\n/// @notice Interface for standard ERC20 implementation\\ninterface IERC20 {\\n    /// @notice Emmited when @param value tokens are moved @param from to @param to account\\n    /// @dev `value` may be zero\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Emitted when the allowance of a @param spender for an @param owner is\\n    /// set by a call to {approve}. @param value is the new allowance\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the name of the token\\n    /// @return {string}\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the decimals places of the token\\n    /// @return {uint8}\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the value of tokens in existence\\n    /// @return {uint256}\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the value of tokens owned by @param _owner\\n    /// @return {uint256}\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Moves a @param _value amount of tokens from the caller's account to @param _to\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    /// @dev Emits a {Transfer} event\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Moves a @param _value amount of tokens from @param _from to @param _to using the\\n    /// allowance mechanism. @param _value is then deducted from the caller's allowance\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Sets a @param _value amount of tokens as the allowance of @param _spender over the\\n    /// caller's tokens\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    /// @custom:security Beware that changing an allowance with this method brings the risk\\n    /// that someone may use both the old and the new allowance by unfortunate transaction ordering.\\n    /// One possible solution to mitigate this race condition is to first reduce the spender's\\n    /// allowance to 0 and set the desired value afterwards:\\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x4f7671ce89e6f77621e67d6f9992f18832ed317612c0ab61be741628887ef37f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/AssetsState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {LibDeposit} from \\\"./logic/LibDeposit.sol\\\";\\nimport {LibBorrow} from \\\"./logic/LibBorrow.sol\\\";\\nimport {LibRepay} from \\\"./logic/LibRepay.sol\\\";\\nimport {LibWithdraw} from \\\"./logic/LibWithdraw.sol\\\";\\nimport {LibLiquidation} from \\\"./logic/LibLiquidation.sol\\\";\\nimport {LibCalculator} from \\\"./logic/LibCalculator.sol\\\";\\nimport {IAggregatorV3} from \\\"../interfaces/IAggregatorV3.sol\\\";\\nimport {DomainErrors} from \\\"../../helpers/Errors.sol\\\";\\n\\nusing LibDeposit for AssetsState global;\\nusing LibBorrow for AssetsState global;\\nusing LibRepay for AssetsState global;\\nusing LibWithdraw for AssetsState global;\\nusing LibLiquidation for AssetsState global;\\nusing LibCalculator for AssetsState global;\\n\\n/// @notice Defines the properties for an allowed token\\n/// @dev Parameters used for calculations are present in basis points. For example,\\n/// 1000 basis points = a 10 % staking stable rate\\nstruct AllowedToken {\\n    /// @notice Used as a parameter (on withdrawing) for calculating the daily interest (in tokens)\\n    /// for *solely* staking the token\\n    uint16 stakeStableRate;\\n    /// @notice Used as a parameter (on repaying) for calculating the daily interest (in tokens) to\\n    /// be paid back for a borrowed token\\n    uint16 borrowStableRate;\\n    /// @notice The token's LTV ratio. Higher value \\u2014 higher risk for the protocol's health\\n    uint16 ltv;\\n    /// @notice The token's liquidation threshold. If the borrowed amount in USD surpasses\\n    /// this limit, the borrower should be liquidated\\n    /// @dev 8_000 BPs = 80 % of the collateral\\n    uint16 liquidationThreshold;\\n    /// @notice Returns `true` if the token is allowed, otherwise `false`\\n    bool isAllowed;\\n    /// @notice The address of the token used for setting up the protocol's allowed tokens\\n    address tokenAddress;\\n    /// @notice The address of the Chainlink data feed\\n    IAggregatorV3 dataFeed;\\n}\\n\\n/// @notice Defines the properties for a staked token\\nstruct StakedToken {\\n    /// @notice The staked amount\\n    uint256 amountStaked;\\n    /// @notice Marks the start of the staking period, measured in seconds since the Unix epoch (block.timestamp)\\n    uint256 startAccumulatingDay;\\n    /// @notice Returns `true` if the token is staked, otherwise `false`\\n    bool isStaked;\\n    /// @notice Returns `true` if the token can be used as collateral for borrowing\\n    bool isCollateralOn;\\n    /// @notice Returns `true` if the token is currently used as collateral for a borrowed token\\n    bool isCollateralInUse;\\n}\\n\\n/// @notice Defines the properties for a borrowed token\\nstruct BorrowedToken {\\n    /// @notice The borrowed amount\\n    uint256 amountBorrowed;\\n    /// @notice Marks the start of the borrowing period, measured in seconds since the Unix epoch (block.timestamp)\\n    uint256 startAccumulatingDay;\\n    /// @notice Returns `true` if the token is borrowed, otherwise `false`\\n    bool isBorrowed;\\n    /// @notice The address of the used collateral\\n    address collateralAddress;\\n    /// @notice The amount tokens used for the borrow\\n    uint256 collateralAmount;\\n}\\n\\n/// @notice Struct defining the current assets state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `AssetsState`\\nstruct AssetsState {\\n    /// @notice Protocol's allowed tokens data. Token address -> token data\\n    mapping(address => AllowedToken) allowedTokenData;\\n    /// @notice Protocol's allowed tokens\\n    address[] allowedTokens;\\n    // ======================= STAKE ===========================================================\\n    /// @notice Account -> token address -> staking data\\n    mapping(address => mapping(address => StakedToken)) stakedTokenData;\\n    /// @notice Account -> array of staked token addresses\\n    mapping(address => address[]) stakedTokens;\\n    // ======================= BORROW ===========================================================\\n    /// @notice Account -> token address -> borrowing data\\n    mapping(address => mapping(address => BorrowedToken)) borrowedTokenData;\\n    /// @notice Account -> array of borrowed token addressess\\n    mapping(address => address[]) borrowedTokens;\\n    /// @notice Protocol's borrowers\\n    address[] borrowers;\\n}\\n\\n/* ============================= Pointer =============================================================================== */\\n\\nbytes32 constant ASSETS_STORAGE_POSITION = keccak256(\\\"martinivv.assets.storage\\\");\\n\\n/// @notice Used as a shared storage\\n/// @return ast Storage pointer to `AssetsState` struct\\n/// @dev Any operation involving `ast` will read from or write to **storage**\\nfunction a() pure returns (AssetsState storage ast) {\\n    bytes32 position = ASSETS_STORAGE_POSITION;\\n\\n    assembly {\\n        ast.slot := position\\n    }\\n}\\n\\n/* ============================= Modifiers =============================================================================== */\\n\\n/// @notice Includes modifiers shared across protocol's contracts\\nabstract contract AssetsModifiers {\\n    /* ============================= Deposit & Borrow =========================================================== */\\n\\n    /// @notice Checks if @param _tokenAddress is allowed and @param _tokenAmount is greater than 0\\n    /// @custom:security Zero value ERC20 transfers are terminated in the protocol\\n    modifier allowed(address _tokenAddress, uint256 _tokenAmount) {\\n        if (!a().allowedTokenData[_tokenAddress].isAllowed) {\\n            revert DomainErrors.TokenNotAllowed(msg.sender, _tokenAddress);\\n        }\\n        if (_tokenAmount == 0) revert DomainErrors.AmountShouldBePositive(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Looks the @param _tokenAddress's collateral option to be enabled\\n    /// @custom:security When enabled, it is checked whether it is staked or not\\n    modifier enabledCollateral(address _tokenAddress) {\\n        if (!a().stakedTokenData[msg.sender][_tokenAddress].isCollateralOn) {\\n            revert DomainErrors.CollateralNotEnabled(msg.sender, _tokenAddress);\\n        }\\n        _;\\n    }\\n\\n    /// @notice Looks the @param _collateralAddress to not be currently in use\\n    /// @custom:security The property `isCollateralInUse` is controlled in `BorrowFacet` and\\n    /// `RepayFacet`, the necessary checks are made\\n    modifier notInUseCollateral(address _collateralAddress) {\\n        if (!a().stakedTokenData[msg.sender][_collateralAddress].isStaked) {\\n            revert DomainErrors.TokenNotStaked(msg.sender, _collateralAddress);\\n        }\\n        if (a().stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse) {\\n            revert DomainErrors.CollateralCurrentlyInUse();\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Repay =========================================================== */\\n\\n    /// @notice Looks @param _collateralAddress and @param _borrowedToken to be repayable\\n    /// @custom:security Checking the validity of the `_collateralAddress` is crucial for the\\n    /// protocol security, otherwise could lead to critical vulnerability\\n    modifier repayableCollateral(address _collateralAddress, address _borrowedToken) {\\n        if (a().borrowedTokenData[msg.sender][_borrowedToken].collateralAddress != _collateralAddress) {\\n            revert DomainErrors.CollateralMismatch();\\n        }\\n        if (!a().stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse) {\\n            revert DomainErrors.CollateralNotInUse();\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Liquidation =========================================================== */\\n\\n    /// @notice Looks @param _borrower and @param _borrowedToken to be liquidatable\\n    modifier liquidatable(address _borrower, address _borrowedToken) {\\n        if (msg.sender == _borrower) revert DomainErrors.SelfLiquidationNotAllowed();\\n        if (!a().borrowedTokenData[_borrower][_borrowedToken].isBorrowed) {\\n            revert DomainErrors.TokenNotBorrowed(msg.sender, _borrowedToken);\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Global =========================================================== */\\n\\n    /// @notice Looks @param _tokenAmount to be positive\\n    modifier positiveAmount(uint256 _tokenAmount) {\\n        if (_tokenAmount == 0) revert DomainErrors.AmountShouldBePositive(msg.sender);\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x60b9d2140d47818d4cc2996e0161daf9eb703ca53f5b506660aa3b30bea5f73f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/ProtocolState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {DomainConstants} from \\\"../../helpers/Constants.sol\\\";\\nimport {DomainErrors} from \\\"../../helpers/Errors.sol\\\";\\nimport {d} from \\\"../../diamond/libraries/DiamondState.sol\\\";\\n\\n/// @notice Struct defining the current protocol state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `ProtocolState`\\nstruct ProtocolState {\\n    /// @notice Reentrancy guard's property\\n    uint256 reentrancyStatus;\\n    /// @notice The address of the interest-bearing token\\n    address mTokenAddress;\\n    /// @notice Staleness prevention for the Chainlink oracle response\\n    uint32 answerStalenessThreshold;\\n}\\n\\n/* ============================= Pointer ============================================================================= */\\n\\nbytes32 constant PROTOCOL_STORAGE_POSITION = keccak256(\\\"martinivv.protocol.storage\\\");\\n\\n/// @notice Used as a shared storage among libraries\\n/// @return ps Storage pointer to `DiamondState` struct\\n/// @dev Any operation involving `ps` will read from or write to **storage**\\nfunction p() pure returns (ProtocolState storage ps) {\\n    bytes32 position = PROTOCOL_STORAGE_POSITION;\\n\\n    assembly {\\n        ps.slot := position\\n    }\\n}\\n\\n/* ============================= Modifiers ============================================================================= */\\n\\n/// @notice Includes modifiers shared across protocol's contracts\\n/// @custom:advice Consider adding more robust access control management\\nabstract contract ProtocolModifiers {\\n    /// @notice Prevents a contract from calling itself, over and over, directly or indirectly\\n    /// @dev Forked OZ implementation. Avoids state storage collision within diamond\\n    /// @dev By storing the original value once again at the end, a refund is triggered (see\\n    /// https://eips.ethereum.org/EIPS/eip-2200)\\n    modifier nonReentrant() {\\n        if (p().reentrancyStatus == DomainConstants._ENTERED) revert DomainErrors.ReentrantCall();\\n\\n        p().reentrancyStatus = DomainConstants._ENTERED;\\n        _;\\n\\n        p().reentrancyStatus = DomainConstants._NOT_ENTERED;\\n    }\\n\\n    /// @notice Access control modifier. Ensures that the method is called only by the diamond owner\\n    modifier onlyOwner() {\\n        d().enforceIsContractOwner();\\n        _;\\n    }\\n\\n    /// @notice Initializes reentrancy guard on diamond deployment\\n    function _initReentrancyGuard() internal {\\n        p().reentrancyStatus = DomainConstants._NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x18cdfee5c086a3e8a58182330615629996fcde2d1f18ae21a3a552b8e3abbcd9\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibBorrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibBorrow\\nlibrary LibBorrow {\\n    using Array for address[];\\n\\n    /// @notice Verifies the truth of account parameters and records the borrow\\n    /// @param _collateralAddress The address of the token used as collateral for the borrow\\n    /// @param _tokenAddress The address of the borrowed token\\n    /// @param _tokenAmount The amount to be borrowed\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:advice If `_tokenAmount` cannot be borrowed, consider implementing logic where\\n    /// the maximum available token amount is passed to the `BorrowFacet`\\n    /// @custom:exec Sanity checks (internal calls to `LibCalculator`) -> internal state updates\\n    function verifyAndRecordBorrow(\\n        AssetsState storage self,\\n        address _collateralAddress,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal returns (uint256 scaledAmount) {\\n        /* ========================= Sanity checks ======================================================================== */\\n\\n        (uint256 collateralAmount, uint256 maxToBorrowInUsd) = self.getMaxAmountToBorrowInUsd(_collateralAddress);\\n        uint256 amountToBeBorrowedInUsd = self.getNormalizedUsdEquivalent(_tokenAddress, _tokenAmount);\\n\\n        if (amountToBeBorrowedInUsd > maxToBorrowInUsd) {\\n            revert DomainErrors.CannotBorrowAmount(msg.sender, maxToBorrowInUsd, amountToBeBorrowedInUsd);\\n        }\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n        scaledAmount = _tokenAmount * 10 ** decimals;\\n\\n        if (token.balanceOf(address(this)) < scaledAmount) revert DomainErrors.InsufficientProtocolFunds();\\n\\n        /* ========================= Updating internal state ======================================================================== */\\n\\n        BorrowedToken storage borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        bool isTokenBorrowed = borrowedToken.isBorrowed;\\n\\n        if (isTokenBorrowed) {\\n            address collateralInUse = borrowedToken.collateralAddress;\\n            if (_collateralAddress != collateralInUse) revert DomainErrors.CollateralMismatch();\\n\\n            borrowedToken.amountBorrowed += _tokenAmount;\\n        } else {\\n            BorrowedToken memory currentToken = BorrowedToken({\\n                amountBorrowed: _tokenAmount,\\n                startAccumulatingDay: block.timestamp,\\n                isBorrowed: true,\\n                collateralAddress: _collateralAddress,\\n                collateralAmount: collateralAmount\\n            });\\n\\n            // Always manage together!\\n            self.borrowedTokenData[msg.sender][_tokenAddress] = currentToken;\\n            self.borrowedTokens[msg.sender].push(_tokenAddress);\\n            // =======\\n            self.borrowers.safePush(msg.sender);\\n\\n            self.stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse = true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6378e24efb17284ef19a5e2cf4d108962660c1deacee51b286eef57b292e3f2f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {AssetsState} from \\\"../AssetsState.sol\\\";\\n// Add remappings\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {p} from \\\"../ProtocolState.sol\\\";\\nimport {IAggregatorV3} from \\\"../../interfaces/IAggregatorV3.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibCalculator\\n/// @custom:advice If needed, implement max ratio constant\\nlibrary LibCalculator {\\n    /// @notice Gets the borrowing power in USD\\n    /// @param _collateralAddress The address of the used collateral for the borrow\\n    /// @return collateralAmount The amount of the used collateral\\n    /// @return maxToBorrowInUsd The maximum USD amount you can borrow\\n    /// @dev LTV ratio is represented in basis points, 500 basis points = 5 %\\n    /// @custom:security Reverts if the extraction in `value` results in a negative value\\n    /// @custom:security The integral business model is not considered, may occur wrong calculations, loss of funds.\\n    /// It's a demo version\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    /// @custom:exec Gets the USD equivalent of the collateral amount -> calculates the\\n    /// max borrowing amount in USD\\n    function getMaxAmountToBorrowInUsd(\\n        AssetsState storage self,\\n        address _collateralAddress\\n    ) internal view returns (uint256 collateralAmount, uint256 maxToBorrowInUsd) {\\n        collateralAmount = self.stakedTokenData[msg.sender][_collateralAddress].amountStaked;\\n        uint256 collateralInUsd = getNormalizedUsdEquivalent(self, _collateralAddress, collateralAmount);\\n        uint16 tokenLtv = self.allowedTokenData[_collateralAddress].ltv;\\n\\n        // Calculates the result of the expression `collateralInUsd - (collateralInUsd * tokenLtv / BASIS_POINTS)`.\\n        // The calculation within the parentheses is rounded down\\n        uint256 denominator = DomainConstants.BASIS_POINTS;\\n        assembly {\\n            let z := mul(collateralInUsd, tokenLtv)\\n\\n            if iszero(\\n                and(iszero(iszero(denominator)), or(iszero(collateralInUsd), eq(div(z, collateralInUsd), tokenLtv)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(z, denominator)\\n            maxToBorrowInUsd := sub(collateralInUsd, z)\\n        }\\n    }\\n\\n    /// @notice Calculates the USD equivalent value of a token amount\\n    /// @param _tokenAddress The token's address\\n    /// @param _tokenAmount The token amount\\n    /// @return value The normalized USD value obtained by `tokenAmount *\\n    /// the token's USD price / decimals to be removed`\\n    function getNormalizedUsdEquivalent(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 value) {\\n        (uint256 oracleResponse, uint8 decimals) = _getTokenPriceInUsd(self, _tokenAddress);\\n\\n        value = (_tokenAmount * oracleResponse) / (10 ** decimals);\\n    }\\n\\n    /// @notice Gets the raw price and decimals of an allowed token\\n    /// @param _tokenAddress The allowed token\\n    /// @return oracleResponse Returns the raw price with `decimals`, not divided by a decimal point\\n    /// @return decimals *Typically* comes with a value of 8\\n    /// @custom:security Consider implementing backup oracle(-s) logic in case of failure;\\n    /// TWAP or other verifiably secure options are recommended\\n    function _getTokenPriceInUsd(\\n        AssetsState storage state,\\n        address _tokenAddress\\n    ) private view returns (uint256 oracleResponse, uint8 decimals) {\\n        IAggregatorV3 dataFeed = state.allowedTokenData[_tokenAddress].dataFeed;\\n\\n        try dataFeed.latestRoundData() returns (uint80 roundId, int256 answer, uint256, uint256 updatedAt, uint80) {\\n            if (answer < 1) revert DomainErrors.AnswerShouldBePositiveNum(roundId, answer);\\n\\n            if (updatedAt == 0) revert DomainErrors.InvalidTime(roundId, updatedAt);\\n\\n            if (block.timestamp - updatedAt > p().answerStalenessThreshold) {\\n                revert DomainErrors.StalePrice(roundId);\\n            }\\n\\n            oracleResponse = uint256(answer);\\n        } catch {\\n            revert DomainErrors.OracleNotAvailable(dataFeed);\\n        }\\n\\n        decimals = dataFeed.decimals();\\n    }\\n}\\n\",\"keccak256\":\"0x036a955a0cf1baf620f4d0b1af90796db1b0c1cf332671c15f642055b4dd6861\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibDeposit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {SafeERC20} from \\\"../../vendor/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {AssetsState, StakedToken} from \\\"../AssetsState.sol\\\";\\nimport {p} from \\\"../ProtocolState.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DomainEvents} from \\\"../../../helpers/Events.sol\\\";\\n\\n/// @title LibDeposit\\nlibrary LibDeposit {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice Manages the deposit by changing the internal protocol state. Then sends mTokens\\n    /// @param _tokenAddress The deposited token address\\n    /// @param _tokenAmount The token amount without decimals\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    function manageDeposit(AssetsState storage self, address _tokenAddress, uint256 _tokenAmount) internal {\\n        StakedToken storage stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        bool isTokenStaked = stakedToken.isStaked;\\n\\n        if (isTokenStaked) {\\n            stakedToken.amountStaked += _tokenAmount;\\n            stakedToken.startAccumulatingDay = block.timestamp;\\n        } else {\\n            StakedToken memory currentToken = StakedToken({\\n                amountStaked: _tokenAmount,\\n                startAccumulatingDay: block.timestamp,\\n                isStaked: true,\\n                isCollateralOn: false,\\n                isCollateralInUse: false\\n            });\\n\\n            // Always manage together!\\n            self.stakedTokenData[msg.sender][_tokenAddress] = currentToken;\\n            self.stakedTokens[msg.sender].push(_tokenAddress);\\n            // =======\\n        }\\n\\n        _sendMTokens(self, _tokenAddress, _tokenAmount);\\n    }\\n\\n    /// @notice Sends mTokens; the interest-bearing token back for a deposited token\\n    /// @param _tokenAddress The deposited token's address\\n    /// @param _tokenAmount The deposited token's amount\\n    /// @custom:security Ensure you're using the right decimals, otherwise this can lead\\n    /// to wrong calculations, misleading errors, loss of funds\\n    /// @custom:advice Consider implementing event monitoring for the interest-bearing token\\n    function _sendMTokens(AssetsState storage state, address _tokenAddress, uint256 _tokenAmount) private {\\n        // The price of the token amount without decimals\\n        uint256 sendAmount = state.getNormalizedUsdEquivalent(_tokenAddress, _tokenAmount);\\n\\n        IERC20 mToken = IERC20(p().mTokenAddress);\\n        uint8 decimals = mToken.decimals();\\n\\n        uint256 scaledAmount = sendAmount * 10 ** decimals;\\n        if (scaledAmount > mToken.balanceOf(address(this))) revert DomainErrors.NotEnoughTokensInExistence();\\n\\n        emit DomainEvents.Deposit(_tokenAddress, _tokenAmount, msg.sender);\\n        mToken.safeTransfer(msg.sender, scaledAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x010dfa516db0f0fba5b957570002521220dd65f19cb7a081f17c0d021179439a\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibLiquidation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\n\\n/// @title LibLiquidation\\nlibrary LibLiquidation {\\n    using Array for address[];\\n\\n    /// @notice Returns keeper's @return rewardInTokens, otherwise, if the @param _borrower is not\\n    /// for liquidation, reverts\\n    /// @param _borrowedToken The address of the borrowed token\\n    /// @dev Calculations once again are in basis points. 8_000 BPs = 80 %\\n    /// @custom:advice Consider adding another mechanism instead of reverting; if needed\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    /// @custom:security Gives 50 % (5_000 BPs) of the reward to the keeper to establish some form\\n    /// of equilibrium in the protocol (pays interest to the supporters). Don't forget that this\\n    /// is a DEFI protocol\\n    function manageLiquidation(\\n        AssetsState storage self,\\n        address _borrower,\\n        address _borrowedToken\\n    ) internal view returns (address collateralAddress, uint256 rewardInTokens) {\\n        BorrowedToken memory borrowedToken = self.borrowedTokenData[_borrower][_borrowedToken];\\n\\n        /* ==================================== Is liquidatable? =========================================================================== */\\n\\n        // ========== Collateral in USD ==============================\\n        collateralAddress = borrowedToken.collateralAddress;\\n        uint256 collateralAmount = self.stakedTokenData[_borrower][collateralAddress].amountStaked;\\n        uint256 collateralInUsd = self.getNormalizedUsdEquivalent(collateralAddress, collateralAmount);\\n\\n        // ========== Borrowed in USD ==============================\\n        uint256 borrowedAmount = borrowedToken.amountBorrowed;\\n        uint256 borrowedInUsd = self.getNormalizedUsdEquivalent(_borrowedToken, borrowedAmount);\\n\\n        // ========== Finding the limit ==============================\\n        uint16 collateralThreshold = self.allowedTokenData[collateralAddress].liquidationThreshold;\\n        // For example. `8_000 * 1000 / 10_000` equals to `800`\\n        uint256 limitInUsd = (collateralThreshold * collateralInUsd) / DomainConstants.BASIS_POINTS;\\n        if (borrowedInUsd < limitInUsd) revert DomainErrors.NotLiquidatable(msg.sender);\\n\\n        /* =============================== Calculating the keeper reward ========================================================================== */\\n\\n        // `(5_000 * (2400 - 2000)) / 10_000` equals to `200`\\n        uint256 rewardInUsd = (5_000 * (borrowedInUsd - limitInUsd)) / DomainConstants.BASIS_POINTS;\\n        uint256 singleTokenPrice = rewardInUsd / borrowedAmount;\\n        uint8 decimals = IERC20(_borrowedToken).decimals();\\n        rewardInTokens = (rewardInUsd * 10 ** decimals) / singleTokenPrice;\\n    }\\n\\n    /// @notice Records the liquidation into the internal state\\n    /// @param _borrower The address of the borrower\\n    /// @param _collateralAddress The address of the used collateral token\\n    /// @param _borrowedToken The address of the borrowed token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    function recordLiquidation(\\n        AssetsState storage self,\\n        address _borrower,\\n        address _collateralAddress,\\n        address _borrowedToken\\n    ) internal {\\n        delete self.stakedTokenData[_borrower][_collateralAddress];\\n        self.stakedTokens[_borrower].remove(_collateralAddress);\\n\\n        delete self.borrowedTokenData[_borrower][_borrowedToken];\\n        self.borrowedTokens[_borrower].remove(_borrowedToken);\\n    }\\n}\\n\",\"keccak256\":\"0x398b9d536aabd5fbcb25334067cf236f1cbbc08e189f72645e5944299ac93fbf\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibRepay.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibRepay\\nlibrary LibRepay {\\n    using Array for address[];\\n\\n    /// @notice Makes internal changes\\n    /// @param _collateralAddress The address of the used collateral token\\n    /// @param _tokenAddress The address of the repaid token\\n    /// @param _verifiedAmount The verified amount of the repaid token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:security Can't occur the mapping/array vulnerability where the mapping/array remains accessible\\n    /// even after deletion, because in this case it's not nested\\n    function recordRepay(\\n        AssetsState storage self,\\n        address _collateralAddress,\\n        address _tokenAddress,\\n        uint256 _verifiedAmount\\n    ) internal {\\n        BorrowedToken storage borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        // Still hasn't been updated\\n        uint256 currentAmount = borrowedToken.amountBorrowed;\\n\\n        if (_verifiedAmount == currentAmount) {\\n            // Always manage together!\\n            delete self.borrowedTokenData[msg.sender][_tokenAddress];\\n            self.borrowedTokens[msg.sender].remove(_tokenAddress);\\n            // =======\\n            if (self.borrowedTokens[msg.sender].length == 0) self.borrowers.remove(msg.sender);\\n\\n            // Managing the collateral token\\n            self.stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse = false;\\n        } else {\\n            borrowedToken.amountBorrowed -= _verifiedAmount;\\n        }\\n    }\\n\\n    /// @notice Calculates the amount to be repaid\\n    /// @param _tokenAddress The borrowed token\\n    /// @param _tokenAmount The borrowed amount\\n    /// @return verifiedAmount Ensures correct state changes in {recordRepay}\\n    /// @return totalToRepay The amount with the right token decimals\\n    /// @custom:security The integral business model is not considered; wrong calculations and loss of funds may occur.\\n    /// Calculations are only used for demo purposes\\n    /// @custom:security If `startAccumulatingDay` is in the current day, `verifiedNumDays` will receive a value of\\n    /// 1 (day) to ensure proper calculations in the current version, thereby preventing a critical vulnerability\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    function calculateAmountToRepay(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 verifiedAmount, uint256 totalToRepay) {\\n        /* ============================== Setup =========================================================================== */\\n\\n        BorrowedToken memory borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 borrowedAmount = borrowedToken.amountBorrowed;\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n\\n        verifiedAmount = (_tokenAmount > borrowedAmount ? borrowedAmount : _tokenAmount);\\n        uint256 scaledAmount = verifiedAmount * 10 ** decimals;\\n\\n        /* ============================== Interest =========================================================================== */\\n\\n        uint256 startAccumulatingDay = borrowedToken.startAccumulatingDay;\\n        uint16 tokenBorrowStableRate = self.allowedTokenData[_tokenAddress].borrowStableRate;\\n\\n        uint256 numDays = (block.timestamp - startAccumulatingDay) / DomainConstants.SECONDS_PER_DAY;\\n\\n        uint256 verifiedNumDays = numDays > 0 ? numDays : 1;\\n        // For example. `100e18 * 500 / 10_000` equals to `5e18`\\n        uint256 dailyInterestInTokens = (scaledAmount * tokenBorrowStableRate) / DomainConstants.BASIS_POINTS;\\n        // `15 * 5e18 / 365` equals to `(0.)205479452054794520`\\n        uint256 accumulatedInterestInTokens = (verifiedNumDays * dailyInterestInTokens) / DomainConstants.DAYS_PER_YEAR;\\n\\n        /* ============================== Finalization =========================================================================== */\\n\\n        // `100e18 + 205479452054794520` equals to `100205479452054794520`\\n        totalToRepay = scaledAmount + accumulatedInterestInTokens;\\n\\n        if (token.balanceOf(msg.sender) < totalToRepay) revert DomainErrors.InsufficientTokenAmount();\\n    }\\n}\\n\",\"keccak256\":\"0xeeb666ad7ba6012c8715c34fe53b0e5b71113bedad8a5d947a977f6ba4abc7a3\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibWithdraw.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, StakedToken} from \\\"../AssetsState.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\n\\n/// @title LibWithdraw\\nlibrary LibWithdraw {\\n    using Array for address[];\\n\\n    /// @notice Records the withdraw, applying the changes to the internal state\\n    /// @param _tokenAddress The address of the withdrawn token\\n    /// @param _verifiedAmount The verified amount of the withdrawn token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:security Can't occur the mapping/array vulnerability where the mapping/array remains accessible\\n    /// even after deletion, because in this case it's not nested\\n    function recordWithdraw(AssetsState storage self, address _tokenAddress, uint256 _verifiedAmount) internal {\\n        StakedToken storage stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 currentAmount = stakedToken.amountStaked;\\n\\n        if (_verifiedAmount == currentAmount) {\\n            // Always manage together!\\n            delete self.stakedTokenData[msg.sender][_tokenAddress];\\n            self.stakedTokens[msg.sender].remove(_tokenAddress);\\n            // =======\\n        } else {\\n            stakedToken.amountStaked -= _verifiedAmount;\\n        }\\n    }\\n\\n    /// @notice Calculates @return withdrawAmount and @return mTokensToBurn. @return verifiedAmount ensures\\n    /// correct state changes in {recordWithdraw}\\n    /// @param _tokenAddress The address of the token to be withdrawn\\n    /// @param _tokenAmount The amount of the token to be withdrawn\\n    /// @custom:security The correct decimals are applied\\n    /// @custom:security The integral business model is not considered; wrong calculations and loss of funds may occur.\\n    /// Calculations are only used for demo purposes\\n    /// @custom:security If `startAccumulatingDay` is in the current day, `verifiedNumDays` will receive a value of\\n    /// 1 (day) to ensure proper calculations in the current version, thereby preventing a critical vulnerability\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    function calculateWithdraw(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 verifiedAmount, uint256 withdrawAmount, uint256 mTokensToBurn) {\\n        /* ========================== Setup ======================================================================== */\\n\\n        StakedToken memory stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 stakedAmount = stakedToken.amountStaked;\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n\\n        // In order to burn the correct amount\\n        verifiedAmount = (_tokenAmount > stakedAmount ? stakedAmount : _tokenAmount);\\n        uint256 scaledWithdraw = verifiedAmount * 10 ** decimals;\\n\\n        /* ========================== Interest, withdrawable amount ======================================================================== */\\n\\n        if (!stakedToken.isCollateralOn) {\\n            uint32 tokenStakeStableRate = self.allowedTokenData[_tokenAddress].stakeStableRate;\\n\\n            uint256 numDays = (block.timestamp - stakedToken.startAccumulatingDay) / DomainConstants.SECONDS_PER_DAY;\\n\\n            uint256 verifiedNumDays = numDays > 0 ? numDays : 1;\\n            // For example. `100e18 * 1000 / 10_000` equals to `10e18`\\n            uint256 dailyInterestInTokens = (scaledWithdraw * tokenStakeStableRate) / DomainConstants.BASIS_POINTS;\\n            // `15 * 10e18 / 365` equals to `(0.)410958904109589041`\\n            uint256 accumulatedInterestInTokens = (verifiedNumDays * dailyInterestInTokens) /\\n                DomainConstants.DAYS_PER_YEAR;\\n\\n            // `100e18 += 410958904109589041` equals to `100410958904109589041`\\n            withdrawAmount = accumulatedInterestInTokens;\\n        }\\n\\n        withdrawAmount += scaledWithdraw;\\n        if (token.balanceOf(address(this)) < withdrawAmount) revert DomainErrors.InsufficientProtocolFunds();\\n\\n        /* ========================== mTokens ======================================================================== */\\n\\n        mTokensToBurn = (self.getNormalizedUsdEquivalent(_tokenAddress, verifiedAmount)) * 10 ** decimals;\\n    }\\n}\\n\",\"keccak256\":\"0xa408f251c75bb9c5c2d3538e61f1a92fe29f9063aba448a51c2bf0d16fb24d14\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/utils/Array.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// Consider adding remappings\\nimport {DomainErrors} from \\\"../../../../helpers/Errors.sol\\\";\\n\\n/// @title Array\\n/// @notice Array helper utils\\nlibrary Array {\\n    /// @notice Removes @param _address from @param _arr\\n    /// @custom:exec Gets the index of `tokenAddress` -> moves the element in the last index, if\\n    /// it's not already there -> removes the last index\\n    function remove(address[] storage _arr, address _address) internal {\\n        uint256 index = _indexOf(_arr, _address);\\n        if (index == 404) revert DomainErrors.Error404();\\n\\n        uint256 lastIndex = _arr.length - 1;\\n\\n        if (index != lastIndex) _arr[index] = _arr[lastIndex];\\n\\n        _arr.pop();\\n    }\\n\\n    /// @notice Pushes @param _address in @param _arr, if doesn't occur\\n    function safePush(address[] storage _arr, address _address) internal {\\n        uint256 index = _indexOf(_arr, _address);\\n\\n        if (index == 404) {\\n            _arr.push(_address);\\n        } else {\\n            revert DomainErrors.TokenAlreadyThere();\\n        }\\n    }\\n\\n    /// @notice Returns the index of @param _address in @param _arr\\n    /// @return i The index of the token's address, otherwise `404`, referencing the popular *Error404*\\n    /// @custom:security Security measures taken for the *for* loop:\\n    /// 1. The array is cached outside, making it gas-optimized;\\n    /// 2. There is no storage array that can grow infinitely;\\n    /// 3. There are no external calls within the loop, potentially preventing a DoS attack\\n    function _indexOf(address[] memory _arr, address _address) private pure returns (uint256 i) {\\n        uint256 length = _arr.length;\\n\\n        for (i; i < length; i++) {\\n            if (_arr[i] == _address) return i;\\n        }\\n\\n        i = 404;\\n    }\\n}\\n\",\"keccak256\":\"0x9da1029c3f2fe8d32ad9c6d2f590e7a3149c01f4818cf6da62d3f25f342a8bcd\",\"license\":\"MIT\"},\"src/contracts/domain/vendor/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n/* solhint-disable avoid-low-level-calls */\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x0f523ff6883ab63bc74f9840a89983d659dfa223db3286b9c82d0e1ead604fac\",\"license\":\"MIT\"},\"src/contracts/helpers/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n// solhint-disable state-visibility\\n\\npragma solidity =0.8.20;\\n\\n/// @title DiamondConstants\\n/// @notice Constants used all around the Diamond logic\\nlibrary DiamondConstants {\\n    /// @notice Diamond's property\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    /// @notice Diamond's property\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n}\\n\\n/// @title DomainConstants\\n/// @notice Constants used all around the Domain logic\\nlibrary DomainConstants {\\n    /// @notice Used for handling calculations with basis points\\n    uint256 constant BASIS_POINTS = 10_000;\\n    /// @notice One day in seconds\\n    uint256 constant SECONDS_PER_DAY = 1 days;\\n    /// @notice Days in a year. Yeap years are ignored\\n    uint256 constant DAYS_PER_YEAR = 365;\\n    /// @notice ReentrancyGuard's property\\n    uint256 constant _NOT_ENTERED = 1;\\n    /// @notice ReentrancyGuard's property\\n    uint256 constant _ENTERED = 2;\\n}\\n\",\"keccak256\":\"0xa91d9468a2376c940149c6d99e6cacd92a78bf16d90d3fae43dbb1789f9b1028\",\"license\":\"MIT\"},\"src/contracts/helpers/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n\\npragma solidity =0.8.20;\\n\\nimport {IAggregatorV3} from \\\"../domain/interfaces/IAggregatorV3.sol\\\";\\n\\n/// @title DiamondErrors\\n/// @notice Errors used all around the Diamond logic\\nlibrary DiamondErrors {\\n    error FunctionDoesNotExist();\\n    error TooManyFunctionsInAFacet();\\n    error NoZeroAddressOwner();\\n    error NoSelectorFound();\\n    error FunctionAlreadyExists();\\n    error ImmutableFunctionDetected();\\n    error CannotReplaceTheSameFunction();\\n    error MustBeZeroAddress(address _newFacetAddress);\\n    error IncorrectFacetCutAction(uint8 _actionNum);\\n    error InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n    error MustBeDiamondOwner(address _caller);\\n    error TransferFailed();\\n}\\n\\n/// @title DomainErrors\\n/// @notice Errors used all around the Domain logic\\n/// @custom:advice Use distinct naming for the errors if your error monitoring model requires it\\nlibrary DomainErrors {\\n    // =============== Protocol ========================================\\n    error ReentrantCall();\\n    // =============== Deposit ========================================\\n    error TokenNotAllowed(address _caller, address _tokenAddress);\\n    error AmountShouldBePositive(address _caller);\\n    error NotEnoughTokensInExistence();\\n    error TokenNotStaked(address _caller, address _tokenAddress);\\n    error CollateralAlreadyOn();\\n    error CollateralNotEnabled(address _caller, address _tokenAddress);\\n    error CollateralCurrentlyInUse();\\n    // =============== Borrow ========================================\\n    error NoAmountAvailable();\\n    error CannotBorrowAmount(address _caller, uint256 maxAmountToBorrowInUsd, uint256 amountToBeBorrowedInUsd);\\n    error InsufficientProtocolFunds();\\n    error CollateralMismatch();\\n    // =============== Repay ========================================\\n    error TokenNotBorrowed(address _caller, address _tokenAddress);\\n    error CollateralNotInUse();\\n    error InsufficientTokenAmount();\\n    error Error404();\\n    error TokenAlreadyThere();\\n    error NoTokensFound();\\n    // =============== Liquidation ========================================\\n    error SelfLiquidationNotAllowed();\\n    error NotLiquidatable(address _caller);\\n    // =============== LibCalculator ========================================\\n    error AnswerShouldBePositiveNum(uint80 roundId, int256 answer);\\n    error InvalidTime(uint80 roundId, uint256 updatedAt);\\n    error StalePrice(uint80 roundId);\\n    error OracleNotAvailable(IAggregatorV3 dataFeed);\\n    // =============== UI ========================================\\n    error UI__TokenNotAllowed(address _caller, address _tokenAddress);\\n}\\n\",\"keccak256\":\"0x24db49ec47c0dfe9a5ab4164cff3bd3b41df64767e8cebec12fed494cae978e1\",\"license\":\"MIT\"},\"src/contracts/helpers/Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n\\npragma solidity =0.8.20;\\n\\nimport {IDiamondCutFacet} from \\\"../diamond/interfaces/IDiamondCutFacet.sol\\\";\\n\\n/// @title DiamondEvents\\n/// @notice Events used all around the Diamond logic\\nlibrary DiamondEvents {\\n    /// @notice Emitted on a successful cut\\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\\n/// @title DomainEvents\\n/// @notice Events used all around the Domain logic\\nlibrary DomainEvents {\\n    /// @notice Emitted on a successful deposit/stake in the protocol\\n    event Deposit(address _depositedToken, uint256 _depositedAmount, address indexed _depositor);\\n    /// @notice Emitted on a successful collateral activation\\n    event CollateralOn(address _tokenAddress, address _depositor);\\n    /// @notice Emitted on a successful collateral deactivation\\n    event CollateralOff(address _tokenAddress, address _depositor);\\n    /// @notice Emitted on a successful borrow from the protocol\\n    event Borrow(address borrowedToken, uint256 _borrowedAmount, address indexed _borrower);\\n    /// @notice Emitted on a successful repayment to the protocol\\n    event Repay(address borrowedToken, uint256 _repayedAmount, address indexed _borrower);\\n    /// @notice Emitted on a successful withdrawal from the protocol\\n    event Withdraw(address token, uint256 amount, address indexed _depositor);\\n    /// @notice Emitted on a successful liquidation\\n    event Liquidation(address indexed _borrower, address indexed borrowedToken, uint256 keeperReward, address _keeper);\\n}\\n\",\"keccak256\":\"0x6c57d33228666ccd54542c1150d3bd1a4eb099ed89d8ecb34123c292eebfa82d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610f29806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80635224372c14610030575b600080fd5b61004361003e366004610c52565b610045565b005b3360009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cc602090815260408083206001600160a01b03871684529091529020600201548390610100900460ff166100c8576040516376596d7760e01b81523360048201526001600160a01b03821660248201526044015b60405180910390fd5b82827fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709ca6001600160a01b0383166000908152602091909152604090205468010000000000000000900460ff1661014257604051634afb130560e11b81523360048201526001600160a01b03831660248201526044016100bf565b806000036101655760405163f9a7ae8760e01b81523360048201526024016100bf565b60027fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9954036101a7576040516306fda65d60e31b815260040160405180910390fd5b60027fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf995560006101f97fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709ca888888610281565b604080516001600160a01b03891681526020810188905291925033917f6856231d021c3bf5ff021b9c481488255d5b429e5a6b699baba09c6e2916bdb2910160405180910390a26102546001600160a01b0387163383610655565b5060017fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9955505050505050565b6000808061028f87876106c1565b909250905060006102a1888787610746565b9050818111156102d45760405163568bb44560e01b815233600482015260248101839052604481018290526064016100bf565b60008690506000816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610319573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061033d9190610c8e565b905061034a81600a610dab565b6103549088610dba565b6040516370a0823160e01b815230600482015290965086906001600160a01b038416906370a0823190602401602060405180830381865afa15801561039d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103c19190610dd1565b10156103e057604051632122027360e11b815260040160405180910390fd5b33600090815260048b01602090815260408083206001600160a01b038c1684529091529020600281015460ff16801561046a5760028201546001600160a01b036101009091048116908c16811461044a5760405163128abb3560e21b815260040160405180910390fd5b8983600001600082825461045e9190610dea565b90915550610646915050565b60006040518060a001604052808b81526020014281526020016001151581526020018d6001600160a01b03168152602001898152509050808d6004016000336001600160a01b03166001600160a01b0316815260200190815260200160002060008d6001600160a01b03166001600160a01b03168152602001908152602001600020600082015181600001556020820151816001015560408201518160020160006101000a81548160ff02191690831515021790555060608201518160020160016101000a8154816001600160a01b0302191690836001600160a01b03160217905550608082015181600301559050508c6005016000336001600160a01b03166001600160a01b031681526020019081526020016000208b9080600181540180825580915050600190039060005260206000200160009091909190916101000a8154816001600160a01b0302191690836001600160a01b031602179055506105de338e60060161078390919063ffffffff16565b60018d6002016000336001600160a01b03166001600160a01b0316815260200190815260200160002060008e6001600160a01b03166001600160a01b0316815260200190815260200160002060020160026101000a81548160ff021916908315150217905550505b50505050505050949350505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663a9059cbb60e01b1790526106bc90849061084b565b505050565b33600090815260028301602090815260408083206001600160a01b038516845290915281205490806106f4858585610746565b6001600160a01b038516600090815260208790526040902054909150640100000000900461ffff16612710818302838104831484151760011661073657600080fd5b9497940490910394509192505050565b600080600061075586866108ae565b909250905061076581600a610dab565b61076f8386610dba565b6107799190610dfd565b9695505050505050565b60006107e8838054806020026020016040519081016040528092919081815260200182805480156107dd57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116107bf575b505050505083610aa9565b905080610194036108325782546001810184556000848152602090200180546001600160a01b03841673ffffffffffffffffffffffffffffffffffffffff19909116179055505050565b604051634a10c57b60e01b815260040160405180910390fd5b60006108606001600160a01b03841683610b0e565b905080516000141580156108855750808060200190518101906108839190610e1f565b155b156106bc57604051635274afe760e01b81526001600160a01b03841660048201526024016100bf565b6001600160a01b03808216600090815260208490526040808220600101548151633fabe5a360e21b8152915192938493911691829163feaf968c9160048082019260a0929091908290030181865afa92505050801561092a575060408051601f3d908101601f1916820190925261092791810190610e5b565b60015b61095257604051638681218760e01b81526001600160a01b03821660048201526024016100bf565b600184121561098957604051633843011160e21b815269ffffffffffffffffffff86166004820152602481018590526044016100bf565b816000036109bf57604051636bd07e6160e01b815269ffffffffffffffffffff86166004820152602481018390526044016100bf565b7fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9a5474010000000000000000000000000000000000000000900463ffffffff16610a098342610eab565b1115610a36576040516306741d7b60e11b815269ffffffffffffffffffff861660048201526024016100bf565b50919550505050806001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a9f9190610c8e565b9150509250929050565b81516000905b80821015610b0157826001600160a01b0316848381518110610ad357610ad3610ebe565b60200260200101516001600160a01b031603610aef5750610b08565b81610af981610ed4565b925050610aaf565b6101949150505b92915050565b6060610b1c83836000610b23565b9392505050565b606081471015610b485760405163cd78605960e01b81523060048201526024016100bf565b600080856001600160a01b03168486604051610b649190610eed565b60006040518083038185875af1925050503d8060008114610ba1576040519150601f19603f3d011682016040523d82523d6000602084013e610ba6565b606091505b5091509150610779868383606082610bc657610bc182610c0d565b610b1c565b8151158015610bdd57506001600160a01b0384163b155b15610c0657604051639996b31560e01b81526001600160a01b03851660048201526024016100bf565b5080610b1c565b805115610c1d5780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b80356001600160a01b0381168114610c4d57600080fd5b919050565b600080600060608486031215610c6757600080fd5b610c7084610c36565b9250610c7e60208501610c36565b9150604084013590509250925092565b600060208284031215610ca057600080fd5b815160ff81168114610b1c57600080fd5b634e487b7160e01b600052601160045260246000fd5b600181815b80851115610d02578160001904821115610ce857610ce8610cb1565b80851615610cf557918102915b93841c9390800290610ccc565b509250929050565b600082610d1957506001610b08565b81610d2657506000610b08565b8160018114610d3c5760028114610d4657610d62565b6001915050610b08565b60ff841115610d5757610d57610cb1565b50506001821b610b08565b5060208310610133831016604e8410600b8410161715610d85575081810a610b08565b610d8f8383610cc7565b8060001904821115610da357610da3610cb1565b029392505050565b6000610b1c60ff841683610d0a565b8082028115828204841417610b0857610b08610cb1565b600060208284031215610de357600080fd5b5051919050565b80820180821115610b0857610b08610cb1565b600082610e1a57634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215610e3157600080fd5b81518015158114610b1c57600080fd5b805169ffffffffffffffffffff81168114610c4d57600080fd5b600080600080600060a08688031215610e7357600080fd5b610e7c86610e41565b9450602086015193506040860151925060608601519150610e9f60808701610e41565b90509295509295909350565b81810381811115610b0857610b08610cb1565b634e487b7160e01b600052603260045260246000fd5b600060018201610ee657610ee6610cb1565b5060010190565b6000825160005b81811015610f0e5760208186018101518583015201610ef4565b50600092019182525091905056fea164736f6c6343000814000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80635224372c14610030575b600080fd5b61004361003e366004610c52565b610045565b005b3360009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cc602090815260408083206001600160a01b03871684529091529020600201548390610100900460ff166100c8576040516376596d7760e01b81523360048201526001600160a01b03821660248201526044015b60405180910390fd5b82827fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709ca6001600160a01b0383166000908152602091909152604090205468010000000000000000900460ff1661014257604051634afb130560e11b81523360048201526001600160a01b03831660248201526044016100bf565b806000036101655760405163f9a7ae8760e01b81523360048201526024016100bf565b60027fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9954036101a7576040516306fda65d60e31b815260040160405180910390fd5b60027fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf995560006101f97fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709ca888888610281565b604080516001600160a01b03891681526020810188905291925033917f6856231d021c3bf5ff021b9c481488255d5b429e5a6b699baba09c6e2916bdb2910160405180910390a26102546001600160a01b0387163383610655565b5060017fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9955505050505050565b6000808061028f87876106c1565b909250905060006102a1888787610746565b9050818111156102d45760405163568bb44560e01b815233600482015260248101839052604481018290526064016100bf565b60008690506000816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610319573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061033d9190610c8e565b905061034a81600a610dab565b6103549088610dba565b6040516370a0823160e01b815230600482015290965086906001600160a01b038416906370a0823190602401602060405180830381865afa15801561039d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103c19190610dd1565b10156103e057604051632122027360e11b815260040160405180910390fd5b33600090815260048b01602090815260408083206001600160a01b038c1684529091529020600281015460ff16801561046a5760028201546001600160a01b036101009091048116908c16811461044a5760405163128abb3560e21b815260040160405180910390fd5b8983600001600082825461045e9190610dea565b90915550610646915050565b60006040518060a001604052808b81526020014281526020016001151581526020018d6001600160a01b03168152602001898152509050808d6004016000336001600160a01b03166001600160a01b0316815260200190815260200160002060008d6001600160a01b03166001600160a01b03168152602001908152602001600020600082015181600001556020820151816001015560408201518160020160006101000a81548160ff02191690831515021790555060608201518160020160016101000a8154816001600160a01b0302191690836001600160a01b03160217905550608082015181600301559050508c6005016000336001600160a01b03166001600160a01b031681526020019081526020016000208b9080600181540180825580915050600190039060005260206000200160009091909190916101000a8154816001600160a01b0302191690836001600160a01b031602179055506105de338e60060161078390919063ffffffff16565b60018d6002016000336001600160a01b03166001600160a01b0316815260200190815260200160002060008e6001600160a01b03166001600160a01b0316815260200190815260200160002060020160026101000a81548160ff021916908315150217905550505b50505050505050949350505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663a9059cbb60e01b1790526106bc90849061084b565b505050565b33600090815260028301602090815260408083206001600160a01b038516845290915281205490806106f4858585610746565b6001600160a01b038516600090815260208790526040902054909150640100000000900461ffff16612710818302838104831484151760011661073657600080fd5b9497940490910394509192505050565b600080600061075586866108ae565b909250905061076581600a610dab565b61076f8386610dba565b6107799190610dfd565b9695505050505050565b60006107e8838054806020026020016040519081016040528092919081815260200182805480156107dd57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116107bf575b505050505083610aa9565b905080610194036108325782546001810184556000848152602090200180546001600160a01b03841673ffffffffffffffffffffffffffffffffffffffff19909116179055505050565b604051634a10c57b60e01b815260040160405180910390fd5b60006108606001600160a01b03841683610b0e565b905080516000141580156108855750808060200190518101906108839190610e1f565b155b156106bc57604051635274afe760e01b81526001600160a01b03841660048201526024016100bf565b6001600160a01b03808216600090815260208490526040808220600101548151633fabe5a360e21b8152915192938493911691829163feaf968c9160048082019260a0929091908290030181865afa92505050801561092a575060408051601f3d908101601f1916820190925261092791810190610e5b565b60015b61095257604051638681218760e01b81526001600160a01b03821660048201526024016100bf565b600184121561098957604051633843011160e21b815269ffffffffffffffffffff86166004820152602481018590526044016100bf565b816000036109bf57604051636bd07e6160e01b815269ffffffffffffffffffff86166004820152602481018390526044016100bf565b7fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9a5474010000000000000000000000000000000000000000900463ffffffff16610a098342610eab565b1115610a36576040516306741d7b60e11b815269ffffffffffffffffffff861660048201526024016100bf565b50919550505050806001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a9f9190610c8e565b9150509250929050565b81516000905b80821015610b0157826001600160a01b0316848381518110610ad357610ad3610ebe565b60200260200101516001600160a01b031603610aef5750610b08565b81610af981610ed4565b925050610aaf565b6101949150505b92915050565b6060610b1c83836000610b23565b9392505050565b606081471015610b485760405163cd78605960e01b81523060048201526024016100bf565b600080856001600160a01b03168486604051610b649190610eed565b60006040518083038185875af1925050503d8060008114610ba1576040519150601f19603f3d011682016040523d82523d6000602084013e610ba6565b606091505b5091509150610779868383606082610bc657610bc182610c0d565b610b1c565b8151158015610bdd57506001600160a01b0384163b155b15610c0657604051639996b31560e01b81526001600160a01b03851660048201526024016100bf565b5080610b1c565b805115610c1d5780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b80356001600160a01b0381168114610c4d57600080fd5b919050565b600080600060608486031215610c6757600080fd5b610c7084610c36565b9250610c7e60208501610c36565b9150604084013590509250925092565b600060208284031215610ca057600080fd5b815160ff81168114610b1c57600080fd5b634e487b7160e01b600052601160045260246000fd5b600181815b80851115610d02578160001904821115610ce857610ce8610cb1565b80851615610cf557918102915b93841c9390800290610ccc565b509250929050565b600082610d1957506001610b08565b81610d2657506000610b08565b8160018114610d3c5760028114610d4657610d62565b6001915050610b08565b60ff841115610d5757610d57610cb1565b50506001821b610b08565b5060208310610133831016604e8410600b8410161715610d85575081810a610b08565b610d8f8383610cc7565b8060001904821115610da357610da3610cb1565b029392505050565b6000610b1c60ff841683610d0a565b8082028115828204841417610b0857610b08610cb1565b600060208284031215610de357600080fd5b5051919050565b80820180821115610b0857610b08610cb1565b600082610e1a57634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215610e3157600080fd5b81518015158114610b1c57600080fd5b805169ffffffffffffffffffff81168114610c4d57600080fd5b600080600080600060a08688031215610e7357600080fd5b610e7c86610e41565b9450602086015193506040860151925060608601519150610e9f60808701610e41565b90509295509295909350565b81810381811115610b0857610b08610cb1565b634e487b7160e01b600052603260045260246000fd5b600060018201610ee657610ee6610cb1565b5060010190565b6000825160005b81811015610f0e5760208186018101518583015201610ef4565b50600092019182525091905056fea164736f6c6343000814000a",
  "devdoc": {
    "custom:version": "0.0.1",
    "details": "Keep in mind that *most* of the functions should be symmetric with `RepayFacet` ones",
    "errors": {
      "AddressEmptyCode(address)": [
        {
          "details": "There's no code at `target` (it is not a contract)."
        }
      ],
      "AddressInsufficientBalance(address)": [
        {
          "details": "The ETH balance of the account is not enough to perform the operation."
        }
      ],
      "FailedInnerCall()": [
        {
          "details": "A call to an address target failed. The target may have reverted."
        }
      ],
      "SafeERC20FailedOperation(address)": [
        {
          "details": "An operation with an ERC20 token failed."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "borrow(address,address,uint256)": {
        "custom:exec": "Sanity checks -> internal state changes, returns the scaled amount (currently) -> transfer",
        "custom:security": "`_tokenAmount` should be properly handled in the front-end; whole number",
        "params": {
          "_collateralAddress": "The address of the token which is going to be used as a collateral",
          "_tokenAmount": "The amount of tokens to borrow",
          "tokenAddress": "The address of the wanted token"
        }
      }
    },
    "title": "BorrowFacet",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Borrow(address,uint256,address)": {
        "notice": "Emitted on a successful borrow from the protocol"
      }
    },
    "kind": "user",
    "methods": {
      "borrow(address,address,uint256)": {
        "notice": "Borrows a token amount"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
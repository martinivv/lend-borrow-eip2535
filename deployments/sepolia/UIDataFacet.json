{
  "address": "0x30c2FC007867CcaAe7083a86f208Accc2DD3792d",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint80",
          "name": "roundId",
          "type": "uint80"
        },
        {
          "internalType": "int256",
          "name": "answer",
          "type": "int256"
        }
      ],
      "name": "AnswerShouldBePositiveNum",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint80",
          "name": "roundId",
          "type": "uint80"
        },
        {
          "internalType": "uint256",
          "name": "updatedAt",
          "type": "uint256"
        }
      ],
      "name": "InvalidTime",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "contract IAggregatorV3",
          "name": "dataFeed",
          "type": "address"
        }
      ],
      "name": "OracleNotAvailable",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint80",
          "name": "roundId",
          "type": "uint80"
        }
      ],
      "name": "StalePrice",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_caller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_tokenAddress",
          "type": "address"
        }
      ],
      "name": "UI__TokenNotAllowed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_accountAddress",
          "type": "address"
        }
      ],
      "name": "getAccountData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address[]",
              "name": "stakedTokens",
              "type": "address[]"
            },
            {
              "internalType": "address[]",
              "name": "borrowedTokens",
              "type": "address[]"
            }
          ],
          "internalType": "struct LibUI.AccountData",
          "name": "accountData",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllBorrowers",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "allBorrowers",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        }
      ],
      "name": "getBorrowedTokens",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "amountBorrowed",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "startAccumulatingDay",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "collateralAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "collateralAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct LibUI.BorrowedTokenData[]",
          "name": "borrowedTokensBatch",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_collateralAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_collateralAmount",
          "type": "uint256"
        }
      ],
      "name": "getMaxUsdToBorrow",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "maxUsdToBorrow",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProtocolTokens",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint16",
              "name": "stakeStableRate",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "borrowStableRate",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "ltv",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "liquidationThreshold",
              "type": "uint16"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            }
          ],
          "internalType": "struct LibUI.AllowedTokenData[]",
          "name": "allowedTokensBatch",
          "type": "tuple[]"
        },
        {
          "internalType": "address",
          "name": "mTokenAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        }
      ],
      "name": "getStakedTokens",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "amountStaked",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "startAccumulatingDay",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "isCollateralOn",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isCollateralInUse",
              "type": "bool"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            }
          ],
          "internalType": "struct LibUI.StakedTokenData[]",
          "name": "stakedTokensBatch",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_collateralAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_borrowedTokenAddress",
          "type": "address"
        }
      ],
      "name": "isLiquidatable",
      "outputs": [
        {
          "internalType": "bool",
          "name": "result",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x3128381eb7ada44d2a99e5114415f8b84ce2185fc1a1dcbacf1beb7cc6866b46",
  "receipt": {
    "to": null,
    "from": "0x8dfD6AE6d263262da0E4a2634d899a0085923Fbc",
    "contractAddress": "0x30c2FC007867CcaAe7083a86f208Accc2DD3792d",
    "transactionIndex": 64,
    "gasUsed": "1326943",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc7d920fba64a5bc5c84c931e5b378b09de8a25d47ba907dd6df2bfda929c84ea",
    "transactionHash": "0x3128381eb7ada44d2a99e5114415f8b84ce2185fc1a1dcbacf1beb7cc6866b46",
    "logs": [],
    "blockNumber": 4624289,
    "cumulativeGasUsed": "14354170",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "bf3ace87e0080de70e4c37f388c527e3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"}],\"name\":\"AnswerShouldBePositiveNum\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IAggregatorV3\",\"name\":\"dataFeed\",\"type\":\"address\"}],\"name\":\"OracleNotAvailable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"}],\"name\":\"StalePrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"UI__TokenNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accountAddress\",\"type\":\"address\"}],\"name\":\"getAccountData\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"stakedTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"borrowedTokens\",\"type\":\"address[]\"}],\"internalType\":\"struct LibUI.AccountData\",\"name\":\"accountData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllBorrowers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"allBorrowers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getBorrowedTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAccumulatingDay\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LibUI.BorrowedTokenData[]\",\"name\":\"borrowedTokensBatch\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateralAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"getMaxUsdToBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxUsdToBorrow\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"stakeStableRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowStableRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ltv\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct LibUI.AllowedTokenData[]\",\"name\":\"allowedTokensBatch\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"mTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getStakedTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAccumulatingDay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCollateralOn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCollateralInUse\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct LibUI.StakedTokenData[]\",\"name\":\"stakedTokensBatch\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowedTokenAddress\",\"type\":\"address\"}],\"name\":\"isLiquidatable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"custom:version\":\"0.0.1\",\"details\":\"Make changes depending on the front-end model. This implementation is conceptual\",\"kind\":\"dev\",\"methods\":{\"getMaxUsdToBorrow(address,uint256)\":{\"details\":\"`_collateralAmount` must be a whole number\",\"params\":{\"_collateralAmount\":\"values\"}},\"isLiquidatable(address,address,address)\":{\"returns\":{\"result\":\"`true` if it is, otherwise `false`\"}}},\"title\":\"UIDataFacet\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAccountData(address)\":{\"notice\":\"Gets relevant @param _account information. Returns it as @return data\"},\"getAllBorrowers()\":{\"notice\":\"Returns all borrowers in the protocol as @return allBorrowers\"},\"getBorrowedTokens(address)\":{\"notice\":\"Aggregated view of @param _account's borrowed tokens in @return borrowedTokensBatch\"},\"getMaxUsdToBorrow(address,uint256)\":{\"notice\":\"Returns the maximum amount in USD that can be borrowed based on @param _collateralAddress\"},\"getProtocolTokens()\":{\"notice\":\"Gets global-related data of the protocolAggregated view of the allowed tokens in @return allowedTokensBatch; in @return mTokenAddress \\u2014 the address of the interest-bearing token\"},\"getStakedTokens(address)\":{\"notice\":\"Aggregated view of @param _account's staked tokens in @return stakedTokensBatch\"},\"isLiquidatable(address,address,address)\":{\"notice\":\"Checks if the @param _account is liquidatable based on @param _collateralAddress and @param _borrowedTokenAddress.\"}},\"notice\":\"UI aggregated data\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/domain/facets/UIDataFacet.sol\":\"UIDataFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":600},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"src/contracts/diamond/interfaces/IDiamondCutFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IDiamondCutFacet\\n/// @notice Interface that allows modifications to diamond function selector mapping\\ninterface IDiamondCutFacet {\\n    /// @notice Struct used as a mapping of facet to function selectors\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Available diamond operations\\n    /// @dev Add=0, Replace=1, Remove=2\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n\\n    /// @notice Emitted when facet selectors are modified\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    /// @notice Adds/replaces/removes any number of functions and optionally executes\\n    /// a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute `_calldata`\\n    /// @param _calldata A function call, including function selector and arguments\\n    /// @dev Be aware that `_calldata` is executed with delegatecall on the `_init` contract\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n}\\n\",\"keccak256\":\"0x3acf0660b6a64d0e066525a914763149d9efe9be92ee16e5ce90acd5a1b09009\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/DiamondState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {LibDiamondCut} from \\\"./logic/LibDiamondCut.sol\\\";\\nimport {LibDiamondOwnership} from \\\"./logic/LibDiamondOwnership.sol\\\";\\n\\nusing LibDiamondCut for DiamondState global;\\nusing LibDiamondOwnership for DiamondState global;\\n\\n/// @notice Struct defining the current diamond state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `DiamondState`\\nstruct DiamondState {\\n    /// @notice Function selector -> address facet and selector positions\\n    mapping(bytes4 => bytes32) facets;\\n    /// @notice Array of slots of function selectors, each slot holds 8 function selectors\\n    mapping(uint256 => bytes32) selectorSlots;\\n    /// @notice The number of function selectors in `selectorSlots`\\n    uint16 selectorCount;\\n    /// @notice ERC-165 implementation; query if a contract implements an interface\\n    mapping(bytes4 => bool) supportedInterfaces;\\n    /// @notice The owner of the Diamond contract\\n    address contractOwner;\\n}\\n\\n// ======================== Pointer ================================================================\\n\\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"martinivv.diamond.storage\\\");\\n\\n/// @notice Used as a shared storage\\n/// @return ds Storage pointer to `DiamondState` struct\\nfunction d() pure returns (DiamondState storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n\\n    assembly {\\n        ds.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0x134f91bbed10b47ed90a102ccbb176c45e8d67521b28aacf6656d40e084cb3b6\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/logic/LibDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable avoid-low-level-calls\\n// solhint-disable code-complexity\\n// solhint-disable custom-errors\\n\\npragma solidity =0.8.20;\\n\\nimport {IDiamondCutFacet} from \\\"../../interfaces/IDiamondCutFacet.sol\\\";\\nimport {DiamondState, d} from \\\"../DiamondState.sol\\\";\\n// Consider adding remappings\\nimport {DiamondEvents} from \\\"../../../helpers/Events.sol\\\";\\nimport {DiamondErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DiamondConstants} from \\\"../../../helpers/Constants.sol\\\";\\n\\n/// @notice See {diamondCut}'s @notice\\n/// @custom:security Will behave like an internal function of the calling contract\\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\\n    if (_init == address(0)) return;\\n\\n    LibDiamondCut.enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n\\n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n    if (!success) {\\n        if (error.length > 0) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(error)\\n                revert(add(32, error), returndata_size)\\n            }\\n        } else {\\n            revert DiamondErrors.InitializationFunctionReverted(_init, _calldata);\\n        }\\n    }\\n}\\n\\n/// @title LibDiamondCut\\n/// @notice Internal function versions of `DiamondCutFacet` ones\\n/// @dev This code is almost the same as the external `DiamondCutFacet` one,\\n/// except it is using `Facet[] memory _diamondCut` instead of\\n/// `Facet[] calldata _diamondCut`. The code is duplicated to prevent\\n/// copying calldata to memory which causes an error for a two dimensional array\\nlibrary LibDiamondCut {\\n    /// @notice Adds/replaces/removes any number of functions and optionally executes\\n    /// a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute `_calldata`\\n    /// @param _calldata A function call, including function selector and arguments\\n    /// @dev Be aware that `_calldata` is executed with delegatecall on the `_init` contract\\n    function diamondCut(\\n        DiamondState storage self,\\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        uint256 originalSelectorCount = self.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n\\n        if (selectorCount & 7 > 0) selectorSlot = self.selectorSlots[selectorCount >> 3];\\n\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n\\n            unchecked {\\n                facetIndex++;\\n            }\\n        }\\n\\n        if (selectorCount != originalSelectorCount) self.selectorCount = uint16(selectorCount);\\n\\n        if (selectorCount & 7 > 0) self.selectorSlots[selectorCount >> 3] = selectorSlot;\\n\\n        emit DiamondEvents.DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    /// @notice See {diamondCut}'s @notice\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCutFacet.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondState storage self = d();\\n\\n        if (_selectors.length < 1) revert DiamondErrors.NoSelectorFound();\\n\\n        if (_action == IDiamondCutFacet.FacetCutAction.Add) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = self.facets[selector];\\n\\n                if (address(bytes20(oldFacet)) != address(0)) revert DiamondErrors.FunctionAlreadyExists();\\n\\n                self.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                _selectorSlot =\\n                    (_selectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n\\n                if (selectorInSlotPosition == 224) {\\n                    self.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n\\n                _selectorCount++;\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCutFacet.FacetCutAction.Replace) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = self.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n\\n                if (oldFacetAddress == address(this)) revert DiamondErrors.ImmutableFunctionDetected();\\n\\n                if (oldFacetAddress == _newFacetAddress) revert DiamondErrors.CannotReplaceTheSameFunction();\\n\\n                if (oldFacetAddress == address(0)) revert DiamondErrors.FunctionDoesNotExist();\\n\\n                self.facets[selector] = (oldFacet & DiamondConstants.CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCutFacet.FacetCutAction.Remove) {\\n            if (_newFacetAddress != address(0)) revert DiamondErrors.MustBeZeroAddress(_newFacetAddress);\\n\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                if (_selectorSlot == 0) {\\n                    selectorSlotCount--;\\n                    _selectorSlot = self.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = self.facets[selector];\\n                    if (address(bytes20(oldFacet)) == address(0)) revert DiamondErrors.FunctionDoesNotExist();\\n\\n                    if (address(bytes20(oldFacet)) == address(this)) revert DiamondErrors.ImmutableFunctionDetected();\\n\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n\\n                    if (lastSelector != selector) {\\n                        self.facets[lastSelector] =\\n                            (oldFacet & DiamondConstants.CLEAR_ADDRESS_MASK) |\\n                            bytes20(self.facets[lastSelector]);\\n                    }\\n\\n                    delete self.facets[selector];\\n\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = self.selectorSlots[oldSelectorsSlotCount];\\n\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\n                    self.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n\\n                if (selectorInSlotIndex == 0) {\\n                    delete self.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert DiamondErrors.IncorrectFacetCutAction(uint8(_action));\\n        }\\n\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    /// @notice Ensures that the @param _contract has code, otherwise throws an @param _errorMessage\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x35d9df95b89c58f00c599f6fea6b6d7d7192428a16e2eb7f6362e6765ac68844\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/logic/LibDiamondOwnership.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {DiamondState} from \\\"../DiamondState.sol\\\";\\nimport {DiamondErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibDiamondOwnership\\n/// @notice Library collection of diamond ownership functions\\nlibrary LibDiamondOwnership {\\n    /// @notice Emitted when diamond owner is updated\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Updates the diamond owner to @param _newOwner's address\\n    function setContractOwner(DiamondState storage self, address _newOwner) internal {\\n        address previousOwner = self.contractOwner;\\n        self.contractOwner = _newOwner;\\n\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    /// @notice Returns the diamond @return contractOwner_'s address\\n    function getContractOwner(DiamondState storage self) internal view returns (address contractOwner_) {\\n        contractOwner_ = self.contractOwner;\\n    }\\n\\n    /// @notice Checks if `msg.sender` is the diamond owner\\n    function enforceIsContractOwner(DiamondState storage self) internal view {\\n        if (msg.sender != self.contractOwner) revert DiamondErrors.MustBeDiamondOwner(msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0xd3f4d72fea315ac0781dfc55f5f2b9d8e11262d360f7578ef591228cc385b8d0\",\"license\":\"MIT\"},\"src/contracts/domain/facets/UIDataFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {LibUI} from \\\"../libraries/logic/LibUI.sol\\\";\\n\\n/// @title UIDataFacet\\n/// @notice UI aggregated data\\n/// @dev Make changes depending on the front-end model. This implementation is conceptual\\n/// @custom:version 0.0.1\\ncontract UIDataFacet {\\n    /* =================================== Global ============================================================================================ */\\n\\n    /// @notice Gets global-related data of the protocol\\n    /// @notice Aggregated view of the allowed tokens in @return allowedTokensBatch; in @return mTokenAddress \\u2014 the address of the\\n    /// interest-bearing token\\n    function getProtocolTokens()\\n        external\\n        view\\n        returns (LibUI.AllowedTokenData[] memory allowedTokensBatch, address mTokenAddress)\\n    {\\n        allowedTokensBatch = LibUI.batchAllowedTokens();\\n        mTokenAddress = LibUI.mTokenAddress();\\n    }\\n\\n    /* =================================== User's ============================================================================================ */\\n\\n    /// @notice Returns the maximum amount in USD that can be borrowed based on @param _collateralAddress\\n    /// and @param _collateralAmount values\\n    /// @dev `_collateralAmount` must be a whole number\\n    function getMaxUsdToBorrow(\\n        address _collateralAddress,\\n        uint256 _collateralAmount\\n    ) external view returns (uint256 maxUsdToBorrow) {\\n        maxUsdToBorrow = LibUI.maxUsdToBorrow(_collateralAddress, _collateralAmount);\\n    }\\n\\n    /// @notice Aggregated view of @param _account's staked tokens in @return stakedTokensBatch\\n    function getStakedTokens(\\n        address _account\\n    ) external view returns (LibUI.StakedTokenData[] memory stakedTokensBatch) {\\n        stakedTokensBatch = LibUI.batchStakedTokens(_account);\\n    }\\n\\n    /// @notice Aggregated view of @param _account's borrowed tokens in @return borrowedTokensBatch\\n    function getBorrowedTokens(\\n        address _account\\n    ) external view returns (LibUI.BorrowedTokenData[] memory borrowedTokensBatch) {\\n        borrowedTokensBatch = LibUI.batchBorrowedTokens(_account);\\n    }\\n\\n    /* =================================== Keeper's ============================================================================================ */\\n\\n    /// @notice Returns all borrowers in the protocol as @return allBorrowers\\n    function getAllBorrowers() external view returns (address[] memory allBorrowers) {\\n        allBorrowers = LibUI.allBorrowers();\\n    }\\n\\n    /// @notice Gets relevant @param _account information. Returns it as @return data\\n    function getAccountData(address _accountAddress) external view returns (LibUI.AccountData memory accountData) {\\n        accountData = LibUI.batchAccountData(_accountAddress);\\n    }\\n\\n    /// @notice Checks if the @param _account is liquidatable based on @param _collateralAddress and @param _borrowedTokenAddress.\\n    /// @return result `true` if it is, otherwise `false`\\n    function isLiquidatable(\\n        address _account,\\n        address _collateralAddress,\\n        address _borrowedTokenAddress\\n    ) external view returns (bool result) {\\n        result = LibUI.isLiquidatable(_account, _collateralAddress, _borrowedTokenAddress);\\n    }\\n}\\n\",\"keccak256\":\"0xda315f874870cea85ee554164faa61f8bbec75cf8fe074178b02d4fc578ae7de\",\"license\":\"MIT\"},\"src/contracts/domain/interfaces/IAggregatorV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IAggregatorV3\\n/// @notice This interface enables utilization of Chainlink data feeds\\ninterface IAggregatorV3 {\\n    /// @notice Returns the number of decimals in the response\\n    /// @return {uint8}\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Gets data from the latest round\\n    /// @return roundId The round ID\\n    /// @return answer The data that this specific feed provides\\n    /// @return startedAt Timestamp of when the round started\\n    /// @return updatedAt Timestamp of when the round was updated\\n    /// @return answeredInRound Deprecated. Previously used when answers could take multiple rounds to be computed\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\",\"keccak256\":\"0xf6e216dc33b61ef00f056ccd84e6a9ced64db2dd98a604cafbc5193978485bd2\",\"license\":\"MIT\"},\"src/contracts/domain/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IERC20\\n/// @notice Interface for standard ERC20 implementation\\ninterface IERC20 {\\n    /// @notice Emmited when @param value tokens are moved @param from to @param to account\\n    /// @dev `value` may be zero\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Emitted when the allowance of a @param spender for an @param owner is\\n    /// set by a call to {approve}. @param value is the new allowance\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the name of the token\\n    /// @return {string}\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the decimals places of the token\\n    /// @return {uint8}\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the value of tokens in existence\\n    /// @return {uint256}\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the value of tokens owned by @param _owner\\n    /// @return {uint256}\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Moves a @param _value amount of tokens from the caller's account to @param _to\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    /// @dev Emits a {Transfer} event\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Moves a @param _value amount of tokens from @param _from to @param _to using the\\n    /// allowance mechanism. @param _value is then deducted from the caller's allowance\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Sets a @param _value amount of tokens as the allowance of @param _spender over the\\n    /// caller's tokens\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    /// @custom:security Beware that changing an allowance with this method brings the risk\\n    /// that someone may use both the old and the new allowance by unfortunate transaction ordering.\\n    /// One possible solution to mitigate this race condition is to first reduce the spender's\\n    /// allowance to 0 and set the desired value afterwards:\\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x4f7671ce89e6f77621e67d6f9992f18832ed317612c0ab61be741628887ef37f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/AssetsState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {LibDeposit} from \\\"./logic/LibDeposit.sol\\\";\\nimport {LibBorrow} from \\\"./logic/LibBorrow.sol\\\";\\nimport {LibRepay} from \\\"./logic/LibRepay.sol\\\";\\nimport {LibWithdraw} from \\\"./logic/LibWithdraw.sol\\\";\\nimport {LibLiquidation} from \\\"./logic/LibLiquidation.sol\\\";\\nimport {LibCalculator} from \\\"./logic/LibCalculator.sol\\\";\\nimport {IAggregatorV3} from \\\"../interfaces/IAggregatorV3.sol\\\";\\nimport {DomainErrors} from \\\"../../helpers/Errors.sol\\\";\\n\\nusing LibDeposit for AssetsState global;\\nusing LibBorrow for AssetsState global;\\nusing LibRepay for AssetsState global;\\nusing LibWithdraw for AssetsState global;\\nusing LibLiquidation for AssetsState global;\\nusing LibCalculator for AssetsState global;\\n\\n/// @notice Defines the properties for an allowed token\\n/// @dev Parameters used for calculations are present in basis points. For example,\\n/// 1000 basis points = a 10 % staking stable rate\\nstruct AllowedToken {\\n    /// @notice Used as a parameter (on withdrawing) for calculating the daily interest (in tokens)\\n    /// for *solely* staking the token\\n    uint16 stakeStableRate;\\n    /// @notice Used as a parameter (on repaying) for calculating the daily interest (in tokens) to\\n    /// be paid back for a borrowed token\\n    uint16 borrowStableRate;\\n    /// @notice The token's LTV ratio. Higher value \\u2014 higher risk for the protocol's health\\n    uint16 ltv;\\n    /// @notice The token's liquidation threshold. If the borrowed amount in USD surpasses\\n    /// this limit, the borrower should be liquidated\\n    /// @dev 8_000 BPs = 80 % of the collateral\\n    uint16 liquidationThreshold;\\n    /// @notice Returns `true` if the token is allowed, otherwise `false`\\n    bool isAllowed;\\n    /// @notice The address of the token used for setting up the protocol's allowed tokens\\n    address tokenAddress;\\n    /// @notice The address of the Chainlink data feed\\n    IAggregatorV3 dataFeed;\\n}\\n\\n/// @notice Defines the properties for a staked token\\nstruct StakedToken {\\n    /// @notice The staked amount\\n    uint256 amountStaked;\\n    /// @notice Marks the start of the staking period, measured in seconds since the Unix epoch (block.timestamp)\\n    uint256 startAccumulatingDay;\\n    /// @notice Returns `true` if the token is staked, otherwise `false`\\n    bool isStaked;\\n    /// @notice Returns `true` if the token can be used as collateral for borrowing\\n    bool isCollateralOn;\\n    /// @notice Returns `true` if the token is currently used as collateral for a borrowed token\\n    bool isCollateralInUse;\\n}\\n\\n/// @notice Defines the properties for a borrowed token\\nstruct BorrowedToken {\\n    /// @notice The borrowed amount\\n    uint256 amountBorrowed;\\n    /// @notice Marks the start of the borrowing period, measured in seconds since the Unix epoch (block.timestamp)\\n    uint256 startAccumulatingDay;\\n    /// @notice Returns `true` if the token is borrowed, otherwise `false`\\n    bool isBorrowed;\\n    /// @notice The address of the used collateral\\n    address collateralAddress;\\n    /// @notice The amount tokens used for the borrow\\n    uint256 collateralAmount;\\n}\\n\\n/// @notice Struct defining the current assets state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `AssetsState`\\nstruct AssetsState {\\n    /// @notice Protocol's allowed tokens data. Token address -> token data\\n    mapping(address => AllowedToken) allowedTokenData;\\n    /// @notice Protocol's allowed tokens\\n    address[] allowedTokens;\\n    // ======================= STAKE ===========================================================\\n    /// @notice Account -> token address -> staking data\\n    mapping(address => mapping(address => StakedToken)) stakedTokenData;\\n    /// @notice Account -> array of staked token addresses\\n    mapping(address => address[]) stakedTokens;\\n    // ======================= BORROW ===========================================================\\n    /// @notice Account -> token address -> borrowing data\\n    mapping(address => mapping(address => BorrowedToken)) borrowedTokenData;\\n    /// @notice Account -> array of borrowed token addressess\\n    mapping(address => address[]) borrowedTokens;\\n    /// @notice Protocol's borrowers\\n    address[] borrowers;\\n}\\n\\n/* ============================= Pointer =============================================================================== */\\n\\nbytes32 constant ASSETS_STORAGE_POSITION = keccak256(\\\"martinivv.assets.storage\\\");\\n\\n/// @notice Used as a shared storage\\n/// @return ast Storage pointer to `AssetsState` struct\\n/// @dev Any operation involving `ast` will read from or write to **storage**\\nfunction a() pure returns (AssetsState storage ast) {\\n    bytes32 position = ASSETS_STORAGE_POSITION;\\n\\n    assembly {\\n        ast.slot := position\\n    }\\n}\\n\\n/* ============================= Modifiers =============================================================================== */\\n\\n/// @notice Includes modifiers shared across protocol's contracts\\nabstract contract AssetsModifiers {\\n    /* ============================= Deposit & Borrow =========================================================== */\\n\\n    /// @notice Checks if @param _tokenAddress is allowed and @param _tokenAmount is greater than 0\\n    /// @custom:security Zero value ERC20 transfers are terminated in the protocol\\n    modifier allowed(address _tokenAddress, uint256 _tokenAmount) {\\n        if (!a().allowedTokenData[_tokenAddress].isAllowed) {\\n            revert DomainErrors.TokenNotAllowed(msg.sender, _tokenAddress);\\n        }\\n        if (_tokenAmount == 0) revert DomainErrors.AmountShouldBePositive(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Looks the @param _tokenAddress's collateral option to be enabled\\n    /// @custom:security When enabled, it is checked whether it is staked or not\\n    modifier enabledCollateral(address _tokenAddress) {\\n        if (!a().stakedTokenData[msg.sender][_tokenAddress].isCollateralOn) {\\n            revert DomainErrors.CollateralNotEnabled(msg.sender, _tokenAddress);\\n        }\\n        _;\\n    }\\n\\n    /// @notice Looks the @param _collateralAddress to not be currently in use\\n    /// @custom:security The property `isCollateralInUse` is controlled in `BorrowFacet` and\\n    /// `RepayFacet`, the necessary checks are made\\n    modifier notInUseCollateral(address _collateralAddress) {\\n        if (!a().stakedTokenData[msg.sender][_collateralAddress].isStaked) {\\n            revert DomainErrors.TokenNotStaked(msg.sender, _collateralAddress);\\n        }\\n        if (a().stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse) {\\n            revert DomainErrors.CollateralCurrentlyInUse();\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Repay =========================================================== */\\n\\n    /// @notice Looks @param _collateralAddress and @param _borrowedToken to be repayable\\n    /// @custom:security Checking the validity of the `_collateralAddress` is crucial for the\\n    /// protocol security, otherwise could lead to critical vulnerability\\n    modifier repayableCollateral(address _collateralAddress, address _borrowedToken) {\\n        if (a().borrowedTokenData[msg.sender][_borrowedToken].collateralAddress != _collateralAddress) {\\n            revert DomainErrors.CollateralMismatch();\\n        }\\n        if (!a().stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse) {\\n            revert DomainErrors.CollateralNotInUse();\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Liquidation =========================================================== */\\n\\n    /// @notice Looks @param _borrower and @param _borrowedToken to be liquidatable\\n    modifier liquidatable(address _borrower, address _borrowedToken) {\\n        if (msg.sender == _borrower) revert DomainErrors.SelfLiquidationNotAllowed();\\n        if (!a().borrowedTokenData[_borrower][_borrowedToken].isBorrowed) {\\n            revert DomainErrors.TokenNotBorrowed(msg.sender, _borrowedToken);\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Global =========================================================== */\\n\\n    /// @notice Looks @param _tokenAmount to be positive\\n    modifier positiveAmount(uint256 _tokenAmount) {\\n        if (_tokenAmount == 0) revert DomainErrors.AmountShouldBePositive(msg.sender);\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x60b9d2140d47818d4cc2996e0161daf9eb703ca53f5b506660aa3b30bea5f73f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/ProtocolState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {DomainConstants} from \\\"../../helpers/Constants.sol\\\";\\nimport {DomainErrors} from \\\"../../helpers/Errors.sol\\\";\\nimport {d} from \\\"../../diamond/libraries/DiamondState.sol\\\";\\n\\n/// @notice Struct defining the current protocol state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `ProtocolState`\\nstruct ProtocolState {\\n    /// @notice Reentrancy guard's property\\n    uint256 reentrancyStatus;\\n    /// @notice The address of the interest-bearing token\\n    address mTokenAddress;\\n    /// @notice Staleness prevention for the Chainlink oracle response\\n    uint32 answerStalenessThreshold;\\n}\\n\\n/* ============================= Pointer ============================================================================= */\\n\\nbytes32 constant PROTOCOL_STORAGE_POSITION = keccak256(\\\"martinivv.protocol.storage\\\");\\n\\n/// @notice Used as a shared storage among libraries\\n/// @return ps Storage pointer to `DiamondState` struct\\n/// @dev Any operation involving `ps` will read from or write to **storage**\\nfunction p() pure returns (ProtocolState storage ps) {\\n    bytes32 position = PROTOCOL_STORAGE_POSITION;\\n\\n    assembly {\\n        ps.slot := position\\n    }\\n}\\n\\n/* ============================= Modifiers ============================================================================= */\\n\\n/// @notice Includes modifiers shared across protocol's contracts\\n/// @custom:advice Consider adding more robust access control management\\nabstract contract ProtocolModifiers {\\n    /// @notice Prevents a contract from calling itself, over and over, directly or indirectly\\n    /// @dev Forked OZ implementation. Avoids state storage collision within diamond\\n    /// @dev By storing the original value once again at the end, a refund is triggered (see\\n    /// https://eips.ethereum.org/EIPS/eip-2200)\\n    modifier nonReentrant() {\\n        if (p().reentrancyStatus == DomainConstants._ENTERED) revert DomainErrors.ReentrantCall();\\n\\n        p().reentrancyStatus = DomainConstants._ENTERED;\\n        _;\\n\\n        p().reentrancyStatus = DomainConstants._NOT_ENTERED;\\n    }\\n\\n    /// @notice Access control modifier. Ensures that the method is called only by the diamond owner\\n    modifier onlyOwner() {\\n        d().enforceIsContractOwner();\\n        _;\\n    }\\n\\n    /// @notice Initializes reentrancy guard on diamond deployment\\n    function _initReentrancyGuard() internal {\\n        p().reentrancyStatus = DomainConstants._NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x18cdfee5c086a3e8a58182330615629996fcde2d1f18ae21a3a552b8e3abbcd9\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibBorrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibBorrow\\nlibrary LibBorrow {\\n    using Array for address[];\\n\\n    /// @notice Verifies the truth of account parameters and records the borrow\\n    /// @param _collateralAddress The address of the token used as collateral for the borrow\\n    /// @param _tokenAddress The address of the borrowed token\\n    /// @param _tokenAmount The amount to be borrowed\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:advice If `_tokenAmount` cannot be borrowed, consider implementing logic where\\n    /// the maximum available token amount is passed to the `BorrowFacet`\\n    /// @custom:exec Sanity checks (internal calls to `LibCalculator`) -> internal state updates\\n    function verifyAndRecordBorrow(\\n        AssetsState storage self,\\n        address _collateralAddress,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal returns (uint256 scaledAmount) {\\n        /* ========================= Sanity checks ======================================================================== */\\n\\n        (uint256 collateralAmount, uint256 maxToBorrowInUsd) = self.getMaxAmountToBorrowInUsd(_collateralAddress);\\n        uint256 amountToBeBorrowedInUsd = self.getNormalizedUsdEquivalent(_tokenAddress, _tokenAmount);\\n\\n        if (amountToBeBorrowedInUsd > maxToBorrowInUsd) {\\n            revert DomainErrors.CannotBorrowAmount(msg.sender, maxToBorrowInUsd, amountToBeBorrowedInUsd);\\n        }\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n        scaledAmount = _tokenAmount * 10 ** decimals;\\n\\n        if (token.balanceOf(address(this)) < scaledAmount) revert DomainErrors.InsufficientProtocolFunds();\\n\\n        /* ========================= Updating internal state ======================================================================== */\\n\\n        BorrowedToken storage borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        bool isTokenBorrowed = borrowedToken.isBorrowed;\\n\\n        if (isTokenBorrowed) {\\n            address collateralInUse = borrowedToken.collateralAddress;\\n            if (_collateralAddress != collateralInUse) revert DomainErrors.CollateralMismatch();\\n\\n            borrowedToken.amountBorrowed += _tokenAmount;\\n        } else {\\n            BorrowedToken memory currentToken = BorrowedToken({\\n                amountBorrowed: _tokenAmount,\\n                startAccumulatingDay: block.timestamp,\\n                isBorrowed: true,\\n                collateralAddress: _collateralAddress,\\n                collateralAmount: collateralAmount\\n            });\\n\\n            // Always manage together!\\n            self.borrowedTokenData[msg.sender][_tokenAddress] = currentToken;\\n            self.borrowedTokens[msg.sender].push(_tokenAddress);\\n            // =======\\n            self.borrowers.safePush(msg.sender);\\n\\n            self.stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse = true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6378e24efb17284ef19a5e2cf4d108962660c1deacee51b286eef57b292e3f2f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {AssetsState} from \\\"../AssetsState.sol\\\";\\n// Add remappings\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {p} from \\\"../ProtocolState.sol\\\";\\nimport {IAggregatorV3} from \\\"../../interfaces/IAggregatorV3.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibCalculator\\n/// @custom:advice If needed, implement max ratio constant\\nlibrary LibCalculator {\\n    /// @notice Gets the borrowing power in USD\\n    /// @param _collateralAddress The address of the used collateral for the borrow\\n    /// @return collateralAmount The amount of the used collateral\\n    /// @return maxToBorrowInUsd The maximum USD amount you can borrow\\n    /// @dev LTV ratio is represented in basis points, 500 basis points = 5 %\\n    /// @custom:security Reverts if the extraction in `value` results in a negative value\\n    /// @custom:security The integral business model is not considered, may occur wrong calculations, loss of funds.\\n    /// It's a demo version\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    /// @custom:exec Gets the USD equivalent of the collateral amount -> calculates the\\n    /// max borrowing amount in USD\\n    function getMaxAmountToBorrowInUsd(\\n        AssetsState storage self,\\n        address _collateralAddress\\n    ) internal view returns (uint256 collateralAmount, uint256 maxToBorrowInUsd) {\\n        collateralAmount = self.stakedTokenData[msg.sender][_collateralAddress].amountStaked;\\n        uint256 collateralInUsd = getNormalizedUsdEquivalent(self, _collateralAddress, collateralAmount);\\n        uint16 tokenLtv = self.allowedTokenData[_collateralAddress].ltv;\\n\\n        // Calculates the result of the expression `collateralInUsd - (collateralInUsd * tokenLtv / BASIS_POINTS)`.\\n        // The calculation within the parentheses is rounded down\\n        uint256 denominator = DomainConstants.BASIS_POINTS;\\n        assembly {\\n            let z := mul(collateralInUsd, tokenLtv)\\n\\n            if iszero(\\n                and(iszero(iszero(denominator)), or(iszero(collateralInUsd), eq(div(z, collateralInUsd), tokenLtv)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(z, denominator)\\n            maxToBorrowInUsd := sub(collateralInUsd, z)\\n        }\\n    }\\n\\n    /// @notice Calculates the USD equivalent value of a token amount\\n    /// @param _tokenAddress The token's address\\n    /// @param _tokenAmount The token amount\\n    /// @return value The normalized USD value obtained by `tokenAmount *\\n    /// the token's USD price / decimals to be removed`\\n    function getNormalizedUsdEquivalent(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 value) {\\n        (uint256 oracleResponse, uint8 decimals) = _getTokenPriceInUsd(self, _tokenAddress);\\n\\n        value = (_tokenAmount * oracleResponse) / (10 ** decimals);\\n    }\\n\\n    /// @notice Gets the raw price and decimals of an allowed token\\n    /// @param _tokenAddress The allowed token\\n    /// @return oracleResponse Returns the raw price with `decimals`, not divided by a decimal point\\n    /// @return decimals *Typically* comes with a value of 8\\n    /// @custom:security Consider implementing backup oracle(-s) logic in case of failure;\\n    /// TWAP or other verifiably secure options are recommended\\n    function _getTokenPriceInUsd(\\n        AssetsState storage state,\\n        address _tokenAddress\\n    ) private view returns (uint256 oracleResponse, uint8 decimals) {\\n        IAggregatorV3 dataFeed = state.allowedTokenData[_tokenAddress].dataFeed;\\n\\n        try dataFeed.latestRoundData() returns (uint80 roundId, int256 answer, uint256, uint256 updatedAt, uint80) {\\n            if (answer < 1) revert DomainErrors.AnswerShouldBePositiveNum(roundId, answer);\\n\\n            if (updatedAt == 0) revert DomainErrors.InvalidTime(roundId, updatedAt);\\n\\n            if (block.timestamp - updatedAt > p().answerStalenessThreshold) {\\n                revert DomainErrors.StalePrice(roundId);\\n            }\\n\\n            oracleResponse = uint256(answer);\\n        } catch {\\n            revert DomainErrors.OracleNotAvailable(dataFeed);\\n        }\\n\\n        decimals = dataFeed.decimals();\\n    }\\n}\\n\",\"keccak256\":\"0x036a955a0cf1baf620f4d0b1af90796db1b0c1cf332671c15f642055b4dd6861\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibDeposit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {SafeERC20} from \\\"../../vendor/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {AssetsState, StakedToken} from \\\"../AssetsState.sol\\\";\\nimport {p} from \\\"../ProtocolState.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DomainEvents} from \\\"../../../helpers/Events.sol\\\";\\n\\n/// @title LibDeposit\\nlibrary LibDeposit {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice Manages the deposit by changing the internal protocol state. Then sends mTokens\\n    /// @param _tokenAddress The deposited token address\\n    /// @param _tokenAmount The token amount without decimals\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    function manageDeposit(AssetsState storage self, address _tokenAddress, uint256 _tokenAmount) internal {\\n        StakedToken storage stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        bool isTokenStaked = stakedToken.isStaked;\\n\\n        if (isTokenStaked) {\\n            stakedToken.amountStaked += _tokenAmount;\\n            stakedToken.startAccumulatingDay = block.timestamp;\\n        } else {\\n            StakedToken memory currentToken = StakedToken({\\n                amountStaked: _tokenAmount,\\n                startAccumulatingDay: block.timestamp,\\n                isStaked: true,\\n                isCollateralOn: false,\\n                isCollateralInUse: false\\n            });\\n\\n            // Always manage together!\\n            self.stakedTokenData[msg.sender][_tokenAddress] = currentToken;\\n            self.stakedTokens[msg.sender].push(_tokenAddress);\\n            // =======\\n        }\\n\\n        _sendMTokens(self, _tokenAddress, _tokenAmount);\\n    }\\n\\n    /// @notice Sends mTokens; the interest-bearing token back for a deposited token\\n    /// @param _tokenAddress The deposited token's address\\n    /// @param _tokenAmount The deposited token's amount\\n    /// @custom:security Ensure you're using the right decimals, otherwise this can lead\\n    /// to wrong calculations, misleading errors, loss of funds\\n    /// @custom:advice Consider implementing event monitoring for the interest-bearing token\\n    function _sendMTokens(AssetsState storage state, address _tokenAddress, uint256 _tokenAmount) private {\\n        // The price of the token amount without decimals\\n        uint256 sendAmount = state.getNormalizedUsdEquivalent(_tokenAddress, _tokenAmount);\\n\\n        IERC20 mToken = IERC20(p().mTokenAddress);\\n        uint8 decimals = mToken.decimals();\\n\\n        uint256 scaledAmount = sendAmount * 10 ** decimals;\\n        if (scaledAmount > mToken.balanceOf(address(this))) revert DomainErrors.NotEnoughTokensInExistence();\\n\\n        emit DomainEvents.Deposit(_tokenAddress, _tokenAmount, msg.sender);\\n        mToken.safeTransfer(msg.sender, scaledAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x010dfa516db0f0fba5b957570002521220dd65f19cb7a081f17c0d021179439a\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibLiquidation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\n\\n/// @title LibLiquidation\\nlibrary LibLiquidation {\\n    using Array for address[];\\n\\n    /// @notice Returns keeper's @return rewardInTokens, otherwise, if the @param _borrower is not\\n    /// for liquidation, reverts\\n    /// @param _borrowedToken The address of the borrowed token\\n    /// @dev Calculations once again are in basis points. 8_000 BPs = 80 %\\n    /// @custom:advice Consider adding another mechanism instead of reverting; if needed\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    /// @custom:security Gives 50 % (5_000 BPs) of the reward to the keeper to establish some form\\n    /// of equilibrium in the protocol (pays interest to the supporters). Don't forget that this\\n    /// is a DEFI protocol\\n    function manageLiquidation(\\n        AssetsState storage self,\\n        address _borrower,\\n        address _borrowedToken\\n    ) internal view returns (address collateralAddress, uint256 rewardInTokens) {\\n        BorrowedToken memory borrowedToken = self.borrowedTokenData[_borrower][_borrowedToken];\\n\\n        /* ==================================== Is liquidatable? =========================================================================== */\\n\\n        // ========== Collateral in USD ==============================\\n        collateralAddress = borrowedToken.collateralAddress;\\n        uint256 collateralAmount = self.stakedTokenData[_borrower][collateralAddress].amountStaked;\\n        uint256 collateralInUsd = self.getNormalizedUsdEquivalent(collateralAddress, collateralAmount);\\n\\n        // ========== Borrowed in USD ==============================\\n        uint256 borrowedAmount = borrowedToken.amountBorrowed;\\n        uint256 borrowedInUsd = self.getNormalizedUsdEquivalent(_borrowedToken, borrowedAmount);\\n\\n        // ========== Finding the limit ==============================\\n        uint16 collateralThreshold = self.allowedTokenData[collateralAddress].liquidationThreshold;\\n        // For example. `8_000 * 1000 / 10_000` equals to `800`\\n        uint256 limitInUsd = (collateralThreshold * collateralInUsd) / DomainConstants.BASIS_POINTS;\\n        if (borrowedInUsd < limitInUsd) revert DomainErrors.NotLiquidatable(msg.sender);\\n\\n        /* =============================== Calculating the keeper reward ========================================================================== */\\n\\n        // `(5_000 * (2400 - 2000)) / 10_000` equals to `200`\\n        uint256 rewardInUsd = (5_000 * (borrowedInUsd - limitInUsd)) / DomainConstants.BASIS_POINTS;\\n        uint256 singleTokenPrice = rewardInUsd / borrowedAmount;\\n        uint8 decimals = IERC20(_borrowedToken).decimals();\\n        rewardInTokens = (rewardInUsd * 10 ** decimals) / singleTokenPrice;\\n    }\\n\\n    /// @notice Records the liquidation into the internal state\\n    /// @param _borrower The address of the borrower\\n    /// @param _collateralAddress The address of the used collateral token\\n    /// @param _borrowedToken The address of the borrowed token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    function recordLiquidation(\\n        AssetsState storage self,\\n        address _borrower,\\n        address _collateralAddress,\\n        address _borrowedToken\\n    ) internal {\\n        delete self.stakedTokenData[_borrower][_collateralAddress];\\n        self.stakedTokens[_borrower].remove(_collateralAddress);\\n\\n        delete self.borrowedTokenData[_borrower][_borrowedToken];\\n        self.borrowedTokens[_borrower].remove(_borrowedToken);\\n    }\\n}\\n\",\"keccak256\":\"0x398b9d536aabd5fbcb25334067cf236f1cbbc08e189f72645e5944299ac93fbf\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibRepay.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibRepay\\nlibrary LibRepay {\\n    using Array for address[];\\n\\n    /// @notice Makes internal changes\\n    /// @param _collateralAddress The address of the used collateral token\\n    /// @param _tokenAddress The address of the repaid token\\n    /// @param _verifiedAmount The verified amount of the repaid token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:security Can't occur the mapping/array vulnerability where the mapping/array remains accessible\\n    /// even after deletion, because in this case it's not nested\\n    function recordRepay(\\n        AssetsState storage self,\\n        address _collateralAddress,\\n        address _tokenAddress,\\n        uint256 _verifiedAmount\\n    ) internal {\\n        BorrowedToken storage borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        // Still hasn't been updated\\n        uint256 currentAmount = borrowedToken.amountBorrowed;\\n\\n        if (_verifiedAmount == currentAmount) {\\n            // Always manage together!\\n            delete self.borrowedTokenData[msg.sender][_tokenAddress];\\n            self.borrowedTokens[msg.sender].remove(_tokenAddress);\\n            // =======\\n            if (self.borrowedTokens[msg.sender].length == 0) self.borrowers.remove(msg.sender);\\n\\n            // Managing the collateral token\\n            self.stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse = false;\\n        } else {\\n            borrowedToken.amountBorrowed -= _verifiedAmount;\\n        }\\n    }\\n\\n    /// @notice Calculates the amount to be repaid\\n    /// @param _tokenAddress The borrowed token\\n    /// @param _tokenAmount The borrowed amount\\n    /// @return verifiedAmount Ensures correct state changes in {recordRepay}\\n    /// @return totalToRepay The amount with the right token decimals\\n    /// @custom:security The integral business model is not considered; wrong calculations and loss of funds may occur.\\n    /// Calculations are only used for demo purposes\\n    /// @custom:security If `startAccumulatingDay` is in the current day, `verifiedNumDays` will receive a value of\\n    /// 1 (day) to ensure proper calculations in the current version, thereby preventing a critical vulnerability\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    function calculateAmountToRepay(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 verifiedAmount, uint256 totalToRepay) {\\n        /* ============================== Setup =========================================================================== */\\n\\n        BorrowedToken memory borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 borrowedAmount = borrowedToken.amountBorrowed;\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n\\n        verifiedAmount = (_tokenAmount > borrowedAmount ? borrowedAmount : _tokenAmount);\\n        uint256 scaledAmount = verifiedAmount * 10 ** decimals;\\n\\n        /* ============================== Interest =========================================================================== */\\n\\n        uint256 startAccumulatingDay = borrowedToken.startAccumulatingDay;\\n        uint16 tokenBorrowStableRate = self.allowedTokenData[_tokenAddress].borrowStableRate;\\n\\n        uint256 numDays = (block.timestamp - startAccumulatingDay) / DomainConstants.SECONDS_PER_DAY;\\n\\n        uint256 verifiedNumDays = numDays > 0 ? numDays : 1;\\n        // For example. `100e18 * 500 / 10_000` equals to `5e18`\\n        uint256 dailyInterestInTokens = (scaledAmount * tokenBorrowStableRate) / DomainConstants.BASIS_POINTS;\\n        // `15 * 5e18 / 365` equals to `(0.)205479452054794520`\\n        uint256 accumulatedInterestInTokens = (verifiedNumDays * dailyInterestInTokens) / DomainConstants.DAYS_PER_YEAR;\\n\\n        /* ============================== Finalization =========================================================================== */\\n\\n        // `100e18 + 205479452054794520` equals to `100205479452054794520`\\n        totalToRepay = scaledAmount + accumulatedInterestInTokens;\\n\\n        if (token.balanceOf(msg.sender) < totalToRepay) revert DomainErrors.InsufficientTokenAmount();\\n    }\\n}\\n\",\"keccak256\":\"0xeeb666ad7ba6012c8715c34fe53b0e5b71113bedad8a5d947a977f6ba4abc7a3\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibUI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {AllowedToken, a, AssetsState, StakedToken, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {p} from \\\"../ProtocolState.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\n\\n/// @title LibUI\\n/// @notice Methods that return requested data\\nlibrary LibUI {\\n    /// @notice Returned as a data in {batchAllowedTokens}\\n    struct AllowedTokenData {\\n        address tokenAddress;\\n        uint16 stakeStableRate;\\n        uint16 borrowStableRate;\\n        uint16 ltv;\\n        uint16 liquidationThreshold;\\n        string name;\\n    }\\n\\n    /// @notice Returned as a data in {batchStakedTokens}\\n    struct StakedTokenData {\\n        uint256 amountStaked;\\n        uint256 startAccumulatingDay;\\n        address tokenAddress;\\n        bool isCollateralOn;\\n        bool isCollateralInUse;\\n        string name;\\n    }\\n\\n    /// @notice Returned as a data in {batchBorrowedTokens}\\n    struct BorrowedTokenData {\\n        uint256 amountBorrowed;\\n        uint256 startAccumulatingDay;\\n        string name;\\n        address tokenAddress;\\n        address collateralAddress;\\n        uint256 collateralAmount;\\n    }\\n\\n    /// @notice Returned as a data in {accountData}\\n    struct AccountData {\\n        address[] stakedTokens;\\n        address[] borrowedTokens;\\n    }\\n\\n    /* ======================================= Global ============================================================================================ */\\n\\n    /// @notice Batches allowed tokens related info in @return data\\n    function batchAllowedTokens() internal view returns (AllowedTokenData[] memory data) {\\n        address[] memory tokens = a().allowedTokens;\\n\\n        uint256 length = tokens.length;\\n        data = new AllowedTokenData[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            address tokenAddr = tokens[i];\\n            AllowedToken memory token = a().allowedTokenData[tokenAddr];\\n\\n            data[i] = AllowedTokenData({\\n                tokenAddress: tokenAddr,\\n                stakeStableRate: token.stakeStableRate,\\n                borrowStableRate: token.borrowStableRate,\\n                ltv: token.ltv,\\n                liquidationThreshold: token.liquidationThreshold,\\n                name: IERC20(tokenAddr).name()\\n            });\\n        }\\n    }\\n\\n    /// @notice Returns the address of the interest-bearing token in @return data\\n    function mTokenAddress() internal view returns (address data) {\\n        data = p().mTokenAddress;\\n    }\\n\\n    /* ======================================= User's ============================================================================================ */\\n\\n    /// @notice Calculates the maximum amount in USD that can be borrowed based on @param _collateralAddress\\n    /// and @param _collateralAmount values\\n    /// @return value as a whole number\\n    function maxUsdToBorrow(\\n        address _collateralAddress,\\n        uint256 _collateralAmount\\n    ) internal view returns (uint256 value) {\\n        if (!a().allowedTokenData[_collateralAddress].isAllowed) {\\n            revert DomainErrors.UI__TokenNotAllowed(msg.sender, _collateralAddress);\\n        }\\n\\n        uint256 collateralInUsd = a().getNormalizedUsdEquivalent(_collateralAddress, _collateralAmount);\\n        uint16 tokenLtv = a().allowedTokenData[_collateralAddress].ltv;\\n\\n        // Calculates the result of the expression `collateralInUsd - (collateralInUsd * tokenLtv / BASIS_POINTS)`.\\n        // The calculation within the parentheses is rounded down\\n        uint256 denominator = DomainConstants.BASIS_POINTS;\\n        assembly {\\n            let z := mul(collateralInUsd, tokenLtv)\\n\\n            if iszero(\\n                and(iszero(iszero(denominator)), or(iszero(collateralInUsd), eq(div(z, collateralInUsd), tokenLtv)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(z, denominator)\\n            value := sub(collateralInUsd, z)\\n        }\\n    }\\n\\n    /// @notice Batches related info for the staked tokens of @param _account and returns it in @return data\\n    function batchStakedTokens(address _account) internal view returns (StakedTokenData[] memory data) {\\n        address[] memory tokens = a().stakedTokens[_account];\\n\\n        uint256 length = tokens.length;\\n        data = new StakedTokenData[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            address tokenAddr = tokens[i];\\n            StakedToken memory token = a().stakedTokenData[_account][tokenAddr];\\n\\n            data[i] = StakedTokenData({\\n                amountStaked: token.amountStaked,\\n                startAccumulatingDay: token.startAccumulatingDay,\\n                tokenAddress: tokenAddr,\\n                isCollateralOn: token.isCollateralOn,\\n                isCollateralInUse: token.isCollateralInUse,\\n                name: IERC20(tokenAddr).name()\\n            });\\n        }\\n    }\\n\\n    /// @notice Batches related info for the borrowed tokens of @param _account and returns it in @return data\\n    function batchBorrowedTokens(address _account) internal view returns (BorrowedTokenData[] memory data) {\\n        address[] memory tokens = a().borrowedTokens[_account];\\n\\n        uint256 length = tokens.length;\\n        data = new BorrowedTokenData[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            address tokenAddr = tokens[i];\\n            BorrowedToken memory token = a().borrowedTokenData[_account][tokenAddr];\\n\\n            data[i] = BorrowedTokenData({\\n                amountBorrowed: token.amountBorrowed,\\n                startAccumulatingDay: token.startAccumulatingDay,\\n                name: IERC20(tokenAddr).name(),\\n                tokenAddress: tokenAddr,\\n                collateralAddress: token.collateralAddress,\\n                collateralAmount: token.collateralAmount\\n            });\\n        }\\n    }\\n\\n    /* ======================================= Keeper's ============================================================================================ */\\n\\n    /// @notice Retrieve a list of all borrowers in the protocol as @return data\\n    function allBorrowers() internal view returns (address[] memory data) {\\n        address[] memory borrowers = a().borrowers;\\n\\n        data = new address[](borrowers.length);\\n        data = borrowers;\\n    }\\n\\n    /// @notice Batches relevant @param account data\\n    function batchAccountData(address _account) internal view returns (AccountData memory data) {\\n        data = AccountData({stakedTokens: a().stakedTokens[_account], borrowedTokens: a().borrowedTokens[_account]});\\n    }\\n\\n    /// @notice Returns @return result indicating the outcome of the check\\n    /// @param _account The address of the account\\n    /// @param _collateralAddress The address of the collateral\\n    /// @param _borrowedTokenAddress The address of the borrowed token\\n    function isLiquidatable(\\n        address _account,\\n        address _collateralAddress,\\n        address _borrowedTokenAddress\\n    ) internal view returns (bool result) {\\n        AssetsState storage ast = a();\\n\\n        // ========= Collateral ============================\\n        uint256 collateralAmount = ast.stakedTokenData[_account][_collateralAddress].amountStaked;\\n        uint256 collateralInUsd = ast.getNormalizedUsdEquivalent(_collateralAddress, collateralAmount);\\n\\n        // ========= Borrowed token ============================\\n        uint256 borrowedAmount = ast.borrowedTokenData[_account][_borrowedTokenAddress].amountBorrowed;\\n        uint256 borrowedInUsd = ast.getNormalizedUsdEquivalent(_borrowedTokenAddress, borrowedAmount);\\n\\n        // ========= Limit ============================\\n        uint256 threshold = ast.allowedTokenData[_collateralAddress].liquidationThreshold;\\n        uint256 limitInUsd = (threshold * collateralInUsd) / DomainConstants.BASIS_POINTS;\\n\\n        result = borrowedInUsd > limitInUsd - 1 ? true : false;\\n    }\\n}\\n\",\"keccak256\":\"0x38467eb4b6df44773e9488410ab323a5071bed6086afe7febbdd843ea6265e6a\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibWithdraw.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, StakedToken} from \\\"../AssetsState.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\n\\n/// @title LibWithdraw\\nlibrary LibWithdraw {\\n    using Array for address[];\\n\\n    /// @notice Records the withdraw, applying the changes to the internal state\\n    /// @param _tokenAddress The address of the withdrawn token\\n    /// @param _verifiedAmount The verified amount of the withdrawn token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:security Can't occur the mapping/array vulnerability where the mapping/array remains accessible\\n    /// even after deletion, because in this case it's not nested\\n    function recordWithdraw(AssetsState storage self, address _tokenAddress, uint256 _verifiedAmount) internal {\\n        StakedToken storage stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 currentAmount = stakedToken.amountStaked;\\n\\n        if (_verifiedAmount == currentAmount) {\\n            // Always manage together!\\n            delete self.stakedTokenData[msg.sender][_tokenAddress];\\n            self.stakedTokens[msg.sender].remove(_tokenAddress);\\n            // =======\\n        } else {\\n            stakedToken.amountStaked -= _verifiedAmount;\\n        }\\n    }\\n\\n    /// @notice Calculates @return withdrawAmount and @return mTokensToBurn. @return verifiedAmount ensures\\n    /// correct state changes in {recordWithdraw}\\n    /// @param _tokenAddress The address of the token to be withdrawn\\n    /// @param _tokenAmount The amount of the token to be withdrawn\\n    /// @custom:security The correct decimals are applied\\n    /// @custom:security The integral business model is not considered; wrong calculations and loss of funds may occur.\\n    /// Calculations are only used for demo purposes\\n    /// @custom:security If `startAccumulatingDay` is in the current day, `verifiedNumDays` will receive a value of\\n    /// 1 (day) to ensure proper calculations in the current version, thereby preventing a critical vulnerability\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    function calculateWithdraw(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 verifiedAmount, uint256 withdrawAmount, uint256 mTokensToBurn) {\\n        /* ========================== Setup ======================================================================== */\\n\\n        StakedToken memory stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 stakedAmount = stakedToken.amountStaked;\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n\\n        // In order to burn the correct amount\\n        verifiedAmount = (_tokenAmount > stakedAmount ? stakedAmount : _tokenAmount);\\n        uint256 scaledWithdraw = verifiedAmount * 10 ** decimals;\\n\\n        /* ========================== Interest, withdrawable amount ======================================================================== */\\n\\n        if (!stakedToken.isCollateralOn) {\\n            uint32 tokenStakeStableRate = self.allowedTokenData[_tokenAddress].stakeStableRate;\\n\\n            uint256 numDays = (block.timestamp - stakedToken.startAccumulatingDay) / DomainConstants.SECONDS_PER_DAY;\\n\\n            uint256 verifiedNumDays = numDays > 0 ? numDays : 1;\\n            // For example. `100e18 * 1000 / 10_000` equals to `10e18`\\n            uint256 dailyInterestInTokens = (scaledWithdraw * tokenStakeStableRate) / DomainConstants.BASIS_POINTS;\\n            // `15 * 10e18 / 365` equals to `(0.)410958904109589041`\\n            uint256 accumulatedInterestInTokens = (verifiedNumDays * dailyInterestInTokens) /\\n                DomainConstants.DAYS_PER_YEAR;\\n\\n            // `100e18 += 410958904109589041` equals to `100410958904109589041`\\n            withdrawAmount = accumulatedInterestInTokens;\\n        }\\n\\n        withdrawAmount += scaledWithdraw;\\n        if (token.balanceOf(address(this)) < withdrawAmount) revert DomainErrors.InsufficientProtocolFunds();\\n\\n        /* ========================== mTokens ======================================================================== */\\n\\n        mTokensToBurn = (self.getNormalizedUsdEquivalent(_tokenAddress, verifiedAmount)) * 10 ** decimals;\\n    }\\n}\\n\",\"keccak256\":\"0xa408f251c75bb9c5c2d3538e61f1a92fe29f9063aba448a51c2bf0d16fb24d14\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/utils/Array.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// Consider adding remappings\\nimport {DomainErrors} from \\\"../../../../helpers/Errors.sol\\\";\\n\\n/// @title Array\\n/// @notice Array helper utils\\nlibrary Array {\\n    /// @notice Removes @param _address from @param _arr\\n    /// @custom:exec Gets the index of `tokenAddress` -> moves the element in the last index, if\\n    /// it's not already there -> removes the last index\\n    function remove(address[] storage _arr, address _address) internal {\\n        uint256 index = _indexOf(_arr, _address);\\n        if (index == 404) revert DomainErrors.Error404();\\n\\n        uint256 lastIndex = _arr.length - 1;\\n\\n        if (index != lastIndex) _arr[index] = _arr[lastIndex];\\n\\n        _arr.pop();\\n    }\\n\\n    /// @notice Pushes @param _address in @param _arr, if doesn't occur\\n    function safePush(address[] storage _arr, address _address) internal {\\n        uint256 index = _indexOf(_arr, _address);\\n\\n        if (index == 404) {\\n            _arr.push(_address);\\n        } else {\\n            revert DomainErrors.TokenAlreadyThere();\\n        }\\n    }\\n\\n    /// @notice Returns the index of @param _address in @param _arr\\n    /// @return i The index of the token's address, otherwise `404`, referencing the popular *Error404*\\n    /// @custom:security Security measures taken for the *for* loop:\\n    /// 1. The array is cached outside, making it gas-optimized;\\n    /// 2. There is no storage array that can grow infinitely;\\n    /// 3. There are no external calls within the loop, potentially preventing a DoS attack\\n    function _indexOf(address[] memory _arr, address _address) private pure returns (uint256 i) {\\n        uint256 length = _arr.length;\\n\\n        for (i; i < length; i++) {\\n            if (_arr[i] == _address) return i;\\n        }\\n\\n        i = 404;\\n    }\\n}\\n\",\"keccak256\":\"0x9da1029c3f2fe8d32ad9c6d2f590e7a3149c01f4818cf6da62d3f25f342a8bcd\",\"license\":\"MIT\"},\"src/contracts/domain/vendor/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n/* solhint-disable avoid-low-level-calls */\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x0f523ff6883ab63bc74f9840a89983d659dfa223db3286b9c82d0e1ead604fac\",\"license\":\"MIT\"},\"src/contracts/helpers/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n// solhint-disable state-visibility\\n\\npragma solidity =0.8.20;\\n\\n/// @title DiamondConstants\\n/// @notice Constants used all around the Diamond logic\\nlibrary DiamondConstants {\\n    /// @notice Diamond's property\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    /// @notice Diamond's property\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n}\\n\\n/// @title DomainConstants\\n/// @notice Constants used all around the Domain logic\\nlibrary DomainConstants {\\n    /// @notice Used for handling calculations with basis points\\n    uint256 constant BASIS_POINTS = 10_000;\\n    /// @notice One day in seconds\\n    uint256 constant SECONDS_PER_DAY = 1 days;\\n    /// @notice Days in a year. Yeap years are ignored\\n    uint256 constant DAYS_PER_YEAR = 365;\\n    /// @notice ReentrancyGuard's property\\n    uint256 constant _NOT_ENTERED = 1;\\n    /// @notice ReentrancyGuard's property\\n    uint256 constant _ENTERED = 2;\\n}\\n\",\"keccak256\":\"0xa91d9468a2376c940149c6d99e6cacd92a78bf16d90d3fae43dbb1789f9b1028\",\"license\":\"MIT\"},\"src/contracts/helpers/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n\\npragma solidity =0.8.20;\\n\\nimport {IAggregatorV3} from \\\"../domain/interfaces/IAggregatorV3.sol\\\";\\n\\n/// @title DiamondErrors\\n/// @notice Errors used all around the Diamond logic\\nlibrary DiamondErrors {\\n    error FunctionDoesNotExist();\\n    error TooManyFunctionsInAFacet();\\n    error NoZeroAddressOwner();\\n    error NoSelectorFound();\\n    error FunctionAlreadyExists();\\n    error ImmutableFunctionDetected();\\n    error CannotReplaceTheSameFunction();\\n    error MustBeZeroAddress(address _newFacetAddress);\\n    error IncorrectFacetCutAction(uint8 _actionNum);\\n    error InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n    error MustBeDiamondOwner(address _caller);\\n    error TransferFailed();\\n}\\n\\n/// @title DomainErrors\\n/// @notice Errors used all around the Domain logic\\n/// @custom:advice Use distinct naming for the errors if your error monitoring model requires it\\nlibrary DomainErrors {\\n    // =============== Protocol ========================================\\n    error ReentrantCall();\\n    // =============== Deposit ========================================\\n    error TokenNotAllowed(address _caller, address _tokenAddress);\\n    error AmountShouldBePositive(address _caller);\\n    error NotEnoughTokensInExistence();\\n    error TokenNotStaked(address _caller, address _tokenAddress);\\n    error CollateralAlreadyOn();\\n    error CollateralNotEnabled(address _caller, address _tokenAddress);\\n    error CollateralCurrentlyInUse();\\n    // =============== Borrow ========================================\\n    error NoAmountAvailable();\\n    error CannotBorrowAmount(address _caller, uint256 maxAmountToBorrowInUsd, uint256 amountToBeBorrowedInUsd);\\n    error InsufficientProtocolFunds();\\n    error CollateralMismatch();\\n    // =============== Repay ========================================\\n    error TokenNotBorrowed(address _caller, address _tokenAddress);\\n    error CollateralNotInUse();\\n    error InsufficientTokenAmount();\\n    error Error404();\\n    error TokenAlreadyThere();\\n    error NoTokensFound();\\n    // =============== Liquidation ========================================\\n    error SelfLiquidationNotAllowed();\\n    error NotLiquidatable(address _caller);\\n    // =============== LibCalculator ========================================\\n    error AnswerShouldBePositiveNum(uint80 roundId, int256 answer);\\n    error InvalidTime(uint80 roundId, uint256 updatedAt);\\n    error StalePrice(uint80 roundId);\\n    error OracleNotAvailable(IAggregatorV3 dataFeed);\\n    // =============== UI ========================================\\n    error UI__TokenNotAllowed(address _caller, address _tokenAddress);\\n}\\n\",\"keccak256\":\"0x24db49ec47c0dfe9a5ab4164cff3bd3b41df64767e8cebec12fed494cae978e1\",\"license\":\"MIT\"},\"src/contracts/helpers/Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n\\npragma solidity =0.8.20;\\n\\nimport {IDiamondCutFacet} from \\\"../diamond/interfaces/IDiamondCutFacet.sol\\\";\\n\\n/// @title DiamondEvents\\n/// @notice Events used all around the Diamond logic\\nlibrary DiamondEvents {\\n    /// @notice Emitted on a successful cut\\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\\n/// @title DomainEvents\\n/// @notice Events used all around the Domain logic\\nlibrary DomainEvents {\\n    /// @notice Emitted on a successful deposit/stake in the protocol\\n    event Deposit(address _depositedToken, uint256 _depositedAmount, address indexed _depositor);\\n    /// @notice Emitted on a successful collateral activation\\n    event CollateralOn(address _tokenAddress, address _depositor);\\n    /// @notice Emitted on a successful collateral deactivation\\n    event CollateralOff(address _tokenAddress, address _depositor);\\n    /// @notice Emitted on a successful borrow from the protocol\\n    event Borrow(address borrowedToken, uint256 _borrowedAmount, address indexed _borrower);\\n    /// @notice Emitted on a successful repayment to the protocol\\n    event Repay(address borrowedToken, uint256 _repayedAmount, address indexed _borrower);\\n    /// @notice Emitted on a successful withdrawal from the protocol\\n    event Withdraw(address token, uint256 amount, address indexed _depositor);\\n    /// @notice Emitted on a successful liquidation\\n    event Liquidation(address indexed _borrower, address indexed borrowedToken, uint256 keeperReward, address _keeper);\\n}\\n\",\"keccak256\":\"0x6c57d33228666ccd54542c1150d3bd1a4eb099ed89d8ecb34123c292eebfa82d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061170d806100206000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c80636178bad61161005b5780636178bad6146100dd57806363c28db1146100fd57806373a050c91461011d578063ad8b34351461013357600080fd5b806302f8e9a31461008257806332abcdbe146100a85780635d78650e146100bd575b600080fd5b610095610090366004611046565b610156565b6040519081526020015b60405180910390f35b6100b0610169565b60405161009f9190611070565b6100d06100cb3660046110bd565b610178565b60405161009f919061111c565b6100f06100eb3660046110bd565b61019b565b60405161009f91906111ae565b61011061010b3660046110bd565b6101a6565b60405161009f919061125e565b6101256101b1565b60405161009f9291906112fc565b6101466101413660046113c9565b6101f6565b604051901515815260200161009f565b6000610162838361020b565b9392505050565b60606101736102e9565b905090565b6040805180820190915260608082526020820152610195826103a5565b92915050565b6060610195826104df565b60606101958261079a565b606060006101bd610a40565b91506101f07fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9a546001600160a01b031690565b90509091565b6000610203848484610ce8565b949350505050565b6001600160a01b03821660009081526000805160206116e1833981519152602052604081205468010000000000000000900460ff16610273576040516394ee780f60e01b81523360048201526001600160a01b03841660248201526044015b60405180910390fd5b600061028e6000805160206116e18339815191528585610df2565b6001600160a01b03851660009081526000805160206116e18339815191526020526040902054909150640100000000900461ffff1661271081830283810483148415176001166102dd57600080fd5b04909103949350505050565b606060006000805160206116e183398151915260060180548060200260200160405190810160405280929190818152602001828054801561035357602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610335575b50505050509050805167ffffffffffffffff8111156103745761037461140c565b60405190808252806020026020018201604052801561039d578160200160208202803683370190505b509092915050565b604080518082019091526060808252602082015260405180604001604052806103d96000805160206116e183398151915290565b6001600160a01b038516600090815260039190910160209081526040918290208054835181840281018401909452808452909183018282801561044557602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610427575b505050505081526020016104646000805160206116e183398151915290565b6001600160a01b03851660009081526005919091016020908152604091829020805483518184028101840190945280845290918301828280156104d057602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116104b2575b50505050508152509050919050565b6001600160a01b03811660009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cf6020908152604080832080548251818502810185019093528083526060949383018282801561056757602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610549575b50508351939450839250505067ffffffffffffffff81111561058b5761058b61140c565b60405190808252806020026020018201604052801561060757816020015b6105f46040518060c0016040528060008152602001600081526020016060815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081525090565b8152602001906001900390816105a95790505b50925060005b8181101561079257600083828151811061062957610629611422565b60200260200101519050600061064a6000805160206116e183398151915290565b6001600160a01b038089166000908152600492830160209081526040808320878516808552908352818420825160a081018452815481526001820154818601908152600283015460ff8116151583870152610100900490971660608201526003909101546080820152825160c0810184528151815295519386019390935281516306fdde0360e01b8152825193975094959186019490936306fdde03938284019391929091908290030181865afa158015610709573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107319190810190611438565b8152602001836001600160a01b0316815260200182606001516001600160a01b03168152602001826080015181525086848151811061077257610772611422565b60200260200101819052505050808061078a906114fb565b91505061060d565b505050919050565b6001600160a01b03811660009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cd6020908152604080832080548251818502810185019093528083526060949383018282801561082257602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610804575b50508351939450839250505067ffffffffffffffff8111156108465761084661140c565b6040519080825280602002602001820160405280156108bd57816020015b6108aa6040518060c00160405280600081526020016000815260200160006001600160a01b03168152602001600015158152602001600015158152602001606081525090565b8152602001906001900390816108645790505b50925060005b818110156107925760008382815181106108df576108df611422565b6020026020010151905060006109006000805160206116e183398151915290565b6001600160a01b038089166000908152600292830160209081526040808320938716808452938252808320815160a08082018452825482526001830154828601908152929097015460ff80821615158386015261010082048116151560608085019182526201000090930490911615156080808501918252865160c0810188528551815295519786019790975284860189905290511515918401919091525115159382019390935281516306fdde0360e01b8152915192965094850193926306fdde03926004808401938290030181865afa1580156109e3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610a0b9190810190611438565b815250868481518110610a2057610a20611422565b602002602001018190525050508080610a38906114fb565b9150506108c3565b606060006000805160206116e1833981519152600101805480602002602001604051908101604052809291908181526020018280548015610aaa57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610a8c575b50508351939450839250505067ffffffffffffffff811115610ace57610ace61140c565b604051908082528060200260200182016040528015610b3057816020015b6040805160c081018252600080825260208083018290529282018190526060808301829052608083019190915260a08201528252600019909201910181610aec5790505b50925060005b81811015610ce2576000838281518110610b5257610b52611422565b602002602001015190506000610b736000805160206116e183398151915290565b6001600160a01b03808416600081815260209384526040808220815160e081018352815461ffff80821683526201000082048116838a0190815264010000000083048216848701908152660100000000000084048316606080870191825260ff68010000000000000000870416151560808089019190915269010000000000000000009096048c1660a080890191909152600190980154909b1660c080880191909152885190810189528a8152865185169c81019c909c52915183168b880152518216988a019890985296519096169587019590955281516306fdde0360e01b815291519496508501936306fdde03926004838101939192918290030181865afa158015610c85573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610cad9190810190611438565b815250868481518110610cc257610cc2611422565b602002602001018190525050508080610cda906114fb565b915050610b36565b50505090565b6001600160a01b0383811660009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cc602090815260408083209386168352929052908120546000805160206116e18339815191529082610d4b838784610df2565b6001600160a01b0380891660009081526004860160209081526040808320938a16835292905290812054919250610d83858884610df2565b6001600160a01b038916600090815260208790526040812054919250660100000000000090910461ffff1690612710610dbc8684611514565b610dc6919061152b565b9050610dd360018261154d565b8311610de0576000610de3565b60015b9b9a5050505050505050505050565b6000806000610e018686610e2f565b9092509050610e1181600a611644565b610e1b8386611514565b610e25919061152b565b9695505050505050565b6001600160a01b03808216600090815260208490526040808220600101548151633fabe5a360e21b8152915192938493911691829163feaf968c9160048082019260a0929091908290030181865afa925050508015610eab575060408051601f3d908101601f19168201909252610ea89181019061166d565b60015b610ed357604051638681218760e01b81526001600160a01b038216600482015260240161026a565b6001841215610f0a57604051633843011160e21b815269ffffffffffffffffffff861660048201526024810185905260440161026a565b81600003610f4057604051636bd07e6160e01b815269ffffffffffffffffffff861660048201526024810183905260440161026a565b7fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9a5474010000000000000000000000000000000000000000900463ffffffff16610f8a834261154d565b1115610fb7576040516306741d7b60e11b815269ffffffffffffffffffff8616600482015260240161026a565b50919550505050806001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ffc573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061102091906116bd565b9150509250929050565b80356001600160a01b038116811461104157600080fd5b919050565b6000806040838503121561105957600080fd5b6110628361102a565b946020939093013593505050565b6020808252825182820181905260009190848201906040850190845b818110156110b15783516001600160a01b03168352928401929184019160010161108c565b50909695505050505050565b6000602082840312156110cf57600080fd5b6101628261102a565b600081518084526020808501945080840160005b838110156111115781516001600160a01b0316875295820195908201906001016110ec565b509495945050505050565b60208152600082516040602084015261113860608401826110d8565b90506020840151601f1984830301604085015261115582826110d8565b95945050505050565b60005b83811015611179578181015183820152602001611161565b50506000910152565b6000815180845261119a81602086016020860161115e565b601f01601f19169290920160200192915050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b8381101561125057603f19898403018552815160c081518552888201518986015287820151818987015261120b82870182611182565b6060848101516001600160a01b03908116918901919091526080808601519091169088015260a0938401519390960192909252505093860193908601906001016111d5565b509098975050505050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b8381101561125057888303603f190185528151805184528781015188850152868101516001600160a01b03168785015260608082015115159085015260808082015115159085015260a09081015160c0918501829052906112e881860183611182565b968901969450505090860190600101611285565b60006040808301818452808651808352606092508286019150828160051b8701016020808a0160005b848110156113a357898403605f19018652815180516001600160a01b031685528381015161ffff908116858701528982015181168a870152888201518116898701526080808301519091169086015260a09081015160c09186018290529061138f81870183611182565b978501979550505090820190600101611325565b50508196506113bc8189018a6001600160a01b03169052565b5050505050509392505050565b6000806000606084860312156113de57600080fd5b6113e78461102a565b92506113f56020850161102a565b91506114036040850161102a565b90509250925092565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b60006020828403121561144a57600080fd5b815167ffffffffffffffff8082111561146257600080fd5b818401915084601f83011261147657600080fd5b8151818111156114885761148861140c565b604051601f8201601f19908116603f011681019083821181831017156114b0576114b061140c565b816040528281528760208487010111156114c957600080fd5b6114da83602083016020880161115e565b979650505050505050565b634e487b7160e01b600052601160045260246000fd5b60006001820161150d5761150d6114e5565b5060010190565b8082028115828204841417610195576101956114e5565b60008261154857634e487b7160e01b600052601260045260246000fd5b500490565b81810381811115610195576101956114e5565b600181815b8085111561159b578160001904821115611581576115816114e5565b8085161561158e57918102915b93841c9390800290611565565b509250929050565b6000826115b257506001610195565b816115bf57506000610195565b81600181146115d557600281146115df576115fb565b6001915050610195565b60ff8411156115f0576115f06114e5565b50506001821b610195565b5060208310610133831016604e8410600b841016171561161e575081810a610195565b6116288383611560565b806000190482111561163c5761163c6114e5565b029392505050565b600061016260ff8416836115a3565b805169ffffffffffffffffffff8116811461104157600080fd5b600080600080600060a0868803121561168557600080fd5b61168e86611653565b94506020860151935060408601519250606086015191506116b160808701611653565b90509295509295909350565b6000602082840312156116cf57600080fd5b815160ff8116811461016257600080fdfeb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709caa164736f6c6343000814000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c80636178bad61161005b5780636178bad6146100dd57806363c28db1146100fd57806373a050c91461011d578063ad8b34351461013357600080fd5b806302f8e9a31461008257806332abcdbe146100a85780635d78650e146100bd575b600080fd5b610095610090366004611046565b610156565b6040519081526020015b60405180910390f35b6100b0610169565b60405161009f9190611070565b6100d06100cb3660046110bd565b610178565b60405161009f919061111c565b6100f06100eb3660046110bd565b61019b565b60405161009f91906111ae565b61011061010b3660046110bd565b6101a6565b60405161009f919061125e565b6101256101b1565b60405161009f9291906112fc565b6101466101413660046113c9565b6101f6565b604051901515815260200161009f565b6000610162838361020b565b9392505050565b60606101736102e9565b905090565b6040805180820190915260608082526020820152610195826103a5565b92915050565b6060610195826104df565b60606101958261079a565b606060006101bd610a40565b91506101f07fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9a546001600160a01b031690565b90509091565b6000610203848484610ce8565b949350505050565b6001600160a01b03821660009081526000805160206116e1833981519152602052604081205468010000000000000000900460ff16610273576040516394ee780f60e01b81523360048201526001600160a01b03841660248201526044015b60405180910390fd5b600061028e6000805160206116e18339815191528585610df2565b6001600160a01b03851660009081526000805160206116e18339815191526020526040902054909150640100000000900461ffff1661271081830283810483148415176001166102dd57600080fd5b04909103949350505050565b606060006000805160206116e183398151915260060180548060200260200160405190810160405280929190818152602001828054801561035357602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610335575b50505050509050805167ffffffffffffffff8111156103745761037461140c565b60405190808252806020026020018201604052801561039d578160200160208202803683370190505b509092915050565b604080518082019091526060808252602082015260405180604001604052806103d96000805160206116e183398151915290565b6001600160a01b038516600090815260039190910160209081526040918290208054835181840281018401909452808452909183018282801561044557602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610427575b505050505081526020016104646000805160206116e183398151915290565b6001600160a01b03851660009081526005919091016020908152604091829020805483518184028101840190945280845290918301828280156104d057602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116104b2575b50505050508152509050919050565b6001600160a01b03811660009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cf6020908152604080832080548251818502810185019093528083526060949383018282801561056757602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610549575b50508351939450839250505067ffffffffffffffff81111561058b5761058b61140c565b60405190808252806020026020018201604052801561060757816020015b6105f46040518060c0016040528060008152602001600081526020016060815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081525090565b8152602001906001900390816105a95790505b50925060005b8181101561079257600083828151811061062957610629611422565b60200260200101519050600061064a6000805160206116e183398151915290565b6001600160a01b038089166000908152600492830160209081526040808320878516808552908352818420825160a081018452815481526001820154818601908152600283015460ff8116151583870152610100900490971660608201526003909101546080820152825160c0810184528151815295519386019390935281516306fdde0360e01b8152825193975094959186019490936306fdde03938284019391929091908290030181865afa158015610709573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107319190810190611438565b8152602001836001600160a01b0316815260200182606001516001600160a01b03168152602001826080015181525086848151811061077257610772611422565b60200260200101819052505050808061078a906114fb565b91505061060d565b505050919050565b6001600160a01b03811660009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cd6020908152604080832080548251818502810185019093528083526060949383018282801561082257602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610804575b50508351939450839250505067ffffffffffffffff8111156108465761084661140c565b6040519080825280602002602001820160405280156108bd57816020015b6108aa6040518060c00160405280600081526020016000815260200160006001600160a01b03168152602001600015158152602001600015158152602001606081525090565b8152602001906001900390816108645790505b50925060005b818110156107925760008382815181106108df576108df611422565b6020026020010151905060006109006000805160206116e183398151915290565b6001600160a01b038089166000908152600292830160209081526040808320938716808452938252808320815160a08082018452825482526001830154828601908152929097015460ff80821615158386015261010082048116151560608085019182526201000090930490911615156080808501918252865160c0810188528551815295519786019790975284860189905290511515918401919091525115159382019390935281516306fdde0360e01b8152915192965094850193926306fdde03926004808401938290030181865afa1580156109e3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610a0b9190810190611438565b815250868481518110610a2057610a20611422565b602002602001018190525050508080610a38906114fb565b9150506108c3565b606060006000805160206116e1833981519152600101805480602002602001604051908101604052809291908181526020018280548015610aaa57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610a8c575b50508351939450839250505067ffffffffffffffff811115610ace57610ace61140c565b604051908082528060200260200182016040528015610b3057816020015b6040805160c081018252600080825260208083018290529282018190526060808301829052608083019190915260a08201528252600019909201910181610aec5790505b50925060005b81811015610ce2576000838281518110610b5257610b52611422565b602002602001015190506000610b736000805160206116e183398151915290565b6001600160a01b03808416600081815260209384526040808220815160e081018352815461ffff80821683526201000082048116838a0190815264010000000083048216848701908152660100000000000084048316606080870191825260ff68010000000000000000870416151560808089019190915269010000000000000000009096048c1660a080890191909152600190980154909b1660c080880191909152885190810189528a8152865185169c81019c909c52915183168b880152518216988a019890985296519096169587019590955281516306fdde0360e01b815291519496508501936306fdde03926004838101939192918290030181865afa158015610c85573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610cad9190810190611438565b815250868481518110610cc257610cc2611422565b602002602001018190525050508080610cda906114fb565b915050610b36565b50505090565b6001600160a01b0383811660009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cc602090815260408083209386168352929052908120546000805160206116e18339815191529082610d4b838784610df2565b6001600160a01b0380891660009081526004860160209081526040808320938a16835292905290812054919250610d83858884610df2565b6001600160a01b038916600090815260208790526040812054919250660100000000000090910461ffff1690612710610dbc8684611514565b610dc6919061152b565b9050610dd360018261154d565b8311610de0576000610de3565b60015b9b9a5050505050505050505050565b6000806000610e018686610e2f565b9092509050610e1181600a611644565b610e1b8386611514565b610e25919061152b565b9695505050505050565b6001600160a01b03808216600090815260208490526040808220600101548151633fabe5a360e21b8152915192938493911691829163feaf968c9160048082019260a0929091908290030181865afa925050508015610eab575060408051601f3d908101601f19168201909252610ea89181019061166d565b60015b610ed357604051638681218760e01b81526001600160a01b038216600482015260240161026a565b6001841215610f0a57604051633843011160e21b815269ffffffffffffffffffff861660048201526024810185905260440161026a565b81600003610f4057604051636bd07e6160e01b815269ffffffffffffffffffff861660048201526024810183905260440161026a565b7fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9a5474010000000000000000000000000000000000000000900463ffffffff16610f8a834261154d565b1115610fb7576040516306741d7b60e11b815269ffffffffffffffffffff8616600482015260240161026a565b50919550505050806001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ffc573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061102091906116bd565b9150509250929050565b80356001600160a01b038116811461104157600080fd5b919050565b6000806040838503121561105957600080fd5b6110628361102a565b946020939093013593505050565b6020808252825182820181905260009190848201906040850190845b818110156110b15783516001600160a01b03168352928401929184019160010161108c565b50909695505050505050565b6000602082840312156110cf57600080fd5b6101628261102a565b600081518084526020808501945080840160005b838110156111115781516001600160a01b0316875295820195908201906001016110ec565b509495945050505050565b60208152600082516040602084015261113860608401826110d8565b90506020840151601f1984830301604085015261115582826110d8565b95945050505050565b60005b83811015611179578181015183820152602001611161565b50506000910152565b6000815180845261119a81602086016020860161115e565b601f01601f19169290920160200192915050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b8381101561125057603f19898403018552815160c081518552888201518986015287820151818987015261120b82870182611182565b6060848101516001600160a01b03908116918901919091526080808601519091169088015260a0938401519390960192909252505093860193908601906001016111d5565b509098975050505050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b8381101561125057888303603f190185528151805184528781015188850152868101516001600160a01b03168785015260608082015115159085015260808082015115159085015260a09081015160c0918501829052906112e881860183611182565b968901969450505090860190600101611285565b60006040808301818452808651808352606092508286019150828160051b8701016020808a0160005b848110156113a357898403605f19018652815180516001600160a01b031685528381015161ffff908116858701528982015181168a870152888201518116898701526080808301519091169086015260a09081015160c09186018290529061138f81870183611182565b978501979550505090820190600101611325565b50508196506113bc8189018a6001600160a01b03169052565b5050505050509392505050565b6000806000606084860312156113de57600080fd5b6113e78461102a565b92506113f56020850161102a565b91506114036040850161102a565b90509250925092565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b60006020828403121561144a57600080fd5b815167ffffffffffffffff8082111561146257600080fd5b818401915084601f83011261147657600080fd5b8151818111156114885761148861140c565b604051601f8201601f19908116603f011681019083821181831017156114b0576114b061140c565b816040528281528760208487010111156114c957600080fd5b6114da83602083016020880161115e565b979650505050505050565b634e487b7160e01b600052601160045260246000fd5b60006001820161150d5761150d6114e5565b5060010190565b8082028115828204841417610195576101956114e5565b60008261154857634e487b7160e01b600052601260045260246000fd5b500490565b81810381811115610195576101956114e5565b600181815b8085111561159b578160001904821115611581576115816114e5565b8085161561158e57918102915b93841c9390800290611565565b509250929050565b6000826115b257506001610195565b816115bf57506000610195565b81600181146115d557600281146115df576115fb565b6001915050610195565b60ff8411156115f0576115f06114e5565b50506001821b610195565b5060208310610133831016604e8410600b841016171561161e575081810a610195565b6116288383611560565b806000190482111561163c5761163c6114e5565b029392505050565b600061016260ff8416836115a3565b805169ffffffffffffffffffff8116811461104157600080fd5b600080600080600060a0868803121561168557600080fd5b61168e86611653565b94506020860151935060408601519250606086015191506116b160808701611653565b90509295509295909350565b6000602082840312156116cf57600080fd5b815160ff8116811461016257600080fdfeb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709caa164736f6c6343000814000a",
  "devdoc": {
    "custom:version": "0.0.1",
    "details": "Make changes depending on the front-end model. This implementation is conceptual",
    "kind": "dev",
    "methods": {
      "getMaxUsdToBorrow(address,uint256)": {
        "details": "`_collateralAmount` must be a whole number",
        "params": {
          "_collateralAmount": "values"
        }
      },
      "isLiquidatable(address,address,address)": {
        "returns": {
          "result": "`true` if it is, otherwise `false`"
        }
      }
    },
    "title": "UIDataFacet",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getAccountData(address)": {
        "notice": "Gets relevant @param _account information. Returns it as @return data"
      },
      "getAllBorrowers()": {
        "notice": "Returns all borrowers in the protocol as @return allBorrowers"
      },
      "getBorrowedTokens(address)": {
        "notice": "Aggregated view of @param _account's borrowed tokens in @return borrowedTokensBatch"
      },
      "getMaxUsdToBorrow(address,uint256)": {
        "notice": "Returns the maximum amount in USD that can be borrowed based on @param _collateralAddress"
      },
      "getProtocolTokens()": {
        "notice": "Gets global-related data of the protocolAggregated view of the allowed tokens in @return allowedTokensBatch; in @return mTokenAddress  the address of the interest-bearing token"
      },
      "getStakedTokens(address)": {
        "notice": "Aggregated view of @param _account's staked tokens in @return stakedTokensBatch"
      },
      "isLiquidatable(address,address,address)": {
        "notice": "Checks if the @param _account is liquidatable based on @param _collateralAddress and @param _borrowedTokenAddress."
      }
    },
    "notice": "UI aggregated data",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
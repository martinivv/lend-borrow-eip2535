{
  "address": "0xb02467Cc764390Ac48a628979D35185d47F354Ae",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "AddressEmptyCode",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "AddressInsufficientBalance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_caller",
          "type": "address"
        }
      ],
      "name": "AmountShouldBePositive",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint80",
          "name": "roundId",
          "type": "uint80"
        },
        {
          "internalType": "int256",
          "name": "answer",
          "type": "int256"
        }
      ],
      "name": "AnswerShouldBePositiveNum",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CollateralCurrentlyInUse",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Error404",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FailedInnerCall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientProtocolFunds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint80",
          "name": "roundId",
          "type": "uint80"
        },
        {
          "internalType": "uint256",
          "name": "updatedAt",
          "type": "uint256"
        }
      ],
      "name": "InvalidTime",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "contract IAggregatorV3",
          "name": "dataFeed",
          "type": "address"
        }
      ],
      "name": "OracleNotAvailable",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ReentrantCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint80",
          "name": "roundId",
          "type": "uint80"
        }
      ],
      "name": "StalePrice",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_caller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_tokenAddress",
          "type": "address"
        }
      ],
      "name": "TokenNotStaked",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_depositor",
          "type": "address"
        }
      ],
      "name": "Withdraw",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenAmount",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xfaa3d8bc877137c952973b2aae20c025ab75119e4f0d44b75dd179248aa6a378",
  "receipt": {
    "to": null,
    "from": "0x8dfD6AE6d263262da0E4a2634d899a0085923Fbc",
    "contractAddress": "0xb02467Cc764390Ac48a628979D35185d47F354Ae",
    "transactionIndex": 15,
    "gasUsed": "888177",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xabd86f378200fe67467e8f2299d4a843ec4813c205d5c9d3a4a7bf3a0af7f595",
    "transactionHash": "0xfaa3d8bc877137c952973b2aae20c025ab75119e4f0d44b75dd179248aa6a378",
    "logs": [],
    "blockNumber": 4624275,
    "cumulativeGasUsed": "3222292",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "bf3ace87e0080de70e4c37f388c527e3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"AmountShouldBePositive\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"}],\"name\":\"AnswerShouldBePositiveNum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollateralCurrentlyInUse\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Error404\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientProtocolFunds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IAggregatorV3\",\"name\":\"dataFeed\",\"type\":\"address\"}],\"name\":\"OracleNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"}],\"name\":\"StalePrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"TokenNotStaked\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:version\":\"0.0.1\",\"errors\":{\"AddressEmptyCode(address)\":[{\"details\":\"There's no code at `target` (it is not a contract).\"}],\"AddressInsufficientBalance(address)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}],\"SafeERC20FailedOperation(address)\":[{\"details\":\"An operation with an ERC20 token failed.\"}]},\"kind\":\"dev\",\"methods\":{\"withdraw(address,uint256)\":{\"custom:advice\":\"Consider checking the balance of the interest-bearing token; if necessaryConsider implementing event monitoring for the interest-bearing token\",\"custom:exec\":\"Sanity checks -> calculation call -> burn -> records withdraw -> transfer\",\"custom:security\":\"`_tokenAmount` should be properly handled in the front-end. Should be solely the number of tokens (without decimal portion)\"}},\"title\":\"WithdrawFacet\",\"version\":1},\"userdoc\":{\"events\":{\"Withdraw(address,uint256,address)\":{\"notice\":\"Emitted on a successful withdrawal from the protocol\"}},\"kind\":\"user\",\"methods\":{\"withdraw(address,uint256)\":{\"notice\":\"Withdraws @param _tokenAmount of @param tokenAddress\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/domain/facets/WithdrawFacet.sol\":\"WithdrawFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":600},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"src/contracts/diamond/interfaces/IDiamondCutFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IDiamondCutFacet\\n/// @notice Interface that allows modifications to diamond function selector mapping\\ninterface IDiamondCutFacet {\\n    /// @notice Struct used as a mapping of facet to function selectors\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Available diamond operations\\n    /// @dev Add=0, Replace=1, Remove=2\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n\\n    /// @notice Emitted when facet selectors are modified\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    /// @notice Adds/replaces/removes any number of functions and optionally executes\\n    /// a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute `_calldata`\\n    /// @param _calldata A function call, including function selector and arguments\\n    /// @dev Be aware that `_calldata` is executed with delegatecall on the `_init` contract\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n}\\n\",\"keccak256\":\"0x3acf0660b6a64d0e066525a914763149d9efe9be92ee16e5ce90acd5a1b09009\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/DiamondState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {LibDiamondCut} from \\\"./logic/LibDiamondCut.sol\\\";\\nimport {LibDiamondOwnership} from \\\"./logic/LibDiamondOwnership.sol\\\";\\n\\nusing LibDiamondCut for DiamondState global;\\nusing LibDiamondOwnership for DiamondState global;\\n\\n/// @notice Struct defining the current diamond state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `DiamondState`\\nstruct DiamondState {\\n    /// @notice Function selector -> address facet and selector positions\\n    mapping(bytes4 => bytes32) facets;\\n    /// @notice Array of slots of function selectors, each slot holds 8 function selectors\\n    mapping(uint256 => bytes32) selectorSlots;\\n    /// @notice The number of function selectors in `selectorSlots`\\n    uint16 selectorCount;\\n    /// @notice ERC-165 implementation; query if a contract implements an interface\\n    mapping(bytes4 => bool) supportedInterfaces;\\n    /// @notice The owner of the Diamond contract\\n    address contractOwner;\\n}\\n\\n// ======================== Pointer ================================================================\\n\\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"martinivv.diamond.storage\\\");\\n\\n/// @notice Used as a shared storage\\n/// @return ds Storage pointer to `DiamondState` struct\\nfunction d() pure returns (DiamondState storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n\\n    assembly {\\n        ds.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0x134f91bbed10b47ed90a102ccbb176c45e8d67521b28aacf6656d40e084cb3b6\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/logic/LibDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable avoid-low-level-calls\\n// solhint-disable code-complexity\\n// solhint-disable custom-errors\\n\\npragma solidity =0.8.20;\\n\\nimport {IDiamondCutFacet} from \\\"../../interfaces/IDiamondCutFacet.sol\\\";\\nimport {DiamondState, d} from \\\"../DiamondState.sol\\\";\\n// Consider adding remappings\\nimport {DiamondEvents} from \\\"../../../helpers/Events.sol\\\";\\nimport {DiamondErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DiamondConstants} from \\\"../../../helpers/Constants.sol\\\";\\n\\n/// @notice See {diamondCut}'s @notice\\n/// @custom:security Will behave like an internal function of the calling contract\\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\\n    if (_init == address(0)) return;\\n\\n    LibDiamondCut.enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n\\n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n    if (!success) {\\n        if (error.length > 0) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(error)\\n                revert(add(32, error), returndata_size)\\n            }\\n        } else {\\n            revert DiamondErrors.InitializationFunctionReverted(_init, _calldata);\\n        }\\n    }\\n}\\n\\n/// @title LibDiamondCut\\n/// @notice Internal function versions of `DiamondCutFacet` ones\\n/// @dev This code is almost the same as the external `DiamondCutFacet` one,\\n/// except it is using `Facet[] memory _diamondCut` instead of\\n/// `Facet[] calldata _diamondCut`. The code is duplicated to prevent\\n/// copying calldata to memory which causes an error for a two dimensional array\\nlibrary LibDiamondCut {\\n    /// @notice Adds/replaces/removes any number of functions and optionally executes\\n    /// a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute `_calldata`\\n    /// @param _calldata A function call, including function selector and arguments\\n    /// @dev Be aware that `_calldata` is executed with delegatecall on the `_init` contract\\n    function diamondCut(\\n        DiamondState storage self,\\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        uint256 originalSelectorCount = self.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n\\n        if (selectorCount & 7 > 0) selectorSlot = self.selectorSlots[selectorCount >> 3];\\n\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n\\n            unchecked {\\n                facetIndex++;\\n            }\\n        }\\n\\n        if (selectorCount != originalSelectorCount) self.selectorCount = uint16(selectorCount);\\n\\n        if (selectorCount & 7 > 0) self.selectorSlots[selectorCount >> 3] = selectorSlot;\\n\\n        emit DiamondEvents.DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    /// @notice See {diamondCut}'s @notice\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCutFacet.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondState storage self = d();\\n\\n        if (_selectors.length < 1) revert DiamondErrors.NoSelectorFound();\\n\\n        if (_action == IDiamondCutFacet.FacetCutAction.Add) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = self.facets[selector];\\n\\n                if (address(bytes20(oldFacet)) != address(0)) revert DiamondErrors.FunctionAlreadyExists();\\n\\n                self.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                _selectorSlot =\\n                    (_selectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n\\n                if (selectorInSlotPosition == 224) {\\n                    self.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n\\n                _selectorCount++;\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCutFacet.FacetCutAction.Replace) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = self.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n\\n                if (oldFacetAddress == address(this)) revert DiamondErrors.ImmutableFunctionDetected();\\n\\n                if (oldFacetAddress == _newFacetAddress) revert DiamondErrors.CannotReplaceTheSameFunction();\\n\\n                if (oldFacetAddress == address(0)) revert DiamondErrors.FunctionDoesNotExist();\\n\\n                self.facets[selector] = (oldFacet & DiamondConstants.CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCutFacet.FacetCutAction.Remove) {\\n            if (_newFacetAddress != address(0)) revert DiamondErrors.MustBeZeroAddress(_newFacetAddress);\\n\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                if (_selectorSlot == 0) {\\n                    selectorSlotCount--;\\n                    _selectorSlot = self.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = self.facets[selector];\\n                    if (address(bytes20(oldFacet)) == address(0)) revert DiamondErrors.FunctionDoesNotExist();\\n\\n                    if (address(bytes20(oldFacet)) == address(this)) revert DiamondErrors.ImmutableFunctionDetected();\\n\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n\\n                    if (lastSelector != selector) {\\n                        self.facets[lastSelector] =\\n                            (oldFacet & DiamondConstants.CLEAR_ADDRESS_MASK) |\\n                            bytes20(self.facets[lastSelector]);\\n                    }\\n\\n                    delete self.facets[selector];\\n\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = self.selectorSlots[oldSelectorsSlotCount];\\n\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\n                    self.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n\\n                if (selectorInSlotIndex == 0) {\\n                    delete self.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert DiamondErrors.IncorrectFacetCutAction(uint8(_action));\\n        }\\n\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    /// @notice Ensures that the @param _contract has code, otherwise throws an @param _errorMessage\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x35d9df95b89c58f00c599f6fea6b6d7d7192428a16e2eb7f6362e6765ac68844\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/logic/LibDiamondOwnership.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {DiamondState} from \\\"../DiamondState.sol\\\";\\nimport {DiamondErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibDiamondOwnership\\n/// @notice Library collection of diamond ownership functions\\nlibrary LibDiamondOwnership {\\n    /// @notice Emitted when diamond owner is updated\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Updates the diamond owner to @param _newOwner's address\\n    function setContractOwner(DiamondState storage self, address _newOwner) internal {\\n        address previousOwner = self.contractOwner;\\n        self.contractOwner = _newOwner;\\n\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    /// @notice Returns the diamond @return contractOwner_'s address\\n    function getContractOwner(DiamondState storage self) internal view returns (address contractOwner_) {\\n        contractOwner_ = self.contractOwner;\\n    }\\n\\n    /// @notice Checks if `msg.sender` is the diamond owner\\n    function enforceIsContractOwner(DiamondState storage self) internal view {\\n        if (msg.sender != self.contractOwner) revert DiamondErrors.MustBeDiamondOwner(msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0xd3f4d72fea315ac0781dfc55f5f2b9d8e11262d360f7578ef591228cc385b8d0\",\"license\":\"MIT\"},\"src/contracts/domain/facets/WithdrawFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {AssetsModifiers, a} from \\\"../libraries/AssetsState.sol\\\";\\nimport {ProtocolModifiers, p} from \\\"../libraries/ProtocolState.sol\\\";\\nimport {SafeERC20} from \\\"../vendor/SafeERC20.sol\\\";\\nimport {IMToken} from \\\"../interfaces/IMToken.sol\\\";\\nimport {DomainEvents} from \\\"../../helpers/Events.sol\\\";\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @title WithdrawFacet\\n/// @custom:version 0.0.1\\ncontract WithdrawFacet is AssetsModifiers, ProtocolModifiers {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice Withdraws @param _tokenAmount of @param tokenAddress\\n    /// @custom:security `_tokenAmount` should be properly handled in the front-end.\\n    /// Should be solely the number of tokens (without decimal portion)\\n    /// @custom:advice Consider checking the balance of the interest-bearing token; if necessary\\n    /// @custom:advice Consider implementing event monitoring for the interest-bearing token\\n    /// @custom:exec Sanity checks -> calculation call -> burn -> records withdraw -> transfer\\n    function withdraw(\\n        address tokenAddress,\\n        uint256 _tokenAmount\\n    ) external notInUseCollateral(tokenAddress) positiveAmount(_tokenAmount) nonReentrant {\\n        (uint256 verifiedAmount, uint256 withdrawAmount, uint256 mTokensToBurn) = a().calculateWithdraw(\\n            tokenAddress,\\n            _tokenAmount\\n        );\\n        // The right decimals are applied\\n        IMToken(p().mTokenAddress).burn(msg.sender, mTokensToBurn);\\n\\n        a().recordWithdraw(tokenAddress, verifiedAmount);\\n\\n        emit DomainEvents.Withdraw(tokenAddress, withdrawAmount, msg.sender);\\n        IERC20(tokenAddress).safeTransfer(msg.sender, withdrawAmount);\\n    }\\n}\\n\",\"keccak256\":\"0xad236dee35e7b0edbc830960b8f6072adb02fb66990cfe56bfe7b08e8213a8f3\",\"license\":\"MIT\"},\"src/contracts/domain/interfaces/IAggregatorV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IAggregatorV3\\n/// @notice This interface enables utilization of Chainlink data feeds\\ninterface IAggregatorV3 {\\n    /// @notice Returns the number of decimals in the response\\n    /// @return {uint8}\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Gets data from the latest round\\n    /// @return roundId The round ID\\n    /// @return answer The data that this specific feed provides\\n    /// @return startedAt Timestamp of when the round started\\n    /// @return updatedAt Timestamp of when the round was updated\\n    /// @return answeredInRound Deprecated. Previously used when answers could take multiple rounds to be computed\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\",\"keccak256\":\"0xf6e216dc33b61ef00f056ccd84e6a9ced64db2dd98a604cafbc5193978485bd2\",\"license\":\"MIT\"},\"src/contracts/domain/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IERC20\\n/// @notice Interface for standard ERC20 implementation\\ninterface IERC20 {\\n    /// @notice Emmited when @param value tokens are moved @param from to @param to account\\n    /// @dev `value` may be zero\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Emitted when the allowance of a @param spender for an @param owner is\\n    /// set by a call to {approve}. @param value is the new allowance\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the name of the token\\n    /// @return {string}\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the decimals places of the token\\n    /// @return {uint8}\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the value of tokens in existence\\n    /// @return {uint256}\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the value of tokens owned by @param _owner\\n    /// @return {uint256}\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Moves a @param _value amount of tokens from the caller's account to @param _to\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    /// @dev Emits a {Transfer} event\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Moves a @param _value amount of tokens from @param _from to @param _to using the\\n    /// allowance mechanism. @param _value is then deducted from the caller's allowance\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Sets a @param _value amount of tokens as the allowance of @param _spender over the\\n    /// caller's tokens\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    /// @custom:security Beware that changing an allowance with this method brings the risk\\n    /// that someone may use both the old and the new allowance by unfortunate transaction ordering.\\n    /// One possible solution to mitigate this race condition is to first reduce the spender's\\n    /// allowance to 0 and set the desired value afterwards:\\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x4f7671ce89e6f77621e67d6f9992f18832ed317612c0ab61be741628887ef37f\",\"license\":\"MIT\"},\"src/contracts/domain/interfaces/IMToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IMToken\\n/// @notice Interface for the interest-bearing token *mToken*\\ninterface IMToken {\\n    /// @notice Burns @param _amount of tokens from @param _from\\n    function burn(address _from, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x85c219295279701c7f6924827c2492d2ec9a942d39a6e97990b2b01485427990\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/AssetsState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {LibDeposit} from \\\"./logic/LibDeposit.sol\\\";\\nimport {LibBorrow} from \\\"./logic/LibBorrow.sol\\\";\\nimport {LibRepay} from \\\"./logic/LibRepay.sol\\\";\\nimport {LibWithdraw} from \\\"./logic/LibWithdraw.sol\\\";\\nimport {LibLiquidation} from \\\"./logic/LibLiquidation.sol\\\";\\nimport {LibCalculator} from \\\"./logic/LibCalculator.sol\\\";\\nimport {IAggregatorV3} from \\\"../interfaces/IAggregatorV3.sol\\\";\\nimport {DomainErrors} from \\\"../../helpers/Errors.sol\\\";\\n\\nusing LibDeposit for AssetsState global;\\nusing LibBorrow for AssetsState global;\\nusing LibRepay for AssetsState global;\\nusing LibWithdraw for AssetsState global;\\nusing LibLiquidation for AssetsState global;\\nusing LibCalculator for AssetsState global;\\n\\n/// @notice Defines the properties for an allowed token\\n/// @dev Parameters used for calculations are present in basis points. For example,\\n/// 1000 basis points = a 10 % staking stable rate\\nstruct AllowedToken {\\n    /// @notice Used as a parameter (on withdrawing) for calculating the daily interest (in tokens)\\n    /// for *solely* staking the token\\n    uint16 stakeStableRate;\\n    /// @notice Used as a parameter (on repaying) for calculating the daily interest (in tokens) to\\n    /// be paid back for a borrowed token\\n    uint16 borrowStableRate;\\n    /// @notice The token's LTV ratio. Higher value \\u2014 higher risk for the protocol's health\\n    uint16 ltv;\\n    /// @notice The token's liquidation threshold. If the borrowed amount in USD surpasses\\n    /// this limit, the borrower should be liquidated\\n    /// @dev 8_000 BPs = 80 % of the collateral\\n    uint16 liquidationThreshold;\\n    /// @notice Returns `true` if the token is allowed, otherwise `false`\\n    bool isAllowed;\\n    /// @notice The address of the token used for setting up the protocol's allowed tokens\\n    address tokenAddress;\\n    /// @notice The address of the Chainlink data feed\\n    IAggregatorV3 dataFeed;\\n}\\n\\n/// @notice Defines the properties for a staked token\\nstruct StakedToken {\\n    /// @notice The staked amount\\n    uint256 amountStaked;\\n    /// @notice Marks the start of the staking period, measured in seconds since the Unix epoch (block.timestamp)\\n    uint256 startAccumulatingDay;\\n    /// @notice Returns `true` if the token is staked, otherwise `false`\\n    bool isStaked;\\n    /// @notice Returns `true` if the token can be used as collateral for borrowing\\n    bool isCollateralOn;\\n    /// @notice Returns `true` if the token is currently used as collateral for a borrowed token\\n    bool isCollateralInUse;\\n}\\n\\n/// @notice Defines the properties for a borrowed token\\nstruct BorrowedToken {\\n    /// @notice The borrowed amount\\n    uint256 amountBorrowed;\\n    /// @notice Marks the start of the borrowing period, measured in seconds since the Unix epoch (block.timestamp)\\n    uint256 startAccumulatingDay;\\n    /// @notice Returns `true` if the token is borrowed, otherwise `false`\\n    bool isBorrowed;\\n    /// @notice The address of the used collateral\\n    address collateralAddress;\\n    /// @notice The amount tokens used for the borrow\\n    uint256 collateralAmount;\\n}\\n\\n/// @notice Struct defining the current assets state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `AssetsState`\\nstruct AssetsState {\\n    /// @notice Protocol's allowed tokens data. Token address -> token data\\n    mapping(address => AllowedToken) allowedTokenData;\\n    /// @notice Protocol's allowed tokens\\n    address[] allowedTokens;\\n    // ======================= STAKE ===========================================================\\n    /// @notice Account -> token address -> staking data\\n    mapping(address => mapping(address => StakedToken)) stakedTokenData;\\n    /// @notice Account -> array of staked token addresses\\n    mapping(address => address[]) stakedTokens;\\n    // ======================= BORROW ===========================================================\\n    /// @notice Account -> token address -> borrowing data\\n    mapping(address => mapping(address => BorrowedToken)) borrowedTokenData;\\n    /// @notice Account -> array of borrowed token addressess\\n    mapping(address => address[]) borrowedTokens;\\n    /// @notice Protocol's borrowers\\n    address[] borrowers;\\n}\\n\\n/* ============================= Pointer =============================================================================== */\\n\\nbytes32 constant ASSETS_STORAGE_POSITION = keccak256(\\\"martinivv.assets.storage\\\");\\n\\n/// @notice Used as a shared storage\\n/// @return ast Storage pointer to `AssetsState` struct\\n/// @dev Any operation involving `ast` will read from or write to **storage**\\nfunction a() pure returns (AssetsState storage ast) {\\n    bytes32 position = ASSETS_STORAGE_POSITION;\\n\\n    assembly {\\n        ast.slot := position\\n    }\\n}\\n\\n/* ============================= Modifiers =============================================================================== */\\n\\n/// @notice Includes modifiers shared across protocol's contracts\\nabstract contract AssetsModifiers {\\n    /* ============================= Deposit & Borrow =========================================================== */\\n\\n    /// @notice Checks if @param _tokenAddress is allowed and @param _tokenAmount is greater than 0\\n    /// @custom:security Zero value ERC20 transfers are terminated in the protocol\\n    modifier allowed(address _tokenAddress, uint256 _tokenAmount) {\\n        if (!a().allowedTokenData[_tokenAddress].isAllowed) {\\n            revert DomainErrors.TokenNotAllowed(msg.sender, _tokenAddress);\\n        }\\n        if (_tokenAmount == 0) revert DomainErrors.AmountShouldBePositive(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Looks the @param _tokenAddress's collateral option to be enabled\\n    /// @custom:security When enabled, it is checked whether it is staked or not\\n    modifier enabledCollateral(address _tokenAddress) {\\n        if (!a().stakedTokenData[msg.sender][_tokenAddress].isCollateralOn) {\\n            revert DomainErrors.CollateralNotEnabled(msg.sender, _tokenAddress);\\n        }\\n        _;\\n    }\\n\\n    /// @notice Looks the @param _collateralAddress to not be currently in use\\n    /// @custom:security The property `isCollateralInUse` is controlled in `BorrowFacet` and\\n    /// `RepayFacet`, the necessary checks are made\\n    modifier notInUseCollateral(address _collateralAddress) {\\n        if (!a().stakedTokenData[msg.sender][_collateralAddress].isStaked) {\\n            revert DomainErrors.TokenNotStaked(msg.sender, _collateralAddress);\\n        }\\n        if (a().stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse) {\\n            revert DomainErrors.CollateralCurrentlyInUse();\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Repay =========================================================== */\\n\\n    /// @notice Looks @param _collateralAddress and @param _borrowedToken to be repayable\\n    /// @custom:security Checking the validity of the `_collateralAddress` is crucial for the\\n    /// protocol security, otherwise could lead to critical vulnerability\\n    modifier repayableCollateral(address _collateralAddress, address _borrowedToken) {\\n        if (a().borrowedTokenData[msg.sender][_borrowedToken].collateralAddress != _collateralAddress) {\\n            revert DomainErrors.CollateralMismatch();\\n        }\\n        if (!a().stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse) {\\n            revert DomainErrors.CollateralNotInUse();\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Liquidation =========================================================== */\\n\\n    /// @notice Looks @param _borrower and @param _borrowedToken to be liquidatable\\n    modifier liquidatable(address _borrower, address _borrowedToken) {\\n        if (msg.sender == _borrower) revert DomainErrors.SelfLiquidationNotAllowed();\\n        if (!a().borrowedTokenData[_borrower][_borrowedToken].isBorrowed) {\\n            revert DomainErrors.TokenNotBorrowed(msg.sender, _borrowedToken);\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Global =========================================================== */\\n\\n    /// @notice Looks @param _tokenAmount to be positive\\n    modifier positiveAmount(uint256 _tokenAmount) {\\n        if (_tokenAmount == 0) revert DomainErrors.AmountShouldBePositive(msg.sender);\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x60b9d2140d47818d4cc2996e0161daf9eb703ca53f5b506660aa3b30bea5f73f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/ProtocolState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {DomainConstants} from \\\"../../helpers/Constants.sol\\\";\\nimport {DomainErrors} from \\\"../../helpers/Errors.sol\\\";\\nimport {d} from \\\"../../diamond/libraries/DiamondState.sol\\\";\\n\\n/// @notice Struct defining the current protocol state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `ProtocolState`\\nstruct ProtocolState {\\n    /// @notice Reentrancy guard's property\\n    uint256 reentrancyStatus;\\n    /// @notice The address of the interest-bearing token\\n    address mTokenAddress;\\n    /// @notice Staleness prevention for the Chainlink oracle response\\n    uint32 answerStalenessThreshold;\\n}\\n\\n/* ============================= Pointer ============================================================================= */\\n\\nbytes32 constant PROTOCOL_STORAGE_POSITION = keccak256(\\\"martinivv.protocol.storage\\\");\\n\\n/// @notice Used as a shared storage among libraries\\n/// @return ps Storage pointer to `DiamondState` struct\\n/// @dev Any operation involving `ps` will read from or write to **storage**\\nfunction p() pure returns (ProtocolState storage ps) {\\n    bytes32 position = PROTOCOL_STORAGE_POSITION;\\n\\n    assembly {\\n        ps.slot := position\\n    }\\n}\\n\\n/* ============================= Modifiers ============================================================================= */\\n\\n/// @notice Includes modifiers shared across protocol's contracts\\n/// @custom:advice Consider adding more robust access control management\\nabstract contract ProtocolModifiers {\\n    /// @notice Prevents a contract from calling itself, over and over, directly or indirectly\\n    /// @dev Forked OZ implementation. Avoids state storage collision within diamond\\n    /// @dev By storing the original value once again at the end, a refund is triggered (see\\n    /// https://eips.ethereum.org/EIPS/eip-2200)\\n    modifier nonReentrant() {\\n        if (p().reentrancyStatus == DomainConstants._ENTERED) revert DomainErrors.ReentrantCall();\\n\\n        p().reentrancyStatus = DomainConstants._ENTERED;\\n        _;\\n\\n        p().reentrancyStatus = DomainConstants._NOT_ENTERED;\\n    }\\n\\n    /// @notice Access control modifier. Ensures that the method is called only by the diamond owner\\n    modifier onlyOwner() {\\n        d().enforceIsContractOwner();\\n        _;\\n    }\\n\\n    /// @notice Initializes reentrancy guard on diamond deployment\\n    function _initReentrancyGuard() internal {\\n        p().reentrancyStatus = DomainConstants._NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x18cdfee5c086a3e8a58182330615629996fcde2d1f18ae21a3a552b8e3abbcd9\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibBorrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibBorrow\\nlibrary LibBorrow {\\n    using Array for address[];\\n\\n    /// @notice Verifies the truth of account parameters and records the borrow\\n    /// @param _collateralAddress The address of the token used as collateral for the borrow\\n    /// @param _tokenAddress The address of the borrowed token\\n    /// @param _tokenAmount The amount to be borrowed\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:advice If `_tokenAmount` cannot be borrowed, consider implementing logic where\\n    /// the maximum available token amount is passed to the `BorrowFacet`\\n    /// @custom:exec Sanity checks (internal calls to `LibCalculator`) -> internal state updates\\n    function verifyAndRecordBorrow(\\n        AssetsState storage self,\\n        address _collateralAddress,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal returns (uint256 scaledAmount) {\\n        /* ========================= Sanity checks ======================================================================== */\\n\\n        (uint256 collateralAmount, uint256 maxToBorrowInUsd) = self.getMaxAmountToBorrowInUsd(_collateralAddress);\\n        uint256 amountToBeBorrowedInUsd = self.getNormalizedUsdEquivalent(_tokenAddress, _tokenAmount);\\n\\n        if (amountToBeBorrowedInUsd > maxToBorrowInUsd) {\\n            revert DomainErrors.CannotBorrowAmount(msg.sender, maxToBorrowInUsd, amountToBeBorrowedInUsd);\\n        }\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n        scaledAmount = _tokenAmount * 10 ** decimals;\\n\\n        if (token.balanceOf(address(this)) < scaledAmount) revert DomainErrors.InsufficientProtocolFunds();\\n\\n        /* ========================= Updating internal state ======================================================================== */\\n\\n        BorrowedToken storage borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        bool isTokenBorrowed = borrowedToken.isBorrowed;\\n\\n        if (isTokenBorrowed) {\\n            address collateralInUse = borrowedToken.collateralAddress;\\n            if (_collateralAddress != collateralInUse) revert DomainErrors.CollateralMismatch();\\n\\n            borrowedToken.amountBorrowed += _tokenAmount;\\n        } else {\\n            BorrowedToken memory currentToken = BorrowedToken({\\n                amountBorrowed: _tokenAmount,\\n                startAccumulatingDay: block.timestamp,\\n                isBorrowed: true,\\n                collateralAddress: _collateralAddress,\\n                collateralAmount: collateralAmount\\n            });\\n\\n            // Always manage together!\\n            self.borrowedTokenData[msg.sender][_tokenAddress] = currentToken;\\n            self.borrowedTokens[msg.sender].push(_tokenAddress);\\n            // =======\\n            self.borrowers.safePush(msg.sender);\\n\\n            self.stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse = true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6378e24efb17284ef19a5e2cf4d108962660c1deacee51b286eef57b292e3f2f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {AssetsState} from \\\"../AssetsState.sol\\\";\\n// Add remappings\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {p} from \\\"../ProtocolState.sol\\\";\\nimport {IAggregatorV3} from \\\"../../interfaces/IAggregatorV3.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibCalculator\\n/// @custom:advice If needed, implement max ratio constant\\nlibrary LibCalculator {\\n    /// @notice Gets the borrowing power in USD\\n    /// @param _collateralAddress The address of the used collateral for the borrow\\n    /// @return collateralAmount The amount of the used collateral\\n    /// @return maxToBorrowInUsd The maximum USD amount you can borrow\\n    /// @dev LTV ratio is represented in basis points, 500 basis points = 5 %\\n    /// @custom:security Reverts if the extraction in `value` results in a negative value\\n    /// @custom:security The integral business model is not considered, may occur wrong calculations, loss of funds.\\n    /// It's a demo version\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    /// @custom:exec Gets the USD equivalent of the collateral amount -> calculates the\\n    /// max borrowing amount in USD\\n    function getMaxAmountToBorrowInUsd(\\n        AssetsState storage self,\\n        address _collateralAddress\\n    ) internal view returns (uint256 collateralAmount, uint256 maxToBorrowInUsd) {\\n        collateralAmount = self.stakedTokenData[msg.sender][_collateralAddress].amountStaked;\\n        uint256 collateralInUsd = getNormalizedUsdEquivalent(self, _collateralAddress, collateralAmount);\\n        uint16 tokenLtv = self.allowedTokenData[_collateralAddress].ltv;\\n\\n        // Calculates the result of the expression `collateralInUsd - (collateralInUsd * tokenLtv / BASIS_POINTS)`.\\n        // The calculation within the parentheses is rounded down\\n        uint256 denominator = DomainConstants.BASIS_POINTS;\\n        assembly {\\n            let z := mul(collateralInUsd, tokenLtv)\\n\\n            if iszero(\\n                and(iszero(iszero(denominator)), or(iszero(collateralInUsd), eq(div(z, collateralInUsd), tokenLtv)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(z, denominator)\\n            maxToBorrowInUsd := sub(collateralInUsd, z)\\n        }\\n    }\\n\\n    /// @notice Calculates the USD equivalent value of a token amount\\n    /// @param _tokenAddress The token's address\\n    /// @param _tokenAmount The token amount\\n    /// @return value The normalized USD value obtained by `tokenAmount *\\n    /// the token's USD price / decimals to be removed`\\n    function getNormalizedUsdEquivalent(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 value) {\\n        (uint256 oracleResponse, uint8 decimals) = _getTokenPriceInUsd(self, _tokenAddress);\\n\\n        value = (_tokenAmount * oracleResponse) / (10 ** decimals);\\n    }\\n\\n    /// @notice Gets the raw price and decimals of an allowed token\\n    /// @param _tokenAddress The allowed token\\n    /// @return oracleResponse Returns the raw price with `decimals`, not divided by a decimal point\\n    /// @return decimals *Typically* comes with a value of 8\\n    /// @custom:security Consider implementing backup oracle(-s) logic in case of failure;\\n    /// TWAP or other verifiably secure options are recommended\\n    function _getTokenPriceInUsd(\\n        AssetsState storage state,\\n        address _tokenAddress\\n    ) private view returns (uint256 oracleResponse, uint8 decimals) {\\n        IAggregatorV3 dataFeed = state.allowedTokenData[_tokenAddress].dataFeed;\\n\\n        try dataFeed.latestRoundData() returns (uint80 roundId, int256 answer, uint256, uint256 updatedAt, uint80) {\\n            if (answer < 1) revert DomainErrors.AnswerShouldBePositiveNum(roundId, answer);\\n\\n            if (updatedAt == 0) revert DomainErrors.InvalidTime(roundId, updatedAt);\\n\\n            if (block.timestamp - updatedAt > p().answerStalenessThreshold) {\\n                revert DomainErrors.StalePrice(roundId);\\n            }\\n\\n            oracleResponse = uint256(answer);\\n        } catch {\\n            revert DomainErrors.OracleNotAvailable(dataFeed);\\n        }\\n\\n        decimals = dataFeed.decimals();\\n    }\\n}\\n\",\"keccak256\":\"0x036a955a0cf1baf620f4d0b1af90796db1b0c1cf332671c15f642055b4dd6861\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibDeposit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {SafeERC20} from \\\"../../vendor/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {AssetsState, StakedToken} from \\\"../AssetsState.sol\\\";\\nimport {p} from \\\"../ProtocolState.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DomainEvents} from \\\"../../../helpers/Events.sol\\\";\\n\\n/// @title LibDeposit\\nlibrary LibDeposit {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice Manages the deposit by changing the internal protocol state. Then sends mTokens\\n    /// @param _tokenAddress The deposited token address\\n    /// @param _tokenAmount The token amount without decimals\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    function manageDeposit(AssetsState storage self, address _tokenAddress, uint256 _tokenAmount) internal {\\n        StakedToken storage stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        bool isTokenStaked = stakedToken.isStaked;\\n\\n        if (isTokenStaked) {\\n            stakedToken.amountStaked += _tokenAmount;\\n            stakedToken.startAccumulatingDay = block.timestamp;\\n        } else {\\n            StakedToken memory currentToken = StakedToken({\\n                amountStaked: _tokenAmount,\\n                startAccumulatingDay: block.timestamp,\\n                isStaked: true,\\n                isCollateralOn: false,\\n                isCollateralInUse: false\\n            });\\n\\n            // Always manage together!\\n            self.stakedTokenData[msg.sender][_tokenAddress] = currentToken;\\n            self.stakedTokens[msg.sender].push(_tokenAddress);\\n            // =======\\n        }\\n\\n        _sendMTokens(self, _tokenAddress, _tokenAmount);\\n    }\\n\\n    /// @notice Sends mTokens; the interest-bearing token back for a deposited token\\n    /// @param _tokenAddress The deposited token's address\\n    /// @param _tokenAmount The deposited token's amount\\n    /// @custom:security Ensure you're using the right decimals, otherwise this can lead\\n    /// to wrong calculations, misleading errors, loss of funds\\n    /// @custom:advice Consider implementing event monitoring for the interest-bearing token\\n    function _sendMTokens(AssetsState storage state, address _tokenAddress, uint256 _tokenAmount) private {\\n        // The price of the token amount without decimals\\n        uint256 sendAmount = state.getNormalizedUsdEquivalent(_tokenAddress, _tokenAmount);\\n\\n        IERC20 mToken = IERC20(p().mTokenAddress);\\n        uint8 decimals = mToken.decimals();\\n\\n        uint256 scaledAmount = sendAmount * 10 ** decimals;\\n        if (scaledAmount > mToken.balanceOf(address(this))) revert DomainErrors.NotEnoughTokensInExistence();\\n\\n        emit DomainEvents.Deposit(_tokenAddress, _tokenAmount, msg.sender);\\n        mToken.safeTransfer(msg.sender, scaledAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x010dfa516db0f0fba5b957570002521220dd65f19cb7a081f17c0d021179439a\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibLiquidation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\n\\n/// @title LibLiquidation\\nlibrary LibLiquidation {\\n    using Array for address[];\\n\\n    /// @notice Returns keeper's @return rewardInTokens, otherwise, if the @param _borrower is not\\n    /// for liquidation, reverts\\n    /// @param _borrowedToken The address of the borrowed token\\n    /// @dev Calculations once again are in basis points. 8_000 BPs = 80 %\\n    /// @custom:advice Consider adding another mechanism instead of reverting; if needed\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    /// @custom:security Gives 50 % (5_000 BPs) of the reward to the keeper to establish some form\\n    /// of equilibrium in the protocol (pays interest to the supporters). Don't forget that this\\n    /// is a DEFI protocol\\n    function manageLiquidation(\\n        AssetsState storage self,\\n        address _borrower,\\n        address _borrowedToken\\n    ) internal view returns (address collateralAddress, uint256 rewardInTokens) {\\n        BorrowedToken memory borrowedToken = self.borrowedTokenData[_borrower][_borrowedToken];\\n\\n        /* ==================================== Is liquidatable? =========================================================================== */\\n\\n        // ========== Collateral in USD ==============================\\n        collateralAddress = borrowedToken.collateralAddress;\\n        uint256 collateralAmount = self.stakedTokenData[_borrower][collateralAddress].amountStaked;\\n        uint256 collateralInUsd = self.getNormalizedUsdEquivalent(collateralAddress, collateralAmount);\\n\\n        // ========== Borrowed in USD ==============================\\n        uint256 borrowedAmount = borrowedToken.amountBorrowed;\\n        uint256 borrowedInUsd = self.getNormalizedUsdEquivalent(_borrowedToken, borrowedAmount);\\n\\n        // ========== Finding the limit ==============================\\n        uint16 collateralThreshold = self.allowedTokenData[collateralAddress].liquidationThreshold;\\n        // For example. `8_000 * 1000 / 10_000` equals to `800`\\n        uint256 limitInUsd = (collateralThreshold * collateralInUsd) / DomainConstants.BASIS_POINTS;\\n        if (borrowedInUsd < limitInUsd) revert DomainErrors.NotLiquidatable(msg.sender);\\n\\n        /* =============================== Calculating the keeper reward ========================================================================== */\\n\\n        // `(5_000 * (2400 - 2000)) / 10_000` equals to `200`\\n        uint256 rewardInUsd = (5_000 * (borrowedInUsd - limitInUsd)) / DomainConstants.BASIS_POINTS;\\n        uint256 singleTokenPrice = rewardInUsd / borrowedAmount;\\n        uint8 decimals = IERC20(_borrowedToken).decimals();\\n        rewardInTokens = (rewardInUsd * 10 ** decimals) / singleTokenPrice;\\n    }\\n\\n    /// @notice Records the liquidation into the internal state\\n    /// @param _borrower The address of the borrower\\n    /// @param _collateralAddress The address of the used collateral token\\n    /// @param _borrowedToken The address of the borrowed token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    function recordLiquidation(\\n        AssetsState storage self,\\n        address _borrower,\\n        address _collateralAddress,\\n        address _borrowedToken\\n    ) internal {\\n        delete self.stakedTokenData[_borrower][_collateralAddress];\\n        self.stakedTokens[_borrower].remove(_collateralAddress);\\n\\n        delete self.borrowedTokenData[_borrower][_borrowedToken];\\n        self.borrowedTokens[_borrower].remove(_borrowedToken);\\n    }\\n}\\n\",\"keccak256\":\"0x398b9d536aabd5fbcb25334067cf236f1cbbc08e189f72645e5944299ac93fbf\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibRepay.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibRepay\\nlibrary LibRepay {\\n    using Array for address[];\\n\\n    /// @notice Makes internal changes\\n    /// @param _collateralAddress The address of the used collateral token\\n    /// @param _tokenAddress The address of the repaid token\\n    /// @param _verifiedAmount The verified amount of the repaid token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:security Can't occur the mapping/array vulnerability where the mapping/array remains accessible\\n    /// even after deletion, because in this case it's not nested\\n    function recordRepay(\\n        AssetsState storage self,\\n        address _collateralAddress,\\n        address _tokenAddress,\\n        uint256 _verifiedAmount\\n    ) internal {\\n        BorrowedToken storage borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        // Still hasn't been updated\\n        uint256 currentAmount = borrowedToken.amountBorrowed;\\n\\n        if (_verifiedAmount == currentAmount) {\\n            // Always manage together!\\n            delete self.borrowedTokenData[msg.sender][_tokenAddress];\\n            self.borrowedTokens[msg.sender].remove(_tokenAddress);\\n            // =======\\n            if (self.borrowedTokens[msg.sender].length == 0) self.borrowers.remove(msg.sender);\\n\\n            // Managing the collateral token\\n            self.stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse = false;\\n        } else {\\n            borrowedToken.amountBorrowed -= _verifiedAmount;\\n        }\\n    }\\n\\n    /// @notice Calculates the amount to be repaid\\n    /// @param _tokenAddress The borrowed token\\n    /// @param _tokenAmount The borrowed amount\\n    /// @return verifiedAmount Ensures correct state changes in {recordRepay}\\n    /// @return totalToRepay The amount with the right token decimals\\n    /// @custom:security The integral business model is not considered; wrong calculations and loss of funds may occur.\\n    /// Calculations are only used for demo purposes\\n    /// @custom:security If `startAccumulatingDay` is in the current day, `verifiedNumDays` will receive a value of\\n    /// 1 (day) to ensure proper calculations in the current version, thereby preventing a critical vulnerability\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    function calculateAmountToRepay(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 verifiedAmount, uint256 totalToRepay) {\\n        /* ============================== Setup =========================================================================== */\\n\\n        BorrowedToken memory borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 borrowedAmount = borrowedToken.amountBorrowed;\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n\\n        verifiedAmount = (_tokenAmount > borrowedAmount ? borrowedAmount : _tokenAmount);\\n        uint256 scaledAmount = verifiedAmount * 10 ** decimals;\\n\\n        /* ============================== Interest =========================================================================== */\\n\\n        uint256 startAccumulatingDay = borrowedToken.startAccumulatingDay;\\n        uint16 tokenBorrowStableRate = self.allowedTokenData[_tokenAddress].borrowStableRate;\\n\\n        uint256 numDays = (block.timestamp - startAccumulatingDay) / DomainConstants.SECONDS_PER_DAY;\\n\\n        uint256 verifiedNumDays = numDays > 0 ? numDays : 1;\\n        // For example. `100e18 * 500 / 10_000` equals to `5e18`\\n        uint256 dailyInterestInTokens = (scaledAmount * tokenBorrowStableRate) / DomainConstants.BASIS_POINTS;\\n        // `15 * 5e18 / 365` equals to `(0.)205479452054794520`\\n        uint256 accumulatedInterestInTokens = (verifiedNumDays * dailyInterestInTokens) / DomainConstants.DAYS_PER_YEAR;\\n\\n        /* ============================== Finalization =========================================================================== */\\n\\n        // `100e18 + 205479452054794520` equals to `100205479452054794520`\\n        totalToRepay = scaledAmount + accumulatedInterestInTokens;\\n\\n        if (token.balanceOf(msg.sender) < totalToRepay) revert DomainErrors.InsufficientTokenAmount();\\n    }\\n}\\n\",\"keccak256\":\"0xeeb666ad7ba6012c8715c34fe53b0e5b71113bedad8a5d947a977f6ba4abc7a3\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibWithdraw.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, StakedToken} from \\\"../AssetsState.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\n\\n/// @title LibWithdraw\\nlibrary LibWithdraw {\\n    using Array for address[];\\n\\n    /// @notice Records the withdraw, applying the changes to the internal state\\n    /// @param _tokenAddress The address of the withdrawn token\\n    /// @param _verifiedAmount The verified amount of the withdrawn token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:security Can't occur the mapping/array vulnerability where the mapping/array remains accessible\\n    /// even after deletion, because in this case it's not nested\\n    function recordWithdraw(AssetsState storage self, address _tokenAddress, uint256 _verifiedAmount) internal {\\n        StakedToken storage stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 currentAmount = stakedToken.amountStaked;\\n\\n        if (_verifiedAmount == currentAmount) {\\n            // Always manage together!\\n            delete self.stakedTokenData[msg.sender][_tokenAddress];\\n            self.stakedTokens[msg.sender].remove(_tokenAddress);\\n            // =======\\n        } else {\\n            stakedToken.amountStaked -= _verifiedAmount;\\n        }\\n    }\\n\\n    /// @notice Calculates @return withdrawAmount and @return mTokensToBurn. @return verifiedAmount ensures\\n    /// correct state changes in {recordWithdraw}\\n    /// @param _tokenAddress The address of the token to be withdrawn\\n    /// @param _tokenAmount The amount of the token to be withdrawn\\n    /// @custom:security The correct decimals are applied\\n    /// @custom:security The integral business model is not considered; wrong calculations and loss of funds may occur.\\n    /// Calculations are only used for demo purposes\\n    /// @custom:security If `startAccumulatingDay` is in the current day, `verifiedNumDays` will receive a value of\\n    /// 1 (day) to ensure proper calculations in the current version, thereby preventing a critical vulnerability\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    function calculateWithdraw(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 verifiedAmount, uint256 withdrawAmount, uint256 mTokensToBurn) {\\n        /* ========================== Setup ======================================================================== */\\n\\n        StakedToken memory stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 stakedAmount = stakedToken.amountStaked;\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n\\n        // In order to burn the correct amount\\n        verifiedAmount = (_tokenAmount > stakedAmount ? stakedAmount : _tokenAmount);\\n        uint256 scaledWithdraw = verifiedAmount * 10 ** decimals;\\n\\n        /* ========================== Interest, withdrawable amount ======================================================================== */\\n\\n        if (!stakedToken.isCollateralOn) {\\n            uint32 tokenStakeStableRate = self.allowedTokenData[_tokenAddress].stakeStableRate;\\n\\n            uint256 numDays = (block.timestamp - stakedToken.startAccumulatingDay) / DomainConstants.SECONDS_PER_DAY;\\n\\n            uint256 verifiedNumDays = numDays > 0 ? numDays : 1;\\n            // For example. `100e18 * 1000 / 10_000` equals to `10e18`\\n            uint256 dailyInterestInTokens = (scaledWithdraw * tokenStakeStableRate) / DomainConstants.BASIS_POINTS;\\n            // `15 * 10e18 / 365` equals to `(0.)410958904109589041`\\n            uint256 accumulatedInterestInTokens = (verifiedNumDays * dailyInterestInTokens) /\\n                DomainConstants.DAYS_PER_YEAR;\\n\\n            // `100e18 += 410958904109589041` equals to `100410958904109589041`\\n            withdrawAmount = accumulatedInterestInTokens;\\n        }\\n\\n        withdrawAmount += scaledWithdraw;\\n        if (token.balanceOf(address(this)) < withdrawAmount) revert DomainErrors.InsufficientProtocolFunds();\\n\\n        /* ========================== mTokens ======================================================================== */\\n\\n        mTokensToBurn = (self.getNormalizedUsdEquivalent(_tokenAddress, verifiedAmount)) * 10 ** decimals;\\n    }\\n}\\n\",\"keccak256\":\"0xa408f251c75bb9c5c2d3538e61f1a92fe29f9063aba448a51c2bf0d16fb24d14\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/utils/Array.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// Consider adding remappings\\nimport {DomainErrors} from \\\"../../../../helpers/Errors.sol\\\";\\n\\n/// @title Array\\n/// @notice Array helper utils\\nlibrary Array {\\n    /// @notice Removes @param _address from @param _arr\\n    /// @custom:exec Gets the index of `tokenAddress` -> moves the element in the last index, if\\n    /// it's not already there -> removes the last index\\n    function remove(address[] storage _arr, address _address) internal {\\n        uint256 index = _indexOf(_arr, _address);\\n        if (index == 404) revert DomainErrors.Error404();\\n\\n        uint256 lastIndex = _arr.length - 1;\\n\\n        if (index != lastIndex) _arr[index] = _arr[lastIndex];\\n\\n        _arr.pop();\\n    }\\n\\n    /// @notice Pushes @param _address in @param _arr, if doesn't occur\\n    function safePush(address[] storage _arr, address _address) internal {\\n        uint256 index = _indexOf(_arr, _address);\\n\\n        if (index == 404) {\\n            _arr.push(_address);\\n        } else {\\n            revert DomainErrors.TokenAlreadyThere();\\n        }\\n    }\\n\\n    /// @notice Returns the index of @param _address in @param _arr\\n    /// @return i The index of the token's address, otherwise `404`, referencing the popular *Error404*\\n    /// @custom:security Security measures taken for the *for* loop:\\n    /// 1. The array is cached outside, making it gas-optimized;\\n    /// 2. There is no storage array that can grow infinitely;\\n    /// 3. There are no external calls within the loop, potentially preventing a DoS attack\\n    function _indexOf(address[] memory _arr, address _address) private pure returns (uint256 i) {\\n        uint256 length = _arr.length;\\n\\n        for (i; i < length; i++) {\\n            if (_arr[i] == _address) return i;\\n        }\\n\\n        i = 404;\\n    }\\n}\\n\",\"keccak256\":\"0x9da1029c3f2fe8d32ad9c6d2f590e7a3149c01f4818cf6da62d3f25f342a8bcd\",\"license\":\"MIT\"},\"src/contracts/domain/vendor/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n/* solhint-disable avoid-low-level-calls */\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x0f523ff6883ab63bc74f9840a89983d659dfa223db3286b9c82d0e1ead604fac\",\"license\":\"MIT\"},\"src/contracts/helpers/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n// solhint-disable state-visibility\\n\\npragma solidity =0.8.20;\\n\\n/// @title DiamondConstants\\n/// @notice Constants used all around the Diamond logic\\nlibrary DiamondConstants {\\n    /// @notice Diamond's property\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    /// @notice Diamond's property\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n}\\n\\n/// @title DomainConstants\\n/// @notice Constants used all around the Domain logic\\nlibrary DomainConstants {\\n    /// @notice Used for handling calculations with basis points\\n    uint256 constant BASIS_POINTS = 10_000;\\n    /// @notice One day in seconds\\n    uint256 constant SECONDS_PER_DAY = 1 days;\\n    /// @notice Days in a year. Yeap years are ignored\\n    uint256 constant DAYS_PER_YEAR = 365;\\n    /// @notice ReentrancyGuard's property\\n    uint256 constant _NOT_ENTERED = 1;\\n    /// @notice ReentrancyGuard's property\\n    uint256 constant _ENTERED = 2;\\n}\\n\",\"keccak256\":\"0xa91d9468a2376c940149c6d99e6cacd92a78bf16d90d3fae43dbb1789f9b1028\",\"license\":\"MIT\"},\"src/contracts/helpers/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n\\npragma solidity =0.8.20;\\n\\nimport {IAggregatorV3} from \\\"../domain/interfaces/IAggregatorV3.sol\\\";\\n\\n/// @title DiamondErrors\\n/// @notice Errors used all around the Diamond logic\\nlibrary DiamondErrors {\\n    error FunctionDoesNotExist();\\n    error TooManyFunctionsInAFacet();\\n    error NoZeroAddressOwner();\\n    error NoSelectorFound();\\n    error FunctionAlreadyExists();\\n    error ImmutableFunctionDetected();\\n    error CannotReplaceTheSameFunction();\\n    error MustBeZeroAddress(address _newFacetAddress);\\n    error IncorrectFacetCutAction(uint8 _actionNum);\\n    error InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n    error MustBeDiamondOwner(address _caller);\\n    error TransferFailed();\\n}\\n\\n/// @title DomainErrors\\n/// @notice Errors used all around the Domain logic\\n/// @custom:advice Use distinct naming for the errors if your error monitoring model requires it\\nlibrary DomainErrors {\\n    // =============== Protocol ========================================\\n    error ReentrantCall();\\n    // =============== Deposit ========================================\\n    error TokenNotAllowed(address _caller, address _tokenAddress);\\n    error AmountShouldBePositive(address _caller);\\n    error NotEnoughTokensInExistence();\\n    error TokenNotStaked(address _caller, address _tokenAddress);\\n    error CollateralAlreadyOn();\\n    error CollateralNotEnabled(address _caller, address _tokenAddress);\\n    error CollateralCurrentlyInUse();\\n    // =============== Borrow ========================================\\n    error NoAmountAvailable();\\n    error CannotBorrowAmount(address _caller, uint256 maxAmountToBorrowInUsd, uint256 amountToBeBorrowedInUsd);\\n    error InsufficientProtocolFunds();\\n    error CollateralMismatch();\\n    // =============== Repay ========================================\\n    error TokenNotBorrowed(address _caller, address _tokenAddress);\\n    error CollateralNotInUse();\\n    error InsufficientTokenAmount();\\n    error Error404();\\n    error TokenAlreadyThere();\\n    error NoTokensFound();\\n    // =============== Liquidation ========================================\\n    error SelfLiquidationNotAllowed();\\n    error NotLiquidatable(address _caller);\\n    // =============== LibCalculator ========================================\\n    error AnswerShouldBePositiveNum(uint80 roundId, int256 answer);\\n    error InvalidTime(uint80 roundId, uint256 updatedAt);\\n    error StalePrice(uint80 roundId);\\n    error OracleNotAvailable(IAggregatorV3 dataFeed);\\n    // =============== UI ========================================\\n    error UI__TokenNotAllowed(address _caller, address _tokenAddress);\\n}\\n\",\"keccak256\":\"0x24db49ec47c0dfe9a5ab4164cff3bd3b41df64767e8cebec12fed494cae978e1\",\"license\":\"MIT\"},\"src/contracts/helpers/Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n\\npragma solidity =0.8.20;\\n\\nimport {IDiamondCutFacet} from \\\"../diamond/interfaces/IDiamondCutFacet.sol\\\";\\n\\n/// @title DiamondEvents\\n/// @notice Events used all around the Diamond logic\\nlibrary DiamondEvents {\\n    /// @notice Emitted on a successful cut\\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\\n/// @title DomainEvents\\n/// @notice Events used all around the Domain logic\\nlibrary DomainEvents {\\n    /// @notice Emitted on a successful deposit/stake in the protocol\\n    event Deposit(address _depositedToken, uint256 _depositedAmount, address indexed _depositor);\\n    /// @notice Emitted on a successful collateral activation\\n    event CollateralOn(address _tokenAddress, address _depositor);\\n    /// @notice Emitted on a successful collateral deactivation\\n    event CollateralOff(address _tokenAddress, address _depositor);\\n    /// @notice Emitted on a successful borrow from the protocol\\n    event Borrow(address borrowedToken, uint256 _borrowedAmount, address indexed _borrower);\\n    /// @notice Emitted on a successful repayment to the protocol\\n    event Repay(address borrowedToken, uint256 _repayedAmount, address indexed _borrower);\\n    /// @notice Emitted on a successful withdrawal from the protocol\\n    event Withdraw(address token, uint256 amount, address indexed _depositor);\\n    /// @notice Emitted on a successful liquidation\\n    event Liquidation(address indexed _borrower, address indexed borrowedToken, uint256 keeperReward, address _keeper);\\n}\\n\",\"keccak256\":\"0x6c57d33228666ccd54542c1150d3bd1a4eb099ed89d8ecb34123c292eebfa82d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610f1b806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063f3fef3a314610030575b600080fd5b61004361003e366004610c2d565b610045565b005b3360009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cc602090815260408083206001600160a01b0386168452909152902060020154829060ff166100c3576040516302acc30360e31b81523360048201526001600160a01b03821660248201526044015b60405180910390fd5b3360009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cc602090815260408083206001600160a01b038516845290915290206002015462010000900460ff1615610130576040516302ffc65b60e01b815260040160405180910390fd5b81806000036101545760405163f9a7ae8760e01b81523360048201526024016100ba565b60027fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf995403610196576040516306fda65d60e31b815260040160405180910390fd5b60027fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9955600080806101e97fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709ca8888610339565b9250925092506102167fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9990565b60010154604051632770a7eb60e21b8152336004820152602481018390526001600160a01b0390911690639dc29fac90604401600060405180830381600087803b15801561026357600080fd5b505af1158015610277573d6000803e3d6000fd5b505050506102ae87846102a77fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709ca90565b919061059a565b604080516001600160a01b03891681526020810184905233917f56c54ba9bd38d8fd62012e42c7ee564519b09763c426d331b3661b537ead19b2910160405180910390a26103066001600160a01b0388163384610640565b50505060016103327fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9990565b5550505050565b3360009081526002808501602090815260408084206001600160a01b038716808652908352818520825160a0810184528154808252600183015482870152919095015460ff8082161515878601526101008204811615156060880152620100009091041615156080860152825163313ce56760e01b8152925186958695909492938a938793919263313ce567926004808401938290030181865afa1580156103e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104099190610c65565b9050828811610418578761041a565b825b9650600061042982600a610d82565b6104339089610d91565b905084606001516104d4576001600160a01b038a16600090815260208c815260408220549087015161ffff909116919062015180906104729042610da8565b61047c9190610dbb565b9050600080821161048e576001610490565b815b905060006127106104a763ffffffff861687610d91565b6104b19190610dbb565b9050600061016d6104c28385610d91565b6104cc9190610dbb565b9b5050505050505b6104de8188610ddd565b6040516370a0823160e01b815230600482015290975087906001600160a01b038516906370a0823190602401602060405180830381865afa158015610527573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061054b9190610df0565b101561056a57604051632122027360e11b815260040160405180910390fd5b61057582600a610d82565b6105808c8c8b6106ac565b61058a9190610d91565b9550505050505093509350939050565b33600090815260028401602090815260408083206001600160a01b03861684529091529020805480830361061f573360008181526002808801602090815260408084206001600160a01b038a168552825280842084815560018101859055909201805462ffffff19169055928252600388019092522061061a90856106e9565b610639565b828260000160008282546106339190610da8565b90915550505b5050505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663a9059cbb60e01b1790526106a7908490610842565b505050565b60008060006106bb86866108a5565b90925090506106cb81600a610d82565b6106d58386610d91565b6106df9190610dbb565b9695505050505050565b600061074e8380548060200260200160405190810160405280929190818152602001828054801561074357602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610725575b505050505083610aa0565b9050806101940361077257604051636b4e55dd60e11b815260040160405180910390fd5b825460009061078390600190610da8565b90508082146107fd5783818154811061079e5761079e610e09565b9060005260206000200160009054906101000a90046001600160a01b03168483815481106107ce576107ce610e09565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b031602179055505b8380548061080d5761080d610e1f565b6000828152602090208101600019908101805473ffffffffffffffffffffffffffffffffffffffff1916905501905550505050565b60006108576001600160a01b03841683610b05565b9050805160001415801561087c57508080602001905181019061087a9190610e35565b155b156106a757604051635274afe760e01b81526001600160a01b03841660048201526024016100ba565b6001600160a01b03808216600090815260208490526040808220600101548151633fabe5a360e21b8152915192938493911691829163feaf968c9160048082019260a0929091908290030181865afa925050508015610921575060408051601f3d908101601f1916820190925261091e91810190610e76565b60015b61094957604051638681218760e01b81526001600160a01b03821660048201526024016100ba565b600184121561098057604051633843011160e21b815269ffffffffffffffffffff86166004820152602481018590526044016100ba565b816000036109b657604051636bd07e6160e01b815269ffffffffffffffffffff86166004820152602481018390526044016100ba565b7fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9a5474010000000000000000000000000000000000000000900463ffffffff16610a008342610da8565b1115610a2d576040516306741d7b60e11b815269ffffffffffffffffffff861660048201526024016100ba565b50919550505050806001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a72573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a969190610c65565b9150509250929050565b81516000905b80821015610af857826001600160a01b0316848381518110610aca57610aca610e09565b60200260200101516001600160a01b031603610ae65750610aff565b81610af081610ec6565b925050610aa6565b6101949150505b92915050565b6060610b1383836000610b1a565b9392505050565b606081471015610b3f5760405163cd78605960e01b81523060048201526024016100ba565b600080856001600160a01b03168486604051610b5b9190610edf565b60006040518083038185875af1925050503d8060008114610b98576040519150601f19603f3d011682016040523d82523d6000602084013e610b9d565b606091505b50915091506106df868383606082610bbd57610bb882610c04565b610b13565b8151158015610bd457506001600160a01b0384163b155b15610bfd57604051639996b31560e01b81526001600160a01b03851660048201526024016100ba565b5080610b13565b805115610c145780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b60008060408385031215610c4057600080fd5b82356001600160a01b0381168114610c5757600080fd5b946020939093013593505050565b600060208284031215610c7757600080fd5b815160ff81168114610b1357600080fd5b634e487b7160e01b600052601160045260246000fd5b600181815b80851115610cd9578160001904821115610cbf57610cbf610c88565b80851615610ccc57918102915b93841c9390800290610ca3565b509250929050565b600082610cf057506001610aff565b81610cfd57506000610aff565b8160018114610d135760028114610d1d57610d39565b6001915050610aff565b60ff841115610d2e57610d2e610c88565b50506001821b610aff565b5060208310610133831016604e8410600b8410161715610d5c575081810a610aff565b610d668383610c9e565b8060001904821115610d7a57610d7a610c88565b029392505050565b6000610b1360ff841683610ce1565b8082028115828204841417610aff57610aff610c88565b81810381811115610aff57610aff610c88565b600082610dd857634e487b7160e01b600052601260045260246000fd5b500490565b80820180821115610aff57610aff610c88565b600060208284031215610e0257600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052603160045260246000fd5b600060208284031215610e4757600080fd5b81518015158114610b1357600080fd5b805169ffffffffffffffffffff81168114610e7157600080fd5b919050565b600080600080600060a08688031215610e8e57600080fd5b610e9786610e57565b9450602086015193506040860151925060608601519150610eba60808701610e57565b90509295509295909350565b600060018201610ed857610ed8610c88565b5060010190565b6000825160005b81811015610f005760208186018101518583015201610ee6565b50600092019182525091905056fea164736f6c6343000814000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063f3fef3a314610030575b600080fd5b61004361003e366004610c2d565b610045565b005b3360009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cc602090815260408083206001600160a01b0386168452909152902060020154829060ff166100c3576040516302acc30360e31b81523360048201526001600160a01b03821660248201526044015b60405180910390fd5b3360009081527fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709cc602090815260408083206001600160a01b038516845290915290206002015462010000900460ff1615610130576040516302ffc65b60e01b815260040160405180910390fd5b81806000036101545760405163f9a7ae8760e01b81523360048201526024016100ba565b60027fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf995403610196576040516306fda65d60e31b815260040160405180910390fd5b60027fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9955600080806101e97fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709ca8888610339565b9250925092506102167fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9990565b60010154604051632770a7eb60e21b8152336004820152602481018390526001600160a01b0390911690639dc29fac90604401600060405180830381600087803b15801561026357600080fd5b505af1158015610277573d6000803e3d6000fd5b505050506102ae87846102a77fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709ca90565b919061059a565b604080516001600160a01b03891681526020810184905233917f56c54ba9bd38d8fd62012e42c7ee564519b09763c426d331b3661b537ead19b2910160405180910390a26103066001600160a01b0388163384610640565b50505060016103327fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9990565b5550505050565b3360009081526002808501602090815260408084206001600160a01b038716808652908352818520825160a0810184528154808252600183015482870152919095015460ff8082161515878601526101008204811615156060880152620100009091041615156080860152825163313ce56760e01b8152925186958695909492938a938793919263313ce567926004808401938290030181865afa1580156103e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104099190610c65565b9050828811610418578761041a565b825b9650600061042982600a610d82565b6104339089610d91565b905084606001516104d4576001600160a01b038a16600090815260208c815260408220549087015161ffff909116919062015180906104729042610da8565b61047c9190610dbb565b9050600080821161048e576001610490565b815b905060006127106104a763ffffffff861687610d91565b6104b19190610dbb565b9050600061016d6104c28385610d91565b6104cc9190610dbb565b9b5050505050505b6104de8188610ddd565b6040516370a0823160e01b815230600482015290975087906001600160a01b038516906370a0823190602401602060405180830381865afa158015610527573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061054b9190610df0565b101561056a57604051632122027360e11b815260040160405180910390fd5b61057582600a610d82565b6105808c8c8b6106ac565b61058a9190610d91565b9550505050505093509350939050565b33600090815260028401602090815260408083206001600160a01b03861684529091529020805480830361061f573360008181526002808801602090815260408084206001600160a01b038a168552825280842084815560018101859055909201805462ffffff19169055928252600388019092522061061a90856106e9565b610639565b828260000160008282546106339190610da8565b90915550505b5050505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1663a9059cbb60e01b1790526106a7908490610842565b505050565b60008060006106bb86866108a5565b90925090506106cb81600a610d82565b6106d58386610d91565b6106df9190610dbb565b9695505050505050565b600061074e8380548060200260200160405190810160405280929190818152602001828054801561074357602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610725575b505050505083610aa0565b9050806101940361077257604051636b4e55dd60e11b815260040160405180910390fd5b825460009061078390600190610da8565b90508082146107fd5783818154811061079e5761079e610e09565b9060005260206000200160009054906101000a90046001600160a01b03168483815481106107ce576107ce610e09565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b031602179055505b8380548061080d5761080d610e1f565b6000828152602090208101600019908101805473ffffffffffffffffffffffffffffffffffffffff1916905501905550505050565b60006108576001600160a01b03841683610b05565b9050805160001415801561087c57508080602001905181019061087a9190610e35565b155b156106a757604051635274afe760e01b81526001600160a01b03841660048201526024016100ba565b6001600160a01b03808216600090815260208490526040808220600101548151633fabe5a360e21b8152915192938493911691829163feaf968c9160048082019260a0929091908290030181865afa925050508015610921575060408051601f3d908101601f1916820190925261091e91810190610e76565b60015b61094957604051638681218760e01b81526001600160a01b03821660048201526024016100ba565b600184121561098057604051633843011160e21b815269ffffffffffffffffffff86166004820152602481018590526044016100ba565b816000036109b657604051636bd07e6160e01b815269ffffffffffffffffffff86166004820152602481018390526044016100ba565b7fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf9a5474010000000000000000000000000000000000000000900463ffffffff16610a008342610da8565b1115610a2d576040516306741d7b60e11b815269ffffffffffffffffffff861660048201526024016100ba565b50919550505050806001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a72573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a969190610c65565b9150509250929050565b81516000905b80821015610af857826001600160a01b0316848381518110610aca57610aca610e09565b60200260200101516001600160a01b031603610ae65750610aff565b81610af081610ec6565b925050610aa6565b6101949150505b92915050565b6060610b1383836000610b1a565b9392505050565b606081471015610b3f5760405163cd78605960e01b81523060048201526024016100ba565b600080856001600160a01b03168486604051610b5b9190610edf565b60006040518083038185875af1925050503d8060008114610b98576040519150601f19603f3d011682016040523d82523d6000602084013e610b9d565b606091505b50915091506106df868383606082610bbd57610bb882610c04565b610b13565b8151158015610bd457506001600160a01b0384163b155b15610bfd57604051639996b31560e01b81526001600160a01b03851660048201526024016100ba565b5080610b13565b805115610c145780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b60008060408385031215610c4057600080fd5b82356001600160a01b0381168114610c5757600080fd5b946020939093013593505050565b600060208284031215610c7757600080fd5b815160ff81168114610b1357600080fd5b634e487b7160e01b600052601160045260246000fd5b600181815b80851115610cd9578160001904821115610cbf57610cbf610c88565b80851615610ccc57918102915b93841c9390800290610ca3565b509250929050565b600082610cf057506001610aff565b81610cfd57506000610aff565b8160018114610d135760028114610d1d57610d39565b6001915050610aff565b60ff841115610d2e57610d2e610c88565b50506001821b610aff565b5060208310610133831016604e8410600b8410161715610d5c575081810a610aff565b610d668383610c9e565b8060001904821115610d7a57610d7a610c88565b029392505050565b6000610b1360ff841683610ce1565b8082028115828204841417610aff57610aff610c88565b81810381811115610aff57610aff610c88565b600082610dd857634e487b7160e01b600052601260045260246000fd5b500490565b80820180821115610aff57610aff610c88565b600060208284031215610e0257600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052603160045260246000fd5b600060208284031215610e4757600080fd5b81518015158114610b1357600080fd5b805169ffffffffffffffffffff81168114610e7157600080fd5b919050565b600080600080600060a08688031215610e8e57600080fd5b610e9786610e57565b9450602086015193506040860151925060608601519150610eba60808701610e57565b90509295509295909350565b600060018201610ed857610ed8610c88565b5060010190565b6000825160005b81811015610f005760208186018101518583015201610ee6565b50600092019182525091905056fea164736f6c6343000814000a",
  "devdoc": {
    "custom:version": "0.0.1",
    "errors": {
      "AddressEmptyCode(address)": [
        {
          "details": "There's no code at `target` (it is not a contract)."
        }
      ],
      "AddressInsufficientBalance(address)": [
        {
          "details": "The ETH balance of the account is not enough to perform the operation."
        }
      ],
      "FailedInnerCall()": [
        {
          "details": "A call to an address target failed. The target may have reverted."
        }
      ],
      "SafeERC20FailedOperation(address)": [
        {
          "details": "An operation with an ERC20 token failed."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "withdraw(address,uint256)": {
        "custom:advice": "Consider checking the balance of the interest-bearing token; if necessaryConsider implementing event monitoring for the interest-bearing token",
        "custom:exec": "Sanity checks -> calculation call -> burn -> records withdraw -> transfer",
        "custom:security": "`_tokenAmount` should be properly handled in the front-end. Should be solely the number of tokens (without decimal portion)"
      }
    },
    "title": "WithdrawFacet",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Withdraw(address,uint256,address)": {
        "notice": "Emitted on a successful withdrawal from the protocol"
      }
    },
    "kind": "user",
    "methods": {
      "withdraw(address,uint256)": {
        "notice": "Withdraws @param _tokenAmount of @param tokenAddress"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
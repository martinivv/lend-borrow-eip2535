{
  "address": "0x7eA6Df6bc1ba3c0CeF7804a6a0a0C492B9AD1030",
  "abi": [
    {
      "inputs": [],
      "name": "NoTokensFound",
      "type": "error"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "mTokenAddress",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "uint16",
                  "name": "stakeStableRate",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "borrowStableRate",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "ltv",
                  "type": "uint16"
                },
                {
                  "internalType": "uint16",
                  "name": "liquidationThreshold",
                  "type": "uint16"
                },
                {
                  "internalType": "bool",
                  "name": "isAllowed",
                  "type": "bool"
                },
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "contract IAggregatorV3",
                  "name": "dataFeed",
                  "type": "address"
                }
              ],
              "internalType": "struct AllowedToken[]",
              "name": "allowedTokens",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct DiamondInit.DiamondInitArgs",
          "name": "_args",
          "type": "tuple"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x8650e3b5fa3d9319dfe989fc5d5836dbbb74b188c82fe2bfd997ada925683563",
  "receipt": {
    "to": null,
    "from": "0x8dfD6AE6d263262da0E4a2634d899a0085923Fbc",
    "contractAddress": "0x7eA6Df6bc1ba3c0CeF7804a6a0a0C492B9AD1030",
    "transactionIndex": 10,
    "gasUsed": "363084",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x774c507978f1c7cec16a8d293a7fa590172d64226979673bdc7af526ad59dec4",
    "transactionHash": "0x8650e3b5fa3d9319dfe989fc5d5836dbbb74b188c82fe2bfd997ada925683563",
    "logs": [],
    "blockNumber": 4624230,
    "cumulativeGasUsed": "1531203",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "bf3ace87e0080de70e4c37f388c527e3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NoTokensFound\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"mTokenAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"stakeStableRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"borrowStableRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ltv\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidationThreshold\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"contract IAggregatorV3\",\"name\":\"dataFeed\",\"type\":\"address\"}],\"internalType\":\"struct AllowedToken[]\",\"name\":\"allowedTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DiamondInit.DiamondInitArgs\",\"name\":\"_args\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:advice\":\"See the suggestions made in `Diamond.sol`, keep them in mind throughout the Diamond contracts\",\"custom:security\":\"It is only called once in the diamond constructor and is not saved as a facet within the diamond\",\"custom:version\":\"0.0.1\",\"kind\":\"dev\",\"methods\":{\"init((address,(uint16,uint16,uint16,uint16,bool,address,address)[]))\":{\"params\":{\"_args\":\"Initial arguments\"}}},\"title\":\"DiamondInit\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"init((address,(uint16,uint16,uint16,uint16,bool,address,address)[]))\":{\"notice\":\"Sets state variables\"}},\"notice\":\"Contract for setting state variables in the diamond during deployment or an upgrade\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/diamond/core/DiamondInit.sol\":\"DiamondInit\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":600},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"src/contracts/diamond/core/DiamondInit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {ProtocolModifiers, ProtocolState, p} from \\\"../../domain/libraries/ProtocolState.sol\\\";\\nimport {AllowedToken} from \\\"../../domain/libraries/AssetsState.sol\\\";\\nimport {DiamondState, d} from \\\"../libraries/DiamondState.sol\\\";\\nimport {IERC165} from \\\"../interfaces/IERC165.sol\\\";\\nimport {IDiamondCutFacet} from \\\"../interfaces/IDiamondCutFacet.sol\\\";\\nimport {IDiamondLoupeFacet} from \\\"../interfaces/IDiamondLoupeFacet.sol\\\";\\nimport {IERC173} from \\\"../interfaces/IERC173.sol\\\";\\nimport {LibOwner} from \\\"../../domain/libraries/logic/LibOwner.sol\\\";\\n\\n/// @title DiamondInit\\n/// @notice Contract for setting state variables in the diamond during deployment or an upgrade\\n/// @custom:security It is only called once in the diamond constructor and is not saved as a facet within the diamond\\n/// @custom:advice See the suggestions made in `Diamond.sol`, keep them in mind throughout the Diamond contracts\\n/// @custom:version 0.0.1\\ncontract DiamondInit is ProtocolModifiers {\\n    struct DiamondInitArgs {\\n        address mTokenAddress;\\n        AllowedToken[] allowedTokens;\\n    }\\n\\n    /// @notice Sets state variables\\n    /// @param _args Initial arguments\\n    function init(DiamondInitArgs calldata _args) external {\\n        // ============= Diamond Initialization ==================================\\n        DiamondState storage ds = d();\\n\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondCutFacet).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondLoupeFacet).interfaceId] = true;\\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n\\n        // ============= Protocol&Assets Initialization ==================================\\n        ProtocolState storage ps = p();\\n\\n        _initReentrancyGuard();\\n        ps.mTokenAddress = _args.mTokenAddress;\\n        ps.answerStalenessThreshold = 1 days;\\n\\n        LibOwner.setTokens(_args.allowedTokens);\\n    }\\n}\\n\",\"keccak256\":\"0xccb9625c47ba59ec64cf9833728a5f309cad3bcfe566e0cbe8893101e8698288\",\"license\":\"MIT\"},\"src/contracts/diamond/interfaces/IDiamondCutFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IDiamondCutFacet\\n/// @notice Interface that allows modifications to diamond function selector mapping\\ninterface IDiamondCutFacet {\\n    /// @notice Struct used as a mapping of facet to function selectors\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Available diamond operations\\n    /// @dev Add=0, Replace=1, Remove=2\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n\\n    /// @notice Emitted when facet selectors are modified\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    /// @notice Adds/replaces/removes any number of functions and optionally executes\\n    /// a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute `_calldata`\\n    /// @param _calldata A function call, including function selector and arguments\\n    /// @dev Be aware that `_calldata` is executed with delegatecall on the `_init` contract\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n}\\n\",\"keccak256\":\"0x3acf0660b6a64d0e066525a914763149d9efe9be92ee16e5ce90acd5a1b09009\",\"license\":\"MIT\"},\"src/contracts/diamond/interfaces/IDiamondLoupeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IDiamondLoupeFacet\\ninterface IDiamondLoupeFacet {\\n    /// @notice Used with {facets} to return all facet addresses and their four byte function selectors\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facets and their selectors\\n    /// @return facets_ {Facet[]}\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific @param _facet\\n    /// @return facetFunctionSelectors_ {bytes4[]}\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Gets all facet addresses used by a diamond\\n    /// @return facetAddresses_ {address[]}\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the @return facetAddress_ that supports given @param _functionSelector\\n    /// @custom:advice Consider implementing better error handling if the facet is not found\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0x8e7796733e14e043e3bafae0c4420bb7680886684bd49465c12f49e1c743ee13\",\"license\":\"MIT\"},\"src/contracts/diamond/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IERC165\\n/// @notice The interface introduces support of contract interfaces, which can then be queried\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @return `true` if the contract implements `interfaceID` and\\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x9b3a450a6e9f019b305cbf73180fa3b4a409327a4af7b3d6477911307badbf49\",\"license\":\"MIT\"},\"src/contracts/diamond/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IERC173\\n/// @notice The interface introduces contract ownership standard\\n/// @dev The ERC-165 identifier for this interface is 0x7f5828d0\\ninterface IERC173 {\\n    /// @notice Sets the contract's owner to a @param _newOwner's address\\n    function transferOwnership(address _newOwner) external;\\n\\n    /// @notice Gets the @return owner_'s address\\n    function owner() external view returns (address owner_);\\n}\\n\",\"keccak256\":\"0x076ad946552b040a4ede07b0142e2f58bab1775344dd79e4ad14e72868dd3077\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/DiamondState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {LibDiamondCut} from \\\"./logic/LibDiamondCut.sol\\\";\\nimport {LibDiamondOwnership} from \\\"./logic/LibDiamondOwnership.sol\\\";\\n\\nusing LibDiamondCut for DiamondState global;\\nusing LibDiamondOwnership for DiamondState global;\\n\\n/// @notice Struct defining the current diamond state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `DiamondState`\\nstruct DiamondState {\\n    /// @notice Function selector -> address facet and selector positions\\n    mapping(bytes4 => bytes32) facets;\\n    /// @notice Array of slots of function selectors, each slot holds 8 function selectors\\n    mapping(uint256 => bytes32) selectorSlots;\\n    /// @notice The number of function selectors in `selectorSlots`\\n    uint16 selectorCount;\\n    /// @notice ERC-165 implementation; query if a contract implements an interface\\n    mapping(bytes4 => bool) supportedInterfaces;\\n    /// @notice The owner of the Diamond contract\\n    address contractOwner;\\n}\\n\\n// ======================== Pointer ================================================================\\n\\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"martinivv.diamond.storage\\\");\\n\\n/// @notice Used as a shared storage\\n/// @return ds Storage pointer to `DiamondState` struct\\nfunction d() pure returns (DiamondState storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n\\n    assembly {\\n        ds.slot := position\\n    }\\n}\\n\",\"keccak256\":\"0x134f91bbed10b47ed90a102ccbb176c45e8d67521b28aacf6656d40e084cb3b6\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/logic/LibDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable avoid-low-level-calls\\n// solhint-disable code-complexity\\n// solhint-disable custom-errors\\n\\npragma solidity =0.8.20;\\n\\nimport {IDiamondCutFacet} from \\\"../../interfaces/IDiamondCutFacet.sol\\\";\\nimport {DiamondState, d} from \\\"../DiamondState.sol\\\";\\n// Consider adding remappings\\nimport {DiamondEvents} from \\\"../../../helpers/Events.sol\\\";\\nimport {DiamondErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DiamondConstants} from \\\"../../../helpers/Constants.sol\\\";\\n\\n/// @notice See {diamondCut}'s @notice\\n/// @custom:security Will behave like an internal function of the calling contract\\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\\n    if (_init == address(0)) return;\\n\\n    LibDiamondCut.enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n\\n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n    if (!success) {\\n        if (error.length > 0) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(error)\\n                revert(add(32, error), returndata_size)\\n            }\\n        } else {\\n            revert DiamondErrors.InitializationFunctionReverted(_init, _calldata);\\n        }\\n    }\\n}\\n\\n/// @title LibDiamondCut\\n/// @notice Internal function versions of `DiamondCutFacet` ones\\n/// @dev This code is almost the same as the external `DiamondCutFacet` one,\\n/// except it is using `Facet[] memory _diamondCut` instead of\\n/// `Facet[] calldata _diamondCut`. The code is duplicated to prevent\\n/// copying calldata to memory which causes an error for a two dimensional array\\nlibrary LibDiamondCut {\\n    /// @notice Adds/replaces/removes any number of functions and optionally executes\\n    /// a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute `_calldata`\\n    /// @param _calldata A function call, including function selector and arguments\\n    /// @dev Be aware that `_calldata` is executed with delegatecall on the `_init` contract\\n    function diamondCut(\\n        DiamondState storage self,\\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        uint256 originalSelectorCount = self.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n\\n        if (selectorCount & 7 > 0) selectorSlot = self.selectorSlots[selectorCount >> 3];\\n\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n\\n            unchecked {\\n                facetIndex++;\\n            }\\n        }\\n\\n        if (selectorCount != originalSelectorCount) self.selectorCount = uint16(selectorCount);\\n\\n        if (selectorCount & 7 > 0) self.selectorSlots[selectorCount >> 3] = selectorSlot;\\n\\n        emit DiamondEvents.DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    /// @notice See {diamondCut}'s @notice\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCutFacet.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondState storage self = d();\\n\\n        if (_selectors.length < 1) revert DiamondErrors.NoSelectorFound();\\n\\n        if (_action == IDiamondCutFacet.FacetCutAction.Add) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = self.facets[selector];\\n\\n                if (address(bytes20(oldFacet)) != address(0)) revert DiamondErrors.FunctionAlreadyExists();\\n\\n                self.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                _selectorSlot =\\n                    (_selectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n\\n                if (selectorInSlotPosition == 224) {\\n                    self.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n\\n                _selectorCount++;\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCutFacet.FacetCutAction.Replace) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = self.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n\\n                if (oldFacetAddress == address(this)) revert DiamondErrors.ImmutableFunctionDetected();\\n\\n                if (oldFacetAddress == _newFacetAddress) revert DiamondErrors.CannotReplaceTheSameFunction();\\n\\n                if (oldFacetAddress == address(0)) revert DiamondErrors.FunctionDoesNotExist();\\n\\n                self.facets[selector] = (oldFacet & DiamondConstants.CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCutFacet.FacetCutAction.Remove) {\\n            if (_newFacetAddress != address(0)) revert DiamondErrors.MustBeZeroAddress(_newFacetAddress);\\n\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                if (_selectorSlot == 0) {\\n                    selectorSlotCount--;\\n                    _selectorSlot = self.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = self.facets[selector];\\n                    if (address(bytes20(oldFacet)) == address(0)) revert DiamondErrors.FunctionDoesNotExist();\\n\\n                    if (address(bytes20(oldFacet)) == address(this)) revert DiamondErrors.ImmutableFunctionDetected();\\n\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n\\n                    if (lastSelector != selector) {\\n                        self.facets[lastSelector] =\\n                            (oldFacet & DiamondConstants.CLEAR_ADDRESS_MASK) |\\n                            bytes20(self.facets[lastSelector]);\\n                    }\\n\\n                    delete self.facets[selector];\\n\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = self.selectorSlots[oldSelectorsSlotCount];\\n\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\n                    self.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n\\n                if (selectorInSlotIndex == 0) {\\n                    delete self.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert DiamondErrors.IncorrectFacetCutAction(uint8(_action));\\n        }\\n\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    /// @notice Ensures that the @param _contract has code, otherwise throws an @param _errorMessage\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x35d9df95b89c58f00c599f6fea6b6d7d7192428a16e2eb7f6362e6765ac68844\",\"license\":\"MIT\"},\"src/contracts/diamond/libraries/logic/LibDiamondOwnership.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {DiamondState} from \\\"../DiamondState.sol\\\";\\nimport {DiamondErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibDiamondOwnership\\n/// @notice Library collection of diamond ownership functions\\nlibrary LibDiamondOwnership {\\n    /// @notice Emitted when diamond owner is updated\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Updates the diamond owner to @param _newOwner's address\\n    function setContractOwner(DiamondState storage self, address _newOwner) internal {\\n        address previousOwner = self.contractOwner;\\n        self.contractOwner = _newOwner;\\n\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    /// @notice Returns the diamond @return contractOwner_'s address\\n    function getContractOwner(DiamondState storage self) internal view returns (address contractOwner_) {\\n        contractOwner_ = self.contractOwner;\\n    }\\n\\n    /// @notice Checks if `msg.sender` is the diamond owner\\n    function enforceIsContractOwner(DiamondState storage self) internal view {\\n        if (msg.sender != self.contractOwner) revert DiamondErrors.MustBeDiamondOwner(msg.sender);\\n    }\\n}\\n\",\"keccak256\":\"0xd3f4d72fea315ac0781dfc55f5f2b9d8e11262d360f7578ef591228cc385b8d0\",\"license\":\"MIT\"},\"src/contracts/domain/interfaces/IAggregatorV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IAggregatorV3\\n/// @notice This interface enables utilization of Chainlink data feeds\\ninterface IAggregatorV3 {\\n    /// @notice Returns the number of decimals in the response\\n    /// @return {uint8}\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Gets data from the latest round\\n    /// @return roundId The round ID\\n    /// @return answer The data that this specific feed provides\\n    /// @return startedAt Timestamp of when the round started\\n    /// @return updatedAt Timestamp of when the round was updated\\n    /// @return answeredInRound Deprecated. Previously used when answers could take multiple rounds to be computed\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\",\"keccak256\":\"0xf6e216dc33b61ef00f056ccd84e6a9ced64db2dd98a604cafbc5193978485bd2\",\"license\":\"MIT\"},\"src/contracts/domain/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n/// @title IERC20\\n/// @notice Interface for standard ERC20 implementation\\ninterface IERC20 {\\n    /// @notice Emmited when @param value tokens are moved @param from to @param to account\\n    /// @dev `value` may be zero\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Emitted when the allowance of a @param spender for an @param owner is\\n    /// set by a call to {approve}. @param value is the new allowance\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the name of the token\\n    /// @return {string}\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the decimals places of the token\\n    /// @return {uint8}\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the value of tokens in existence\\n    /// @return {uint256}\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the value of tokens owned by @param _owner\\n    /// @return {uint256}\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Moves a @param _value amount of tokens from the caller's account to @param _to\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    /// @dev Emits a {Transfer} event\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Moves a @param _value amount of tokens from @param _from to @param _to using the\\n    /// allowance mechanism. @param _value is then deducted from the caller's allowance\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n    /// @notice Sets a @param _value amount of tokens as the allowance of @param _spender over the\\n    /// caller's tokens\\n    /// @return Returns a boolean value indicating whether the operation succeeded\\n    /// @custom:security Beware that changing an allowance with this method brings the risk\\n    /// that someone may use both the old and the new allowance by unfortunate transaction ordering.\\n    /// One possible solution to mitigate this race condition is to first reduce the spender's\\n    /// allowance to 0 and set the desired value afterwards:\\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x4f7671ce89e6f77621e67d6f9992f18832ed317612c0ab61be741628887ef37f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/AssetsState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {LibDeposit} from \\\"./logic/LibDeposit.sol\\\";\\nimport {LibBorrow} from \\\"./logic/LibBorrow.sol\\\";\\nimport {LibRepay} from \\\"./logic/LibRepay.sol\\\";\\nimport {LibWithdraw} from \\\"./logic/LibWithdraw.sol\\\";\\nimport {LibLiquidation} from \\\"./logic/LibLiquidation.sol\\\";\\nimport {LibCalculator} from \\\"./logic/LibCalculator.sol\\\";\\nimport {IAggregatorV3} from \\\"../interfaces/IAggregatorV3.sol\\\";\\nimport {DomainErrors} from \\\"../../helpers/Errors.sol\\\";\\n\\nusing LibDeposit for AssetsState global;\\nusing LibBorrow for AssetsState global;\\nusing LibRepay for AssetsState global;\\nusing LibWithdraw for AssetsState global;\\nusing LibLiquidation for AssetsState global;\\nusing LibCalculator for AssetsState global;\\n\\n/// @notice Defines the properties for an allowed token\\n/// @dev Parameters used for calculations are present in basis points. For example,\\n/// 1000 basis points = a 10 % staking stable rate\\nstruct AllowedToken {\\n    /// @notice Used as a parameter (on withdrawing) for calculating the daily interest (in tokens)\\n    /// for *solely* staking the token\\n    uint16 stakeStableRate;\\n    /// @notice Used as a parameter (on repaying) for calculating the daily interest (in tokens) to\\n    /// be paid back for a borrowed token\\n    uint16 borrowStableRate;\\n    /// @notice The token's LTV ratio. Higher value \\u2014 higher risk for the protocol's health\\n    uint16 ltv;\\n    /// @notice The token's liquidation threshold. If the borrowed amount in USD surpasses\\n    /// this limit, the borrower should be liquidated\\n    /// @dev 8_000 BPs = 80 % of the collateral\\n    uint16 liquidationThreshold;\\n    /// @notice Returns `true` if the token is allowed, otherwise `false`\\n    bool isAllowed;\\n    /// @notice The address of the token used for setting up the protocol's allowed tokens\\n    address tokenAddress;\\n    /// @notice The address of the Chainlink data feed\\n    IAggregatorV3 dataFeed;\\n}\\n\\n/// @notice Defines the properties for a staked token\\nstruct StakedToken {\\n    /// @notice The staked amount\\n    uint256 amountStaked;\\n    /// @notice Marks the start of the staking period, measured in seconds since the Unix epoch (block.timestamp)\\n    uint256 startAccumulatingDay;\\n    /// @notice Returns `true` if the token is staked, otherwise `false`\\n    bool isStaked;\\n    /// @notice Returns `true` if the token can be used as collateral for borrowing\\n    bool isCollateralOn;\\n    /// @notice Returns `true` if the token is currently used as collateral for a borrowed token\\n    bool isCollateralInUse;\\n}\\n\\n/// @notice Defines the properties for a borrowed token\\nstruct BorrowedToken {\\n    /// @notice The borrowed amount\\n    uint256 amountBorrowed;\\n    /// @notice Marks the start of the borrowing period, measured in seconds since the Unix epoch (block.timestamp)\\n    uint256 startAccumulatingDay;\\n    /// @notice Returns `true` if the token is borrowed, otherwise `false`\\n    bool isBorrowed;\\n    /// @notice The address of the used collateral\\n    address collateralAddress;\\n    /// @notice The amount tokens used for the borrow\\n    uint256 collateralAmount;\\n}\\n\\n/// @notice Struct defining the current assets state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `AssetsState`\\nstruct AssetsState {\\n    /// @notice Protocol's allowed tokens data. Token address -> token data\\n    mapping(address => AllowedToken) allowedTokenData;\\n    /// @notice Protocol's allowed tokens\\n    address[] allowedTokens;\\n    // ======================= STAKE ===========================================================\\n    /// @notice Account -> token address -> staking data\\n    mapping(address => mapping(address => StakedToken)) stakedTokenData;\\n    /// @notice Account -> array of staked token addresses\\n    mapping(address => address[]) stakedTokens;\\n    // ======================= BORROW ===========================================================\\n    /// @notice Account -> token address -> borrowing data\\n    mapping(address => mapping(address => BorrowedToken)) borrowedTokenData;\\n    /// @notice Account -> array of borrowed token addressess\\n    mapping(address => address[]) borrowedTokens;\\n    /// @notice Protocol's borrowers\\n    address[] borrowers;\\n}\\n\\n/* ============================= Pointer =============================================================================== */\\n\\nbytes32 constant ASSETS_STORAGE_POSITION = keccak256(\\\"martinivv.assets.storage\\\");\\n\\n/// @notice Used as a shared storage\\n/// @return ast Storage pointer to `AssetsState` struct\\n/// @dev Any operation involving `ast` will read from or write to **storage**\\nfunction a() pure returns (AssetsState storage ast) {\\n    bytes32 position = ASSETS_STORAGE_POSITION;\\n\\n    assembly {\\n        ast.slot := position\\n    }\\n}\\n\\n/* ============================= Modifiers =============================================================================== */\\n\\n/// @notice Includes modifiers shared across protocol's contracts\\nabstract contract AssetsModifiers {\\n    /* ============================= Deposit & Borrow =========================================================== */\\n\\n    /// @notice Checks if @param _tokenAddress is allowed and @param _tokenAmount is greater than 0\\n    /// @custom:security Zero value ERC20 transfers are terminated in the protocol\\n    modifier allowed(address _tokenAddress, uint256 _tokenAmount) {\\n        if (!a().allowedTokenData[_tokenAddress].isAllowed) {\\n            revert DomainErrors.TokenNotAllowed(msg.sender, _tokenAddress);\\n        }\\n        if (_tokenAmount == 0) revert DomainErrors.AmountShouldBePositive(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Looks the @param _tokenAddress's collateral option to be enabled\\n    /// @custom:security When enabled, it is checked whether it is staked or not\\n    modifier enabledCollateral(address _tokenAddress) {\\n        if (!a().stakedTokenData[msg.sender][_tokenAddress].isCollateralOn) {\\n            revert DomainErrors.CollateralNotEnabled(msg.sender, _tokenAddress);\\n        }\\n        _;\\n    }\\n\\n    /// @notice Looks the @param _collateralAddress to not be currently in use\\n    /// @custom:security The property `isCollateralInUse` is controlled in `BorrowFacet` and\\n    /// `RepayFacet`, the necessary checks are made\\n    modifier notInUseCollateral(address _collateralAddress) {\\n        if (!a().stakedTokenData[msg.sender][_collateralAddress].isStaked) {\\n            revert DomainErrors.TokenNotStaked(msg.sender, _collateralAddress);\\n        }\\n        if (a().stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse) {\\n            revert DomainErrors.CollateralCurrentlyInUse();\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Repay =========================================================== */\\n\\n    /// @notice Looks @param _collateralAddress and @param _borrowedToken to be repayable\\n    /// @custom:security Checking the validity of the `_collateralAddress` is crucial for the\\n    /// protocol security, otherwise could lead to critical vulnerability\\n    modifier repayableCollateral(address _collateralAddress, address _borrowedToken) {\\n        if (a().borrowedTokenData[msg.sender][_borrowedToken].collateralAddress != _collateralAddress) {\\n            revert DomainErrors.CollateralMismatch();\\n        }\\n        if (!a().stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse) {\\n            revert DomainErrors.CollateralNotInUse();\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Liquidation =========================================================== */\\n\\n    /// @notice Looks @param _borrower and @param _borrowedToken to be liquidatable\\n    modifier liquidatable(address _borrower, address _borrowedToken) {\\n        if (msg.sender == _borrower) revert DomainErrors.SelfLiquidationNotAllowed();\\n        if (!a().borrowedTokenData[_borrower][_borrowedToken].isBorrowed) {\\n            revert DomainErrors.TokenNotBorrowed(msg.sender, _borrowedToken);\\n        }\\n        _;\\n    }\\n\\n    /* ============================= Global =========================================================== */\\n\\n    /// @notice Looks @param _tokenAmount to be positive\\n    modifier positiveAmount(uint256 _tokenAmount) {\\n        if (_tokenAmount == 0) revert DomainErrors.AmountShouldBePositive(msg.sender);\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x60b9d2140d47818d4cc2996e0161daf9eb703ca53f5b506660aa3b30bea5f73f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/ProtocolState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {DomainConstants} from \\\"../../helpers/Constants.sol\\\";\\nimport {DomainErrors} from \\\"../../helpers/Errors.sol\\\";\\nimport {d} from \\\"../../diamond/libraries/DiamondState.sol\\\";\\n\\n/// @notice Struct defining the current protocol state\\n/// @custom:advice Consider creating a library with \\\"generic\\\" functions related to `ProtocolState`\\nstruct ProtocolState {\\n    /// @notice Reentrancy guard's property\\n    uint256 reentrancyStatus;\\n    /// @notice The address of the interest-bearing token\\n    address mTokenAddress;\\n    /// @notice Staleness prevention for the Chainlink oracle response\\n    uint32 answerStalenessThreshold;\\n}\\n\\n/* ============================= Pointer ============================================================================= */\\n\\nbytes32 constant PROTOCOL_STORAGE_POSITION = keccak256(\\\"martinivv.protocol.storage\\\");\\n\\n/// @notice Used as a shared storage among libraries\\n/// @return ps Storage pointer to `DiamondState` struct\\n/// @dev Any operation involving `ps` will read from or write to **storage**\\nfunction p() pure returns (ProtocolState storage ps) {\\n    bytes32 position = PROTOCOL_STORAGE_POSITION;\\n\\n    assembly {\\n        ps.slot := position\\n    }\\n}\\n\\n/* ============================= Modifiers ============================================================================= */\\n\\n/// @notice Includes modifiers shared across protocol's contracts\\n/// @custom:advice Consider adding more robust access control management\\nabstract contract ProtocolModifiers {\\n    /// @notice Prevents a contract from calling itself, over and over, directly or indirectly\\n    /// @dev Forked OZ implementation. Avoids state storage collision within diamond\\n    /// @dev By storing the original value once again at the end, a refund is triggered (see\\n    /// https://eips.ethereum.org/EIPS/eip-2200)\\n    modifier nonReentrant() {\\n        if (p().reentrancyStatus == DomainConstants._ENTERED) revert DomainErrors.ReentrantCall();\\n\\n        p().reentrancyStatus = DomainConstants._ENTERED;\\n        _;\\n\\n        p().reentrancyStatus = DomainConstants._NOT_ENTERED;\\n    }\\n\\n    /// @notice Access control modifier. Ensures that the method is called only by the diamond owner\\n    modifier onlyOwner() {\\n        d().enforceIsContractOwner();\\n        _;\\n    }\\n\\n    /// @notice Initializes reentrancy guard on diamond deployment\\n    function _initReentrancyGuard() internal {\\n        p().reentrancyStatus = DomainConstants._NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x18cdfee5c086a3e8a58182330615629996fcde2d1f18ae21a3a552b8e3abbcd9\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibBorrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibBorrow\\nlibrary LibBorrow {\\n    using Array for address[];\\n\\n    /// @notice Verifies the truth of account parameters and records the borrow\\n    /// @param _collateralAddress The address of the token used as collateral for the borrow\\n    /// @param _tokenAddress The address of the borrowed token\\n    /// @param _tokenAmount The amount to be borrowed\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:advice If `_tokenAmount` cannot be borrowed, consider implementing logic where\\n    /// the maximum available token amount is passed to the `BorrowFacet`\\n    /// @custom:exec Sanity checks (internal calls to `LibCalculator`) -> internal state updates\\n    function verifyAndRecordBorrow(\\n        AssetsState storage self,\\n        address _collateralAddress,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal returns (uint256 scaledAmount) {\\n        /* ========================= Sanity checks ======================================================================== */\\n\\n        (uint256 collateralAmount, uint256 maxToBorrowInUsd) = self.getMaxAmountToBorrowInUsd(_collateralAddress);\\n        uint256 amountToBeBorrowedInUsd = self.getNormalizedUsdEquivalent(_tokenAddress, _tokenAmount);\\n\\n        if (amountToBeBorrowedInUsd > maxToBorrowInUsd) {\\n            revert DomainErrors.CannotBorrowAmount(msg.sender, maxToBorrowInUsd, amountToBeBorrowedInUsd);\\n        }\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n        scaledAmount = _tokenAmount * 10 ** decimals;\\n\\n        if (token.balanceOf(address(this)) < scaledAmount) revert DomainErrors.InsufficientProtocolFunds();\\n\\n        /* ========================= Updating internal state ======================================================================== */\\n\\n        BorrowedToken storage borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        bool isTokenBorrowed = borrowedToken.isBorrowed;\\n\\n        if (isTokenBorrowed) {\\n            address collateralInUse = borrowedToken.collateralAddress;\\n            if (_collateralAddress != collateralInUse) revert DomainErrors.CollateralMismatch();\\n\\n            borrowedToken.amountBorrowed += _tokenAmount;\\n        } else {\\n            BorrowedToken memory currentToken = BorrowedToken({\\n                amountBorrowed: _tokenAmount,\\n                startAccumulatingDay: block.timestamp,\\n                isBorrowed: true,\\n                collateralAddress: _collateralAddress,\\n                collateralAmount: collateralAmount\\n            });\\n\\n            // Always manage together!\\n            self.borrowedTokenData[msg.sender][_tokenAddress] = currentToken;\\n            self.borrowedTokens[msg.sender].push(_tokenAddress);\\n            // =======\\n            self.borrowers.safePush(msg.sender);\\n\\n            self.stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse = true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6378e24efb17284ef19a5e2cf4d108962660c1deacee51b286eef57b292e3f2f\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {AssetsState} from \\\"../AssetsState.sol\\\";\\n// Add remappings\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {p} from \\\"../ProtocolState.sol\\\";\\nimport {IAggregatorV3} from \\\"../../interfaces/IAggregatorV3.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibCalculator\\n/// @custom:advice If needed, implement max ratio constant\\nlibrary LibCalculator {\\n    /// @notice Gets the borrowing power in USD\\n    /// @param _collateralAddress The address of the used collateral for the borrow\\n    /// @return collateralAmount The amount of the used collateral\\n    /// @return maxToBorrowInUsd The maximum USD amount you can borrow\\n    /// @dev LTV ratio is represented in basis points, 500 basis points = 5 %\\n    /// @custom:security Reverts if the extraction in `value` results in a negative value\\n    /// @custom:security The integral business model is not considered, may occur wrong calculations, loss of funds.\\n    /// It's a demo version\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    /// @custom:exec Gets the USD equivalent of the collateral amount -> calculates the\\n    /// max borrowing amount in USD\\n    function getMaxAmountToBorrowInUsd(\\n        AssetsState storage self,\\n        address _collateralAddress\\n    ) internal view returns (uint256 collateralAmount, uint256 maxToBorrowInUsd) {\\n        collateralAmount = self.stakedTokenData[msg.sender][_collateralAddress].amountStaked;\\n        uint256 collateralInUsd = getNormalizedUsdEquivalent(self, _collateralAddress, collateralAmount);\\n        uint16 tokenLtv = self.allowedTokenData[_collateralAddress].ltv;\\n\\n        // Calculates the result of the expression `collateralInUsd - (collateralInUsd * tokenLtv / BASIS_POINTS)`.\\n        // The calculation within the parentheses is rounded down\\n        uint256 denominator = DomainConstants.BASIS_POINTS;\\n        assembly {\\n            let z := mul(collateralInUsd, tokenLtv)\\n\\n            if iszero(\\n                and(iszero(iszero(denominator)), or(iszero(collateralInUsd), eq(div(z, collateralInUsd), tokenLtv)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(z, denominator)\\n            maxToBorrowInUsd := sub(collateralInUsd, z)\\n        }\\n    }\\n\\n    /// @notice Calculates the USD equivalent value of a token amount\\n    /// @param _tokenAddress The token's address\\n    /// @param _tokenAmount The token amount\\n    /// @return value The normalized USD value obtained by `tokenAmount *\\n    /// the token's USD price / decimals to be removed`\\n    function getNormalizedUsdEquivalent(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 value) {\\n        (uint256 oracleResponse, uint8 decimals) = _getTokenPriceInUsd(self, _tokenAddress);\\n\\n        value = (_tokenAmount * oracleResponse) / (10 ** decimals);\\n    }\\n\\n    /// @notice Gets the raw price and decimals of an allowed token\\n    /// @param _tokenAddress The allowed token\\n    /// @return oracleResponse Returns the raw price with `decimals`, not divided by a decimal point\\n    /// @return decimals *Typically* comes with a value of 8\\n    /// @custom:security Consider implementing backup oracle(-s) logic in case of failure;\\n    /// TWAP or other verifiably secure options are recommended\\n    function _getTokenPriceInUsd(\\n        AssetsState storage state,\\n        address _tokenAddress\\n    ) private view returns (uint256 oracleResponse, uint8 decimals) {\\n        IAggregatorV3 dataFeed = state.allowedTokenData[_tokenAddress].dataFeed;\\n\\n        try dataFeed.latestRoundData() returns (uint80 roundId, int256 answer, uint256, uint256 updatedAt, uint80) {\\n            if (answer < 1) revert DomainErrors.AnswerShouldBePositiveNum(roundId, answer);\\n\\n            if (updatedAt == 0) revert DomainErrors.InvalidTime(roundId, updatedAt);\\n\\n            if (block.timestamp - updatedAt > p().answerStalenessThreshold) {\\n                revert DomainErrors.StalePrice(roundId);\\n            }\\n\\n            oracleResponse = uint256(answer);\\n        } catch {\\n            revert DomainErrors.OracleNotAvailable(dataFeed);\\n        }\\n\\n        decimals = dataFeed.decimals();\\n    }\\n}\\n\",\"keccak256\":\"0x036a955a0cf1baf620f4d0b1af90796db1b0c1cf332671c15f642055b4dd6861\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibDeposit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {SafeERC20} from \\\"../../vendor/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {AssetsState, StakedToken} from \\\"../AssetsState.sol\\\";\\nimport {p} from \\\"../ProtocolState.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DomainEvents} from \\\"../../../helpers/Events.sol\\\";\\n\\n/// @title LibDeposit\\nlibrary LibDeposit {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice Manages the deposit by changing the internal protocol state. Then sends mTokens\\n    /// @param _tokenAddress The deposited token address\\n    /// @param _tokenAmount The token amount without decimals\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    function manageDeposit(AssetsState storage self, address _tokenAddress, uint256 _tokenAmount) internal {\\n        StakedToken storage stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        bool isTokenStaked = stakedToken.isStaked;\\n\\n        if (isTokenStaked) {\\n            stakedToken.amountStaked += _tokenAmount;\\n            stakedToken.startAccumulatingDay = block.timestamp;\\n        } else {\\n            StakedToken memory currentToken = StakedToken({\\n                amountStaked: _tokenAmount,\\n                startAccumulatingDay: block.timestamp,\\n                isStaked: true,\\n                isCollateralOn: false,\\n                isCollateralInUse: false\\n            });\\n\\n            // Always manage together!\\n            self.stakedTokenData[msg.sender][_tokenAddress] = currentToken;\\n            self.stakedTokens[msg.sender].push(_tokenAddress);\\n            // =======\\n        }\\n\\n        _sendMTokens(self, _tokenAddress, _tokenAmount);\\n    }\\n\\n    /// @notice Sends mTokens; the interest-bearing token back for a deposited token\\n    /// @param _tokenAddress The deposited token's address\\n    /// @param _tokenAmount The deposited token's amount\\n    /// @custom:security Ensure you're using the right decimals, otherwise this can lead\\n    /// to wrong calculations, misleading errors, loss of funds\\n    /// @custom:advice Consider implementing event monitoring for the interest-bearing token\\n    function _sendMTokens(AssetsState storage state, address _tokenAddress, uint256 _tokenAmount) private {\\n        // The price of the token amount without decimals\\n        uint256 sendAmount = state.getNormalizedUsdEquivalent(_tokenAddress, _tokenAmount);\\n\\n        IERC20 mToken = IERC20(p().mTokenAddress);\\n        uint8 decimals = mToken.decimals();\\n\\n        uint256 scaledAmount = sendAmount * 10 ** decimals;\\n        if (scaledAmount > mToken.balanceOf(address(this))) revert DomainErrors.NotEnoughTokensInExistence();\\n\\n        emit DomainEvents.Deposit(_tokenAddress, _tokenAmount, msg.sender);\\n        mToken.safeTransfer(msg.sender, scaledAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x010dfa516db0f0fba5b957570002521220dd65f19cb7a081f17c0d021179439a\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibLiquidation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\n\\n/// @title LibLiquidation\\nlibrary LibLiquidation {\\n    using Array for address[];\\n\\n    /// @notice Returns keeper's @return rewardInTokens, otherwise, if the @param _borrower is not\\n    /// for liquidation, reverts\\n    /// @param _borrowedToken The address of the borrowed token\\n    /// @dev Calculations once again are in basis points. 8_000 BPs = 80 %\\n    /// @custom:advice Consider adding another mechanism instead of reverting; if needed\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    /// @custom:security Gives 50 % (5_000 BPs) of the reward to the keeper to establish some form\\n    /// of equilibrium in the protocol (pays interest to the supporters). Don't forget that this\\n    /// is a DEFI protocol\\n    function manageLiquidation(\\n        AssetsState storage self,\\n        address _borrower,\\n        address _borrowedToken\\n    ) internal view returns (address collateralAddress, uint256 rewardInTokens) {\\n        BorrowedToken memory borrowedToken = self.borrowedTokenData[_borrower][_borrowedToken];\\n\\n        /* ==================================== Is liquidatable? =========================================================================== */\\n\\n        // ========== Collateral in USD ==============================\\n        collateralAddress = borrowedToken.collateralAddress;\\n        uint256 collateralAmount = self.stakedTokenData[_borrower][collateralAddress].amountStaked;\\n        uint256 collateralInUsd = self.getNormalizedUsdEquivalent(collateralAddress, collateralAmount);\\n\\n        // ========== Borrowed in USD ==============================\\n        uint256 borrowedAmount = borrowedToken.amountBorrowed;\\n        uint256 borrowedInUsd = self.getNormalizedUsdEquivalent(_borrowedToken, borrowedAmount);\\n\\n        // ========== Finding the limit ==============================\\n        uint16 collateralThreshold = self.allowedTokenData[collateralAddress].liquidationThreshold;\\n        // For example. `8_000 * 1000 / 10_000` equals to `800`\\n        uint256 limitInUsd = (collateralThreshold * collateralInUsd) / DomainConstants.BASIS_POINTS;\\n        if (borrowedInUsd < limitInUsd) revert DomainErrors.NotLiquidatable(msg.sender);\\n\\n        /* =============================== Calculating the keeper reward ========================================================================== */\\n\\n        // `(5_000 * (2400 - 2000)) / 10_000` equals to `200`\\n        uint256 rewardInUsd = (5_000 * (borrowedInUsd - limitInUsd)) / DomainConstants.BASIS_POINTS;\\n        uint256 singleTokenPrice = rewardInUsd / borrowedAmount;\\n        uint8 decimals = IERC20(_borrowedToken).decimals();\\n        rewardInTokens = (rewardInUsd * 10 ** decimals) / singleTokenPrice;\\n    }\\n\\n    /// @notice Records the liquidation into the internal state\\n    /// @param _borrower The address of the borrower\\n    /// @param _collateralAddress The address of the used collateral token\\n    /// @param _borrowedToken The address of the borrowed token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    function recordLiquidation(\\n        AssetsState storage self,\\n        address _borrower,\\n        address _collateralAddress,\\n        address _borrowedToken\\n    ) internal {\\n        delete self.stakedTokenData[_borrower][_collateralAddress];\\n        self.stakedTokens[_borrower].remove(_collateralAddress);\\n\\n        delete self.borrowedTokenData[_borrower][_borrowedToken];\\n        self.borrowedTokens[_borrower].remove(_borrowedToken);\\n    }\\n}\\n\",\"keccak256\":\"0x398b9d536aabd5fbcb25334067cf236f1cbbc08e189f72645e5944299ac93fbf\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibOwner.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {AllowedToken, AssetsState, a} from \\\"../AssetsState.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibOwner\\nlibrary LibOwner {\\n    /// @notice Sets the allowed tokens for the protocol\\n    /// @param _tokens Tokens to be allowed\\n    /// @custom:security Security measures taken for the *for* loop:\\n    /// 1. The array is cached outside, making it gas-optimized;\\n    /// 2. There is no storage array that can grow infinitely;\\n    /// 3. There are no external calls within the loop, potentially preventing a DoS attack\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    function setTokens(AllowedToken[] calldata _tokens) internal {\\n        AssetsState storage ast = a();\\n\\n        uint256 length = _tokens.length;\\n        if (length == 0) revert DomainErrors.NoTokensFound();\\n\\n        for (uint256 i; i < length; ) {\\n            address tokenAddress = _tokens[i].tokenAddress;\\n\\n            bool isAdded = ast.allowedTokenData[tokenAddress].isAllowed;\\n            if (!isAdded) {\\n                // Always manage together!\\n                ast.allowedTokenData[tokenAddress] = _tokens[i];\\n                ast.allowedTokens.push(tokenAddress);\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2a11b4eb9aae7df63bcb4a1c581eee4539b1ffa228de795b53a171a816ec9322\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibRepay.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, BorrowedToken} from \\\"../AssetsState.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\n\\n/// @title LibRepay\\nlibrary LibRepay {\\n    using Array for address[];\\n\\n    /// @notice Makes internal changes\\n    /// @param _collateralAddress The address of the used collateral token\\n    /// @param _tokenAddress The address of the repaid token\\n    /// @param _verifiedAmount The verified amount of the repaid token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:security Can't occur the mapping/array vulnerability where the mapping/array remains accessible\\n    /// even after deletion, because in this case it's not nested\\n    function recordRepay(\\n        AssetsState storage self,\\n        address _collateralAddress,\\n        address _tokenAddress,\\n        uint256 _verifiedAmount\\n    ) internal {\\n        BorrowedToken storage borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        // Still hasn't been updated\\n        uint256 currentAmount = borrowedToken.amountBorrowed;\\n\\n        if (_verifiedAmount == currentAmount) {\\n            // Always manage together!\\n            delete self.borrowedTokenData[msg.sender][_tokenAddress];\\n            self.borrowedTokens[msg.sender].remove(_tokenAddress);\\n            // =======\\n            if (self.borrowedTokens[msg.sender].length == 0) self.borrowers.remove(msg.sender);\\n\\n            // Managing the collateral token\\n            self.stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse = false;\\n        } else {\\n            borrowedToken.amountBorrowed -= _verifiedAmount;\\n        }\\n    }\\n\\n    /// @notice Calculates the amount to be repaid\\n    /// @param _tokenAddress The borrowed token\\n    /// @param _tokenAmount The borrowed amount\\n    /// @return verifiedAmount Ensures correct state changes in {recordRepay}\\n    /// @return totalToRepay The amount with the right token decimals\\n    /// @custom:security The integral business model is not considered; wrong calculations and loss of funds may occur.\\n    /// Calculations are only used for demo purposes\\n    /// @custom:security If `startAccumulatingDay` is in the current day, `verifiedNumDays` will receive a value of\\n    /// 1 (day) to ensure proper calculations in the current version, thereby preventing a critical vulnerability\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    function calculateAmountToRepay(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 verifiedAmount, uint256 totalToRepay) {\\n        /* ============================== Setup =========================================================================== */\\n\\n        BorrowedToken memory borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 borrowedAmount = borrowedToken.amountBorrowed;\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n\\n        verifiedAmount = (_tokenAmount > borrowedAmount ? borrowedAmount : _tokenAmount);\\n        uint256 scaledAmount = verifiedAmount * 10 ** decimals;\\n\\n        /* ============================== Interest =========================================================================== */\\n\\n        uint256 startAccumulatingDay = borrowedToken.startAccumulatingDay;\\n        uint16 tokenBorrowStableRate = self.allowedTokenData[_tokenAddress].borrowStableRate;\\n\\n        uint256 numDays = (block.timestamp - startAccumulatingDay) / DomainConstants.SECONDS_PER_DAY;\\n\\n        uint256 verifiedNumDays = numDays > 0 ? numDays : 1;\\n        // For example. `100e18 * 500 / 10_000` equals to `5e18`\\n        uint256 dailyInterestInTokens = (scaledAmount * tokenBorrowStableRate) / DomainConstants.BASIS_POINTS;\\n        // `15 * 5e18 / 365` equals to `(0.)205479452054794520`\\n        uint256 accumulatedInterestInTokens = (verifiedNumDays * dailyInterestInTokens) / DomainConstants.DAYS_PER_YEAR;\\n\\n        /* ============================== Finalization =========================================================================== */\\n\\n        // `100e18 + 205479452054794520` equals to `100205479452054794520`\\n        totalToRepay = scaledAmount + accumulatedInterestInTokens;\\n\\n        if (token.balanceOf(msg.sender) < totalToRepay) revert DomainErrors.InsufficientTokenAmount();\\n    }\\n}\\n\",\"keccak256\":\"0xeeb666ad7ba6012c8715c34fe53b0e5b71113bedad8a5d947a977f6ba4abc7a3\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/LibWithdraw.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {Array} from \\\"./utils/Array.sol\\\";\\nimport {AssetsState, StakedToken} from \\\"../AssetsState.sol\\\";\\nimport {IERC20} from \\\"../../interfaces/IERC20.sol\\\";\\nimport {DomainErrors} from \\\"../../../helpers/Errors.sol\\\";\\nimport {DomainConstants} from \\\"../../../helpers/Constants.sol\\\";\\n\\n/// @title LibWithdraw\\nlibrary LibWithdraw {\\n    using Array for address[];\\n\\n    /// @notice Records the withdraw, applying the changes to the internal state\\n    /// @param _tokenAddress The address of the withdrawn token\\n    /// @param _verifiedAmount The verified amount of the withdrawn token\\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\\n    /// @custom:security Can't occur the mapping/array vulnerability where the mapping/array remains accessible\\n    /// even after deletion, because in this case it's not nested\\n    function recordWithdraw(AssetsState storage self, address _tokenAddress, uint256 _verifiedAmount) internal {\\n        StakedToken storage stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 currentAmount = stakedToken.amountStaked;\\n\\n        if (_verifiedAmount == currentAmount) {\\n            // Always manage together!\\n            delete self.stakedTokenData[msg.sender][_tokenAddress];\\n            self.stakedTokens[msg.sender].remove(_tokenAddress);\\n            // =======\\n        } else {\\n            stakedToken.amountStaked -= _verifiedAmount;\\n        }\\n    }\\n\\n    /// @notice Calculates @return withdrawAmount and @return mTokensToBurn. @return verifiedAmount ensures\\n    /// correct state changes in {recordWithdraw}\\n    /// @param _tokenAddress The address of the token to be withdrawn\\n    /// @param _tokenAmount The amount of the token to be withdrawn\\n    /// @custom:security The correct decimals are applied\\n    /// @custom:security The integral business model is not considered; wrong calculations and loss of funds may occur.\\n    /// Calculations are only used for demo purposes\\n    /// @custom:security If `startAccumulatingDay` is in the current day, `verifiedNumDays` will receive a value of\\n    /// 1 (day) to ensure proper calculations in the current version, thereby preventing a critical vulnerability\\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\\n    /// closely/further monitored\\n    function calculateWithdraw(\\n        AssetsState storage self,\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    ) internal view returns (uint256 verifiedAmount, uint256 withdrawAmount, uint256 mTokensToBurn) {\\n        /* ========================== Setup ======================================================================== */\\n\\n        StakedToken memory stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\\n\\n        uint256 stakedAmount = stakedToken.amountStaked;\\n\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint8 decimals = token.decimals();\\n\\n        // In order to burn the correct amount\\n        verifiedAmount = (_tokenAmount > stakedAmount ? stakedAmount : _tokenAmount);\\n        uint256 scaledWithdraw = verifiedAmount * 10 ** decimals;\\n\\n        /* ========================== Interest, withdrawable amount ======================================================================== */\\n\\n        if (!stakedToken.isCollateralOn) {\\n            uint32 tokenStakeStableRate = self.allowedTokenData[_tokenAddress].stakeStableRate;\\n\\n            uint256 numDays = (block.timestamp - stakedToken.startAccumulatingDay) / DomainConstants.SECONDS_PER_DAY;\\n\\n            uint256 verifiedNumDays = numDays > 0 ? numDays : 1;\\n            // For example. `100e18 * 1000 / 10_000` equals to `10e18`\\n            uint256 dailyInterestInTokens = (scaledWithdraw * tokenStakeStableRate) / DomainConstants.BASIS_POINTS;\\n            // `15 * 10e18 / 365` equals to `(0.)410958904109589041`\\n            uint256 accumulatedInterestInTokens = (verifiedNumDays * dailyInterestInTokens) /\\n                DomainConstants.DAYS_PER_YEAR;\\n\\n            // `100e18 += 410958904109589041` equals to `100410958904109589041`\\n            withdrawAmount = accumulatedInterestInTokens;\\n        }\\n\\n        withdrawAmount += scaledWithdraw;\\n        if (token.balanceOf(address(this)) < withdrawAmount) revert DomainErrors.InsufficientProtocolFunds();\\n\\n        /* ========================== mTokens ======================================================================== */\\n\\n        mTokensToBurn = (self.getNormalizedUsdEquivalent(_tokenAddress, verifiedAmount)) * 10 ** decimals;\\n    }\\n}\\n\",\"keccak256\":\"0xa408f251c75bb9c5c2d3538e61f1a92fe29f9063aba448a51c2bf0d16fb24d14\",\"license\":\"MIT\"},\"src/contracts/domain/libraries/logic/utils/Array.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n// Consider adding remappings\\nimport {DomainErrors} from \\\"../../../../helpers/Errors.sol\\\";\\n\\n/// @title Array\\n/// @notice Array helper utils\\nlibrary Array {\\n    /// @notice Removes @param _address from @param _arr\\n    /// @custom:exec Gets the index of `tokenAddress` -> moves the element in the last index, if\\n    /// it's not already there -> removes the last index\\n    function remove(address[] storage _arr, address _address) internal {\\n        uint256 index = _indexOf(_arr, _address);\\n        if (index == 404) revert DomainErrors.Error404();\\n\\n        uint256 lastIndex = _arr.length - 1;\\n\\n        if (index != lastIndex) _arr[index] = _arr[lastIndex];\\n\\n        _arr.pop();\\n    }\\n\\n    /// @notice Pushes @param _address in @param _arr, if doesn't occur\\n    function safePush(address[] storage _arr, address _address) internal {\\n        uint256 index = _indexOf(_arr, _address);\\n\\n        if (index == 404) {\\n            _arr.push(_address);\\n        } else {\\n            revert DomainErrors.TokenAlreadyThere();\\n        }\\n    }\\n\\n    /// @notice Returns the index of @param _address in @param _arr\\n    /// @return i The index of the token's address, otherwise `404`, referencing the popular *Error404*\\n    /// @custom:security Security measures taken for the *for* loop:\\n    /// 1. The array is cached outside, making it gas-optimized;\\n    /// 2. There is no storage array that can grow infinitely;\\n    /// 3. There are no external calls within the loop, potentially preventing a DoS attack\\n    function _indexOf(address[] memory _arr, address _address) private pure returns (uint256 i) {\\n        uint256 length = _arr.length;\\n\\n        for (i; i < length; i++) {\\n            if (_arr[i] == _address) return i;\\n        }\\n\\n        i = 404;\\n    }\\n}\\n\",\"keccak256\":\"0x9da1029c3f2fe8d32ad9c6d2f590e7a3149c01f4818cf6da62d3f25f342a8bcd\",\"license\":\"MIT\"},\"src/contracts/domain/vendor/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n/* solhint-disable avoid-low-level-calls */\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x0f523ff6883ab63bc74f9840a89983d659dfa223db3286b9c82d0e1ead604fac\",\"license\":\"MIT\"},\"src/contracts/helpers/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n// solhint-disable state-visibility\\n\\npragma solidity =0.8.20;\\n\\n/// @title DiamondConstants\\n/// @notice Constants used all around the Diamond logic\\nlibrary DiamondConstants {\\n    /// @notice Diamond's property\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    /// @notice Diamond's property\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n}\\n\\n/// @title DomainConstants\\n/// @notice Constants used all around the Domain logic\\nlibrary DomainConstants {\\n    /// @notice Used for handling calculations with basis points\\n    uint256 constant BASIS_POINTS = 10_000;\\n    /// @notice One day in seconds\\n    uint256 constant SECONDS_PER_DAY = 1 days;\\n    /// @notice Days in a year. Yeap years are ignored\\n    uint256 constant DAYS_PER_YEAR = 365;\\n    /// @notice ReentrancyGuard's property\\n    uint256 constant _NOT_ENTERED = 1;\\n    /// @notice ReentrancyGuard's property\\n    uint256 constant _ENTERED = 2;\\n}\\n\",\"keccak256\":\"0xa91d9468a2376c940149c6d99e6cacd92a78bf16d90d3fae43dbb1789f9b1028\",\"license\":\"MIT\"},\"src/contracts/helpers/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n\\npragma solidity =0.8.20;\\n\\nimport {IAggregatorV3} from \\\"../domain/interfaces/IAggregatorV3.sol\\\";\\n\\n/// @title DiamondErrors\\n/// @notice Errors used all around the Diamond logic\\nlibrary DiamondErrors {\\n    error FunctionDoesNotExist();\\n    error TooManyFunctionsInAFacet();\\n    error NoZeroAddressOwner();\\n    error NoSelectorFound();\\n    error FunctionAlreadyExists();\\n    error ImmutableFunctionDetected();\\n    error CannotReplaceTheSameFunction();\\n    error MustBeZeroAddress(address _newFacetAddress);\\n    error IncorrectFacetCutAction(uint8 _actionNum);\\n    error InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n    error MustBeDiamondOwner(address _caller);\\n    error TransferFailed();\\n}\\n\\n/// @title DomainErrors\\n/// @notice Errors used all around the Domain logic\\n/// @custom:advice Use distinct naming for the errors if your error monitoring model requires it\\nlibrary DomainErrors {\\n    // =============== Protocol ========================================\\n    error ReentrantCall();\\n    // =============== Deposit ========================================\\n    error TokenNotAllowed(address _caller, address _tokenAddress);\\n    error AmountShouldBePositive(address _caller);\\n    error NotEnoughTokensInExistence();\\n    error TokenNotStaked(address _caller, address _tokenAddress);\\n    error CollateralAlreadyOn();\\n    error CollateralNotEnabled(address _caller, address _tokenAddress);\\n    error CollateralCurrentlyInUse();\\n    // =============== Borrow ========================================\\n    error NoAmountAvailable();\\n    error CannotBorrowAmount(address _caller, uint256 maxAmountToBorrowInUsd, uint256 amountToBeBorrowedInUsd);\\n    error InsufficientProtocolFunds();\\n    error CollateralMismatch();\\n    // =============== Repay ========================================\\n    error TokenNotBorrowed(address _caller, address _tokenAddress);\\n    error CollateralNotInUse();\\n    error InsufficientTokenAmount();\\n    error Error404();\\n    error TokenAlreadyThere();\\n    error NoTokensFound();\\n    // =============== Liquidation ========================================\\n    error SelfLiquidationNotAllowed();\\n    error NotLiquidatable(address _caller);\\n    // =============== LibCalculator ========================================\\n    error AnswerShouldBePositiveNum(uint80 roundId, int256 answer);\\n    error InvalidTime(uint80 roundId, uint256 updatedAt);\\n    error StalePrice(uint80 roundId);\\n    error OracleNotAvailable(IAggregatorV3 dataFeed);\\n    // =============== UI ========================================\\n    error UI__TokenNotAllowed(address _caller, address _tokenAddress);\\n}\\n\",\"keccak256\":\"0x24db49ec47c0dfe9a5ab4164cff3bd3b41df64767e8cebec12fed494cae978e1\",\"license\":\"MIT\"},\"src/contracts/helpers/Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable one-contract-per-file\\n\\npragma solidity =0.8.20;\\n\\nimport {IDiamondCutFacet} from \\\"../diamond/interfaces/IDiamondCutFacet.sol\\\";\\n\\n/// @title DiamondEvents\\n/// @notice Events used all around the Diamond logic\\nlibrary DiamondEvents {\\n    /// @notice Emitted on a successful cut\\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\\n/// @title DomainEvents\\n/// @notice Events used all around the Domain logic\\nlibrary DomainEvents {\\n    /// @notice Emitted on a successful deposit/stake in the protocol\\n    event Deposit(address _depositedToken, uint256 _depositedAmount, address indexed _depositor);\\n    /// @notice Emitted on a successful collateral activation\\n    event CollateralOn(address _tokenAddress, address _depositor);\\n    /// @notice Emitted on a successful collateral deactivation\\n    event CollateralOff(address _tokenAddress, address _depositor);\\n    /// @notice Emitted on a successful borrow from the protocol\\n    event Borrow(address borrowedToken, uint256 _borrowedAmount, address indexed _borrower);\\n    /// @notice Emitted on a successful repayment to the protocol\\n    event Repay(address borrowedToken, uint256 _repayedAmount, address indexed _borrower);\\n    /// @notice Emitted on a successful withdrawal from the protocol\\n    event Withdraw(address token, uint256 amount, address indexed _depositor);\\n    /// @notice Emitted on a successful liquidation\\n    event Liquidation(address indexed _borrower, address indexed borrowedToken, uint256 keeperReward, address _keeper);\\n}\\n\",\"keccak256\":\"0x6c57d33228666ccd54542c1150d3bd1a4eb099ed89d8ecb34123c292eebfa82d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506105a0806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063d3d62b9814610030575b600080fd5b61004361003e36600461031d565b610045565b005b7f33db93811595d149127b48476bd7ca575d33b2af3516f373596199e9ec7c30236020527ffedc2076553f0daaf85d77e64f137f70c7df3d6e2afc35fea028f67801be3d198054600160ff1991821681179092557fd99b3967c607fc392d7cba4de5e3266d240b08d14eecd560823e59167b17a40480548216831790557f44077d5b86ca1ddb347bb5faf392f7f3a0209613674226b0c58d9e8f2ba1902080548216831790556307f5828d60e41b6000527f02d4138dbc1bc27ac87468f5f810f1b88129507e2e3f0ebf89e0481bfc8486788054909116821790557fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf999081557f33db93811595d149127b48476bd7ca575d33b2af3516f373596199e9ec7c3020906101736020840184610377565b6001820180546001600160a01b03929092167fffffffffffffffff000000000000000000000000000000000000000000000000909216919091177601518000000000000000000000000000000000000000001790556101dd6101d86020850185610394565b6101e2565b505050565b7fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709ca8160008190036102265760405163776acd5b60e01b815260040160405180910390fd5b60005b81811015610316576000858583818110610245576102456103e4565b905060e0020160a001602081019061025d9190610377565b6001600160a01b03811660009081526020869052604090205490915068010000000000000000900460ff168061030c5786868481811061029f5761029f6103e4565b6001600160a01b038516600090815260208990526040902060e0909102929092019190506102cd8282610433565b505060018581018054918201815560009081526020902001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0384161790555b5050600101610229565b5050505050565b60006020828403121561032f57600080fd5b813567ffffffffffffffff81111561034657600080fd5b82016040818503121561035857600080fd5b9392505050565b6001600160a01b038116811461037457600080fd5b50565b60006020828403121561038957600080fd5b81356103588161035f565b6000808335601e198436030181126103ab57600080fd5b83018035915067ffffffffffffffff8211156103c657600080fd5b602001915060e0810236038213156103dd57600080fd5b9250929050565b634e487b7160e01b600052603260045260246000fd5b6000813561ffff8116811461040e57600080fd5b92915050565b60008135801515811461040e57600080fd5b6000813561040e8161035f565b61ffff61043f836103fa565b1681548161ffff19821617835563ffff000061045d602086016103fa565b60101b16808363ffffffff1984161717845565ffff00000000610482604087016103fa565b60201b168365ffffffffffff1984161782171784555050506104cb6104a9606084016103fa565b825467ffff000000000000191660309190911b67ffff00000000000016178255565b6105026104da60808401610414565b82805468ff0000000000000000191691151560401b68ff000000000000000016919091179055565b61055f61051160a08401610426565b82547fffffff0000000000000000000000000000000000000000ffffffffffffffffff1660489190911b7cffffffffffffffffffffffffffffffffffffffff00000000000000000016178255565b61058f61056e60c08401610426565b600183016001600160a01b0382166001600160a01b03198254161781555050565b505056fea164736f6c6343000814000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063d3d62b9814610030575b600080fd5b61004361003e36600461031d565b610045565b005b7f33db93811595d149127b48476bd7ca575d33b2af3516f373596199e9ec7c30236020527ffedc2076553f0daaf85d77e64f137f70c7df3d6e2afc35fea028f67801be3d198054600160ff1991821681179092557fd99b3967c607fc392d7cba4de5e3266d240b08d14eecd560823e59167b17a40480548216831790557f44077d5b86ca1ddb347bb5faf392f7f3a0209613674226b0c58d9e8f2ba1902080548216831790556307f5828d60e41b6000527f02d4138dbc1bc27ac87468f5f810f1b88129507e2e3f0ebf89e0481bfc8486788054909116821790557fdbfac48fe43e706cd186aabbc9bf037f2ab712c873b1d76438c57a9d362adf999081557f33db93811595d149127b48476bd7ca575d33b2af3516f373596199e9ec7c3020906101736020840184610377565b6001820180546001600160a01b03929092167fffffffffffffffff000000000000000000000000000000000000000000000000909216919091177601518000000000000000000000000000000000000000001790556101dd6101d86020850185610394565b6101e2565b505050565b7fb63cbb77d85e98261667d5fc207901bcdd6950bf6d20d991f2e751c25e9709ca8160008190036102265760405163776acd5b60e01b815260040160405180910390fd5b60005b81811015610316576000858583818110610245576102456103e4565b905060e0020160a001602081019061025d9190610377565b6001600160a01b03811660009081526020869052604090205490915068010000000000000000900460ff168061030c5786868481811061029f5761029f6103e4565b6001600160a01b038516600090815260208990526040902060e0909102929092019190506102cd8282610433565b505060018581018054918201815560009081526020902001805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0384161790555b5050600101610229565b5050505050565b60006020828403121561032f57600080fd5b813567ffffffffffffffff81111561034657600080fd5b82016040818503121561035857600080fd5b9392505050565b6001600160a01b038116811461037457600080fd5b50565b60006020828403121561038957600080fd5b81356103588161035f565b6000808335601e198436030181126103ab57600080fd5b83018035915067ffffffffffffffff8211156103c657600080fd5b602001915060e0810236038213156103dd57600080fd5b9250929050565b634e487b7160e01b600052603260045260246000fd5b6000813561ffff8116811461040e57600080fd5b92915050565b60008135801515811461040e57600080fd5b6000813561040e8161035f565b61ffff61043f836103fa565b1681548161ffff19821617835563ffff000061045d602086016103fa565b60101b16808363ffffffff1984161717845565ffff00000000610482604087016103fa565b60201b168365ffffffffffff1984161782171784555050506104cb6104a9606084016103fa565b825467ffff000000000000191660309190911b67ffff00000000000016178255565b6105026104da60808401610414565b82805468ff0000000000000000191691151560401b68ff000000000000000016919091179055565b61055f61051160a08401610426565b82547fffffff0000000000000000000000000000000000000000ffffffffffffffffff1660489190911b7cffffffffffffffffffffffffffffffffffffffff00000000000000000016178255565b61058f61056e60c08401610426565b600183016001600160a01b0382166001600160a01b03198254161781555050565b505056fea164736f6c6343000814000a",
  "devdoc": {
    "custom:advice": "See the suggestions made in `Diamond.sol`, keep them in mind throughout the Diamond contracts",
    "custom:security": "It is only called once in the diamond constructor and is not saved as a facet within the diamond",
    "custom:version": "0.0.1",
    "kind": "dev",
    "methods": {
      "init((address,(uint16,uint16,uint16,uint16,bool,address,address)[]))": {
        "params": {
          "_args": "Initial arguments"
        }
      }
    },
    "title": "DiamondInit",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "init((address,(uint16,uint16,uint16,uint16,bool,address,address)[]))": {
        "notice": "Sets state variables"
      }
    },
    "notice": "Contract for setting state variables in the diamond during deployment or an upgrade",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
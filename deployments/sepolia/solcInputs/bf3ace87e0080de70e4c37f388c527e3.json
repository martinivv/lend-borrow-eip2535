{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/contracts/diamond/core/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable no-complex-fallback\n\npragma solidity =0.8.20;\n\nimport {d} from \"../libraries/DiamondState.sol\";\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\n// Consider adding remappings\nimport {DiamondErrors} from \"../../helpers/Errors.sol\";\n\n/// @title Diamond\n/// @author Forked implementation with minor compatibility modifications. Original source: https://github.com/mudgen\n/// @notice Diamond proxy contract. Serves as the primary entry point for the protocol\n/// @custom:advice If your project's complexity requires it, consider creating your own implementation\n/// @custom:advice Consider adding events and more parameters to the custom errors throughout the Diamond contracts\n/// for improved monitoring\n/// @custom:version 0.0.1\ncontract Diamond {\n    struct DiamondArgs {\n        address owner;\n        address diamondInit;\n        bytes data;\n    }\n\n    /// @notice Sets the diamond owner, cuts the @param _diamondCutFacet address, and then calls the `DiamondInit`\n    /// contract with `data`\n    /// @param _args Initial arguments\n    /// @dev Be aware that `data` is executed with delegatecall on the `DiamondInit` contract\n    constructor(DiamondArgs memory _args, address _diamondCutFacet) {\n        d().setContractOwner(_args.owner);\n\n        IDiamondCutFacet.FacetCut[] memory cut = new IDiamondCutFacet.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCutFacet.diamondCut.selector;\n        cut[0] = IDiamondCutFacet.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCutFacet.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n\n        d().diamondCut(cut, _args.diamondInit, _args.data);\n    }\n\n    /// @notice Receives ether\n    receive() external payable {}\n\n    /// @notice Finds the facet for the function that is called and executes the function if the facet is found\n    fallback() external payable {\n        address facet = address(bytes20(d().facets[msg.sig]));\n        if (facet == address(0)) revert DiamondErrors.FunctionDoesNotExist();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /// @notice A rescue function for missent/donated *msg.value*\n    function rescue() external {\n        if (msg.sender != d().contractOwner) revert DiamondErrors.MustBeDiamondOwner(msg.sender);\n\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert DiamondErrors.TransferFailed();\n    }\n}\n"
    },
    "src/contracts/diamond/core/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {ProtocolModifiers, ProtocolState, p} from \"../../domain/libraries/ProtocolState.sol\";\nimport {AllowedToken} from \"../../domain/libraries/AssetsState.sol\";\nimport {DiamondState, d} from \"../libraries/DiamondState.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {IERC173} from \"../interfaces/IERC173.sol\";\nimport {LibOwner} from \"../../domain/libraries/logic/LibOwner.sol\";\n\n/// @title DiamondInit\n/// @notice Contract for setting state variables in the diamond during deployment or an upgrade\n/// @custom:security It is only called once in the diamond constructor and is not saved as a facet within the diamond\n/// @custom:advice See the suggestions made in `Diamond.sol`, keep them in mind throughout the Diamond contracts\n/// @custom:version 0.0.1\ncontract DiamondInit is ProtocolModifiers {\n    struct DiamondInitArgs {\n        address mTokenAddress;\n        AllowedToken[] allowedTokens;\n    }\n\n    /// @notice Sets state variables\n    /// @param _args Initial arguments\n    function init(DiamondInitArgs calldata _args) external {\n        // ============= Diamond Initialization ==================================\n        DiamondState storage ds = d();\n\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCutFacet).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupeFacet).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // ============= Protocol&Assets Initialization ==================================\n        ProtocolState storage ps = p();\n\n        _initReentrancyGuard();\n        ps.mTokenAddress = _args.mTokenAddress;\n        ps.answerStalenessThreshold = 1 days;\n\n        LibOwner.setTokens(_args.allowedTokens);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {IDiamondCutFacet} from \"../interfaces/IDiamondCutFacet.sol\";\nimport {DiamondState, d} from \"../libraries/DiamondState.sol\";\nimport {initializeDiamondCut, LibDiamondCut} from \"../libraries/logic/LibDiamondCut.sol\";\n\n/// @title DiamondCutFacet\n/// @notice Declares related functions for executing a diamond cut\n/// @custom:version 0.0.1\ncontract DiamondCutFacet is IDiamondCutFacet {\n    /// @inheritdoc IDiamondCutFacet\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external override {\n        DiamondState storage ds = d();\n\n        ds.enforceIsContractOwner();\n\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        if (selectorCount & 7 > 0) selectorSlot = ds.selectorSlots[selectorCount >> 3];\n\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            // Calling it in the typical for the protocol way will result in *Stack too deep* error.\n            // Consider creating better version of the Diamond implementation\n            (selectorCount, selectorSlot) = LibDiamondCut.addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) ds.selectorCount = uint16(selectorCount);\n\n        if (selectorCount & 7 > 0) ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable code-complexity\n\npragma solidity =0.8.20;\n\nimport {IDiamondLoupeFacet} from \"../interfaces/IDiamondLoupeFacet.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\nimport {DiamondState, d} from \"../libraries/DiamondState.sol\";\nimport {DiamondErrors} from \"../../helpers/Errors.sol\";\n\n/// @title DiamondLoupeFacet\n/// @notice Declares related functions that tell you what functions and facets are provided by the diamond\n/// @custom:version 0.0.1\ncontract DiamondLoupeFacet is IDiamondLoupeFacet, IERC165 {\n    /// @inheritdoc IDiamondLoupeFacet\n    function facets() external view override returns (Facet[] memory facets_) {\n        DiamondState storage ds = d();\n\n        facets_ = new Facet[](ds.selectorCount);\n        uint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) break;\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\n\n                        if (numFacetSelectors[facetIndex] > 254) revert DiamondErrors.TooManyFunctionsInAFacet();\n\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) continue;\n\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory _facetFunctionSelectors) {\n        DiamondState storage ds = d();\n\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\n        uint256 selectorIndex;\n\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) break;\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(ds.facets[selector]));\n                if (_facet == facet) {\n                    _facetFunctionSelectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n        DiamondState storage ds = d();\n\n        facetAddresses_ = new address[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) break;\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) continue;\n\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @inheritdoc IDiamondLoupeFacet\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n        facetAddress_ = address(bytes20(d().facets[_functionSelector]));\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        return d().supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "src/contracts/diamond/facets/DiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {d} from \"../libraries/DiamondState.sol\";\nimport {IERC173} from \"../interfaces/IERC173.sol\";\nimport {DiamondErrors} from \"../../helpers/Errors.sol\";\n\n/// @title DiamondOwnershipFacet\n/// @notice Contract for managing the owner of the diamond\n/// @custom:version 0.0.1\ncontract DiamondOwnershipFacet is IERC173 {\n    /// @inheritdoc IERC173\n    function transferOwnership(address _newOwner) external override {\n        if (_newOwner == address(0)) revert DiamondErrors.NoZeroAddressOwner();\n\n        d().enforceIsContractOwner();\n        d().setContractOwner(_newOwner);\n    }\n\n    /// @inheritdoc IERC173\n    function owner() external view override returns (address owner_) {\n        owner_ = d().getContractOwner();\n    }\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n/// @title IDiamondCutFacet\n/// @notice Interface that allows modifications to diamond function selector mapping\ninterface IDiamondCutFacet {\n    /// @notice Struct used as a mapping of facet to function selectors\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Available diamond operations\n    /// @dev Add=0, Replace=1, Remove=2\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    /// @notice Emitted when facet selectors are modified\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    /// @notice Adds/replaces/removes any number of functions and optionally executes\n    /// a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute `_calldata`\n    /// @param _calldata A function call, including function selector and arguments\n    /// @dev Be aware that `_calldata` is executed with delegatecall on the `_init` contract\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n}\n"
    },
    "src/contracts/diamond/interfaces/IDiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n/// @title IDiamondLoupeFacet\ninterface IDiamondLoupeFacet {\n    /// @notice Used with {facets} to return all facet addresses and their four byte function selectors\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facets and their selectors\n    /// @return facets_ {Facet[]}\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific @param _facet\n    /// @return facetFunctionSelectors_ {bytes4[]}\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Gets all facet addresses used by a diamond\n    /// @return facetAddresses_ {address[]}\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the @return facetAddress_ that supports given @param _functionSelector\n    /// @custom:advice Consider implementing better error handling if the facet is not found\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "src/contracts/diamond/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n/// @title IERC165\n/// @notice The interface introduces support of contract interfaces, which can then be queried\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/diamond/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n/// @title IERC173\n/// @notice The interface introduces contract ownership standard\n/// @dev The ERC-165 identifier for this interface is 0x7f5828d0\ninterface IERC173 {\n    /// @notice Sets the contract's owner to a @param _newOwner's address\n    function transferOwnership(address _newOwner) external;\n\n    /// @notice Gets the @return owner_'s address\n    function owner() external view returns (address owner_);\n}\n"
    },
    "src/contracts/diamond/libraries/DiamondState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {LibDiamondCut} from \"./logic/LibDiamondCut.sol\";\nimport {LibDiamondOwnership} from \"./logic/LibDiamondOwnership.sol\";\n\nusing LibDiamondCut for DiamondState global;\nusing LibDiamondOwnership for DiamondState global;\n\n/// @notice Struct defining the current diamond state\n/// @custom:advice Consider creating a library with \"generic\" functions related to `DiamondState`\nstruct DiamondState {\n    /// @notice Function selector -> address facet and selector positions\n    mapping(bytes4 => bytes32) facets;\n    /// @notice Array of slots of function selectors, each slot holds 8 function selectors\n    mapping(uint256 => bytes32) selectorSlots;\n    /// @notice The number of function selectors in `selectorSlots`\n    uint16 selectorCount;\n    /// @notice ERC-165 implementation; query if a contract implements an interface\n    mapping(bytes4 => bool) supportedInterfaces;\n    /// @notice The owner of the Diamond contract\n    address contractOwner;\n}\n\n// ======================== Pointer ================================================================\n\nbytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"martinivv.diamond.storage\");\n\n/// @notice Used as a shared storage\n/// @return ds Storage pointer to `DiamondState` struct\nfunction d() pure returns (DiamondState storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n\n    assembly {\n        ds.slot := position\n    }\n}\n"
    },
    "src/contracts/diamond/libraries/logic/LibDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable avoid-low-level-calls\n// solhint-disable code-complexity\n// solhint-disable custom-errors\n\npragma solidity =0.8.20;\n\nimport {IDiamondCutFacet} from \"../../interfaces/IDiamondCutFacet.sol\";\nimport {DiamondState, d} from \"../DiamondState.sol\";\n// Consider adding remappings\nimport {DiamondEvents} from \"../../../helpers/Events.sol\";\nimport {DiamondErrors} from \"../../../helpers/Errors.sol\";\nimport {DiamondConstants} from \"../../../helpers/Constants.sol\";\n\n/// @notice See {diamondCut}'s @notice\n/// @custom:security Will behave like an internal function of the calling contract\nfunction initializeDiamondCut(address _init, bytes memory _calldata) {\n    if (_init == address(0)) return;\n\n    LibDiamondCut.enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n\n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\n    if (!success) {\n        if (error.length > 0) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(error)\n                revert(add(32, error), returndata_size)\n            }\n        } else {\n            revert DiamondErrors.InitializationFunctionReverted(_init, _calldata);\n        }\n    }\n}\n\n/// @title LibDiamondCut\n/// @notice Internal function versions of `DiamondCutFacet` ones\n/// @dev This code is almost the same as the external `DiamondCutFacet` one,\n/// except it is using `Facet[] memory _diamondCut` instead of\n/// `Facet[] calldata _diamondCut`. The code is duplicated to prevent\n/// copying calldata to memory which causes an error for a two dimensional array\nlibrary LibDiamondCut {\n    /// @notice Adds/replaces/removes any number of functions and optionally executes\n    /// a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute `_calldata`\n    /// @param _calldata A function call, including function selector and arguments\n    /// @dev Be aware that `_calldata` is executed with delegatecall on the `_init` contract\n    function diamondCut(\n        DiamondState storage self,\n        IDiamondCutFacet.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        uint256 originalSelectorCount = self.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n\n        if (selectorCount & 7 > 0) selectorSlot = self.selectorSlots[selectorCount >> 3];\n\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n\n        if (selectorCount != originalSelectorCount) self.selectorCount = uint16(selectorCount);\n\n        if (selectorCount & 7 > 0) self.selectorSlots[selectorCount >> 3] = selectorSlot;\n\n        emit DiamondEvents.DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    /// @notice See {diamondCut}'s @notice\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCutFacet.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondState storage self = d();\n\n        if (_selectors.length < 1) revert DiamondErrors.NoSelectorFound();\n\n        if (_action == IDiamondCutFacet.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = self.facets[selector];\n\n                if (address(bytes20(oldFacet)) != address(0)) revert DiamondErrors.FunctionAlreadyExists();\n\n                self.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                _selectorSlot =\n                    (_selectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n\n                if (selectorInSlotPosition == 224) {\n                    self.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCutFacet.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = self.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n\n                if (oldFacetAddress == address(this)) revert DiamondErrors.ImmutableFunctionDetected();\n\n                if (oldFacetAddress == _newFacetAddress) revert DiamondErrors.CannotReplaceTheSameFunction();\n\n                if (oldFacetAddress == address(0)) revert DiamondErrors.FunctionDoesNotExist();\n\n                self.facets[selector] = (oldFacet & DiamondConstants.CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCutFacet.FacetCutAction.Remove) {\n            if (_newFacetAddress != address(0)) revert DiamondErrors.MustBeZeroAddress(_newFacetAddress);\n\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            uint256 selectorInSlotIndex = _selectorCount & 7;\n\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    selectorSlotCount--;\n                    _selectorSlot = self.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = self.facets[selector];\n                    if (address(bytes20(oldFacet)) == address(0)) revert DiamondErrors.FunctionDoesNotExist();\n\n                    if (address(bytes20(oldFacet)) == address(this)) revert DiamondErrors.ImmutableFunctionDetected();\n\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n\n                    if (lastSelector != selector) {\n                        self.facets[lastSelector] =\n                            (oldFacet & DiamondConstants.CLEAR_ADDRESS_MASK) |\n                            bytes20(self.facets[lastSelector]);\n                    }\n\n                    delete self.facets[selector];\n\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = self.selectorSlots[oldSelectorsSlotCount];\n\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n\n                    self.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    _selectorSlot =\n                        (_selectorSlot & ~(DiamondConstants.CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n\n                if (selectorInSlotIndex == 0) {\n                    delete self.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert DiamondErrors.IncorrectFacetCutAction(uint8(_action));\n        }\n\n        return (_selectorCount, _selectorSlot);\n    }\n\n    /// @notice Ensures that the @param _contract has code, otherwise throws an @param _errorMessage\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "src/contracts/diamond/libraries/logic/LibDiamondOwnership.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {DiamondState} from \"../DiamondState.sol\";\nimport {DiamondErrors} from \"../../../helpers/Errors.sol\";\n\n/// @title LibDiamondOwnership\n/// @notice Library collection of diamond ownership functions\nlibrary LibDiamondOwnership {\n    /// @notice Emitted when diamond owner is updated\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Updates the diamond owner to @param _newOwner's address\n    function setContractOwner(DiamondState storage self, address _newOwner) internal {\n        address previousOwner = self.contractOwner;\n        self.contractOwner = _newOwner;\n\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    /// @notice Returns the diamond @return contractOwner_'s address\n    function getContractOwner(DiamondState storage self) internal view returns (address contractOwner_) {\n        contractOwner_ = self.contractOwner;\n    }\n\n    /// @notice Checks if `msg.sender` is the diamond owner\n    function enforceIsContractOwner(DiamondState storage self) internal view {\n        if (msg.sender != self.contractOwner) revert DiamondErrors.MustBeDiamondOwner(msg.sender);\n    }\n}\n"
    },
    "src/contracts/domain/core/MToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/* solhint-disable state-visibility */\npragma solidity =0.8.20;\n\nimport {ERC20} from \"../vendor/ERC20.sol\";\nimport {IMToken} from \"../interfaces/IMToken.sol\";\n\n/// @title MToken\n/// @notice The interest-bearing token associated with the protocol\n/// @custom:advice Consider implementing a more robust access control mechanism, like OZ's\n/// @custom:version 0.0.1\ncontract MToken is ERC20, IMToken {\n    /// @notice The address of the owner\n    address public owner;\n    /// @notice The address of the operator\n    address public operator;\n    /// @notice Initial supply amount\n    uint256 constant SUPPLY = 10_000_000 * 1e18;\n\n    /// @notice Emits when the owner address is changed\n    event OwnerChanged(address indexed owner, address indexed _newOwner);\n\n    /// @notice Triggers when the function is not called by the owner\n    error NotOwner(address _caller);\n    /// @notice Triggers when the function is not called by the protocol\n    error NotOperator(address _caller);\n\n    /// @notice Checks if the function is called by the owner of the token\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert NotOwner(msg.sender);\n        _;\n    }\n\n    /// @notice Checks if the function is called by the protocol\n    modifier onlyOperator() {\n        if (msg.sender != operator) revert NotOperator(msg.sender);\n        _;\n    }\n\n    /* ======================= Methods ===================================================== */\n\n    /// @notice Contract constructor\n    constructor() ERC20(\"MToken\", \"MMM\") {\n        owner = msg.sender;\n        emit OwnerChanged(address(0), owner);\n\n        _mint(msg.sender, SUPPLY);\n    }\n\n    /// @notice Mints token @param _amount to @param _to address\n    function mint(address _to, uint256 _amount) external onlyOwner {\n        uint256 scaledAmount = _amount * 1e18;\n\n        _mint(_to, scaledAmount);\n    }\n\n    /// @inheritdoc IMToken\n    function burn(address _from, uint256 _amount) external onlyOperator {\n        _burn(_from, _amount);\n    }\n\n    /// @notice Sets the token's owner to a new @param owner_ address\n    function setOwner(address _owner) external onlyOwner {\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    /// @notice Sets the token's operator to @param _operator\n    function setOperator(address _operator) external onlyOwner {\n        operator = _operator;\n    }\n}\n"
    },
    "src/contracts/domain/facets/BorrowFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {AssetsModifiers, a} from \"../libraries/AssetsState.sol\";\nimport {ProtocolModifiers} from \"../libraries/ProtocolState.sol\";\nimport {SafeERC20} from \"../vendor/SafeERC20.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {DomainEvents} from \"../../helpers/Events.sol\";\n\n/// @title BorrowFacet\n/// @dev Keep in mind that *most* of the functions should be symmetric with `RepayFacet` ones\n/// @custom:version 0.0.1\ncontract BorrowFacet is AssetsModifiers, ProtocolModifiers {\n    using SafeERC20 for IERC20;\n\n    /// @notice Borrows a token amount\n    /// @param _collateralAddress The address of the token which is going to be used as a collateral\n    /// @param tokenAddress The address of the wanted token\n    /// @param _tokenAmount The amount of tokens to borrow\n    /// @custom:security `_tokenAmount` should be properly handled in the front-end; whole number\n    /// @custom:exec Sanity checks -> internal state changes, returns the scaled amount (currently) -> transfer\n    function borrow(\n        address _collateralAddress,\n        address tokenAddress,\n        uint256 _tokenAmount\n    ) external enabledCollateral(_collateralAddress) allowed(tokenAddress, _tokenAmount) nonReentrant {\n        uint256 scaledAmount = a().verifyAndRecordBorrow(_collateralAddress, tokenAddress, _tokenAmount);\n\n        emit DomainEvents.Borrow(tokenAddress, _tokenAmount, msg.sender);\n        IERC20(tokenAddress).safeTransfer(msg.sender, scaledAmount);\n    }\n}\n"
    },
    "src/contracts/domain/facets/DepositFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {AssetsModifiers, StakedToken, a} from \"../libraries/AssetsState.sol\";\nimport {ProtocolModifiers} from \"../libraries/ProtocolState.sol\";\nimport {SafeERC20} from \"../vendor/SafeERC20.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {DomainEvents} from \"../../helpers/Events.sol\";\nimport {DomainErrors} from \"../../helpers/Errors.sol\";\n\n/// @title DepositFacet\n/// @dev Keep in mind that *most* of the functions should be symmetric with `WithdrawFacet` ones\n/// @custom:advice Consider adding more events, better monitoring\n/// @custom:version 0.0.1\ncontract DepositFacet is AssetsModifiers, ProtocolModifiers {\n    using SafeERC20 for IERC20;\n\n    /// @notice Deposits tokens\n    /// @param tokenAddress The address of token you want to stake\n    /// @param tokenAmount The amount of the token\n    /// @dev In the front-end — ensure correct allowance handling\n    /// @custom:security Transfers tokens before any state changes as an additional re-entrancy safeguard\n    /// @custom:security It's essential to handle decimals properly in the front-end. For the simplicity of\n    /// this version, `tokenAmount` will be a whole number\n    /// @custom:security Be aware of `safeTransferFrom` and all attack vectors associated with it\n    /// @custom:security By using `safeTransferFrom`, it will not be neccessary to check if the transaction\n    /// is succesful (including non-standard ERC20 tokens)\n    /// @custom:security The right business model is crucial for the health of the protocol. If needed,\n    /// consider applying a timed locking mechanism, adjusting the interest rate appropriately, or something else\n    /// @custom:exec Sanity modifier -> deposit -> internal state changes -> sends mTokens\n    function deposit(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) external allowed(tokenAddress, tokenAmount) nonReentrant {\n        IERC20 token = IERC20(tokenAddress);\n\n        uint256 decimals = token.decimals();\n        uint256 scaledAmount = tokenAmount * 10 ** decimals;\n        // If the depositer doesn't have enough tokens, the transfer will fail\n        token.safeTransferFrom(msg.sender, address(this), scaledAmount);\n\n        a().manageDeposit(tokenAddress, tokenAmount);\n    }\n\n    /// @notice Turns on the collateral for a staked token\n    /// @dev Should be symmetric with {turnOffCollateral}\n    function turnOnCollateral(address _tokenAddress) external nonReentrant {\n        StakedToken storage stakedToken = a().stakedTokenData[msg.sender][_tokenAddress];\n\n        if (!stakedToken.isStaked) revert DomainErrors.TokenNotStaked(msg.sender, _tokenAddress);\n        if (stakedToken.isCollateralOn) revert DomainErrors.CollateralAlreadyOn();\n\n        emit DomainEvents.CollateralOn(_tokenAddress, msg.sender);\n        // This property is currently not utilized on tokens used as collateral, which is why it's `0`\n        stakedToken.startAccumulatingDay = 0;\n        stakedToken.isCollateralOn = true;\n    }\n\n    /// @notice Turns off the collateral for a staked token\n    /// @dev Should be symmetric with {turnOnCollateral}\n    function turnOffCollateral(\n        address _tokenAddress\n    ) external enabledCollateral(_tokenAddress) notInUseCollateral(_tokenAddress) nonReentrant {\n        StakedToken storage stakedToken = a().stakedTokenData[msg.sender][_tokenAddress];\n\n        emit DomainEvents.CollateralOff(_tokenAddress, msg.sender);\n        stakedToken.startAccumulatingDay = block.timestamp;\n        stakedToken.isCollateralOn = false;\n    }\n}\n"
    },
    "src/contracts/domain/facets/LiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {AssetsModifiers, a} from \"../libraries/AssetsState.sol\";\nimport {ProtocolModifiers} from \"../libraries/ProtocolState.sol\";\nimport {SafeERC20} from \"../vendor/SafeERC20.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {DomainErrors} from \"../../helpers/Errors.sol\";\nimport {DomainEvents} from \"../../helpers/Events.sol\";\n\n/// @title LiquidationFacet\n/// @custom:version 0.0.1\ncontract LiquidationFacet is AssetsModifiers, ProtocolModifiers {\n    using SafeERC20 for IERC20;\n\n    /// @notice Implements an atypical and severe penalty when the borrower's collateral falls below\n    /// a specified threshold value. In order to prioritize simplicity\n    /// @param _borrower The address of the borrower\n    /// @param borrowedToken The address of the borrowed token\n    /// @custom:security Think of implementing a different reward system based on the business model\n    /// @custom:exec Checks -> checks if it is liquidatable -> calculates the reward for the keeper ->\n    /// internal changes -> transfer\n    function liquidate(\n        address _borrower,\n        address borrowedToken\n    ) external liquidatable(_borrower, borrowedToken) nonReentrant {\n        (address collateralAddress, uint256 rewardInTokens) = a().manageLiquidation(_borrower, borrowedToken);\n\n        a().recordLiquidation(_borrower, collateralAddress, borrowedToken);\n\n        IERC20 collateral = IERC20(collateralAddress);\n        if (collateral.balanceOf(address(this)) < rewardInTokens) revert DomainErrors.InsufficientProtocolFunds();\n\n        emit DomainEvents.Liquidation(_borrower, borrowedToken, rewardInTokens, msg.sender);\n        collateral.safeTransfer(msg.sender, rewardInTokens);\n    }\n}\n"
    },
    "src/contracts/domain/facets/OwnerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {ProtocolModifiers} from \"../libraries/ProtocolState.sol\";\nimport {AllowedToken} from \"../libraries/AssetsState.sol\";\nimport {LibOwner} from \"../libraries/logic/LibOwner.sol\";\n\n/// @title OwnerFacet\n/// @custom:security Be aware of the single point of failure vulnerability\n/// @custom:version 0.0.1\ncontract OwnerFacet is ProtocolModifiers {\n    /// @notice End-owner functionality for setting the allowed tokens during initialization or upgrade\n    /// @param _tokens {AllowedToken[]}\n    function setAllowedTokens(AllowedToken[] calldata _tokens) external onlyOwner {\n        LibOwner.setTokens(_tokens);\n    }\n}\n"
    },
    "src/contracts/domain/facets/RepayFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {AssetsModifiers, a} from \"../libraries/AssetsState.sol\";\nimport {ProtocolModifiers} from \"../libraries/ProtocolState.sol\";\nimport {SafeERC20} from \"../vendor/SafeERC20.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {DomainEvents} from \"../../helpers/Events.sol\";\n\n/// @title RepayFacet\n/// @custom:version 0.0.1\ncontract RepayFacet is AssetsModifiers, ProtocolModifiers {\n    using SafeERC20 for IERC20;\n\n    /// @notice Repays a borrow\n    /// @param _collateralAddress The address of the used collateral token\n    /// @param tokenAddress The borrowed token address\n    /// @param _tokenAmount The borrowed amount\n    /// @dev In the front-end — ensure correct allowance handling\n    /// @custom:security `_tokenAmount` should be properly handled in the front-end; whole number\n    /// @custom:exec Checks -> calculation library call -> transfer -> internal state changes\n    function repay(\n        address _collateralAddress,\n        address tokenAddress,\n        uint256 _tokenAmount\n    ) external repayableCollateral(_collateralAddress, tokenAddress) positiveAmount(_tokenAmount) nonReentrant {\n        // The right decimals are set\n        (uint256 verifiedAmount, uint256 totalToRepay) = a().calculateAmountToRepay(tokenAddress, _tokenAmount);\n        // Before any state changes as an additional re-entrancy metric\n        IERC20(tokenAddress).safeTransferFrom(msg.sender, address(this), totalToRepay);\n\n        emit DomainEvents.Repay(tokenAddress, totalToRepay, msg.sender);\n        a().recordRepay(_collateralAddress, tokenAddress, verifiedAmount);\n    }\n}\n"
    },
    "src/contracts/domain/facets/UIDataFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {LibUI} from \"../libraries/logic/LibUI.sol\";\n\n/// @title UIDataFacet\n/// @notice UI aggregated data\n/// @dev Make changes depending on the front-end model. This implementation is conceptual\n/// @custom:version 0.0.1\ncontract UIDataFacet {\n    /* =================================== Global ============================================================================================ */\n\n    /// @notice Gets global-related data of the protocol\n    /// @notice Aggregated view of the allowed tokens in @return allowedTokensBatch; in @return mTokenAddress — the address of the\n    /// interest-bearing token\n    function getProtocolTokens()\n        external\n        view\n        returns (LibUI.AllowedTokenData[] memory allowedTokensBatch, address mTokenAddress)\n    {\n        allowedTokensBatch = LibUI.batchAllowedTokens();\n        mTokenAddress = LibUI.mTokenAddress();\n    }\n\n    /* =================================== User's ============================================================================================ */\n\n    /// @notice Returns the maximum amount in USD that can be borrowed based on @param _collateralAddress\n    /// and @param _collateralAmount values\n    /// @dev `_collateralAmount` must be a whole number\n    function getMaxUsdToBorrow(\n        address _collateralAddress,\n        uint256 _collateralAmount\n    ) external view returns (uint256 maxUsdToBorrow) {\n        maxUsdToBorrow = LibUI.maxUsdToBorrow(_collateralAddress, _collateralAmount);\n    }\n\n    /// @notice Aggregated view of @param _account's staked tokens in @return stakedTokensBatch\n    function getStakedTokens(\n        address _account\n    ) external view returns (LibUI.StakedTokenData[] memory stakedTokensBatch) {\n        stakedTokensBatch = LibUI.batchStakedTokens(_account);\n    }\n\n    /// @notice Aggregated view of @param _account's borrowed tokens in @return borrowedTokensBatch\n    function getBorrowedTokens(\n        address _account\n    ) external view returns (LibUI.BorrowedTokenData[] memory borrowedTokensBatch) {\n        borrowedTokensBatch = LibUI.batchBorrowedTokens(_account);\n    }\n\n    /* =================================== Keeper's ============================================================================================ */\n\n    /// @notice Returns all borrowers in the protocol as @return allBorrowers\n    function getAllBorrowers() external view returns (address[] memory allBorrowers) {\n        allBorrowers = LibUI.allBorrowers();\n    }\n\n    /// @notice Gets relevant @param _account information. Returns it as @return data\n    function getAccountData(address _accountAddress) external view returns (LibUI.AccountData memory accountData) {\n        accountData = LibUI.batchAccountData(_accountAddress);\n    }\n\n    /// @notice Checks if the @param _account is liquidatable based on @param _collateralAddress and @param _borrowedTokenAddress.\n    /// @return result `true` if it is, otherwise `false`\n    function isLiquidatable(\n        address _account,\n        address _collateralAddress,\n        address _borrowedTokenAddress\n    ) external view returns (bool result) {\n        result = LibUI.isLiquidatable(_account, _collateralAddress, _borrowedTokenAddress);\n    }\n}\n"
    },
    "src/contracts/domain/facets/WithdrawFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {AssetsModifiers, a} from \"../libraries/AssetsState.sol\";\nimport {ProtocolModifiers, p} from \"../libraries/ProtocolState.sol\";\nimport {SafeERC20} from \"../vendor/SafeERC20.sol\";\nimport {IMToken} from \"../interfaces/IMToken.sol\";\nimport {DomainEvents} from \"../../helpers/Events.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @title WithdrawFacet\n/// @custom:version 0.0.1\ncontract WithdrawFacet is AssetsModifiers, ProtocolModifiers {\n    using SafeERC20 for IERC20;\n\n    /// @notice Withdraws @param _tokenAmount of @param tokenAddress\n    /// @custom:security `_tokenAmount` should be properly handled in the front-end.\n    /// Should be solely the number of tokens (without decimal portion)\n    /// @custom:advice Consider checking the balance of the interest-bearing token; if necessary\n    /// @custom:advice Consider implementing event monitoring for the interest-bearing token\n    /// @custom:exec Sanity checks -> calculation call -> burn -> records withdraw -> transfer\n    function withdraw(\n        address tokenAddress,\n        uint256 _tokenAmount\n    ) external notInUseCollateral(tokenAddress) positiveAmount(_tokenAmount) nonReentrant {\n        (uint256 verifiedAmount, uint256 withdrawAmount, uint256 mTokensToBurn) = a().calculateWithdraw(\n            tokenAddress,\n            _tokenAmount\n        );\n        // The right decimals are applied\n        IMToken(p().mTokenAddress).burn(msg.sender, mTokensToBurn);\n\n        a().recordWithdraw(tokenAddress, verifiedAmount);\n\n        emit DomainEvents.Withdraw(tokenAddress, withdrawAmount, msg.sender);\n        IERC20(tokenAddress).safeTransfer(msg.sender, withdrawAmount);\n    }\n}\n"
    },
    "src/contracts/domain/interfaces/IAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n/// @title IAggregatorV3\n/// @notice This interface enables utilization of Chainlink data feeds\ninterface IAggregatorV3 {\n    /// @notice Returns the number of decimals in the response\n    /// @return {uint8}\n    function decimals() external view returns (uint8);\n\n    /// @notice Gets data from the latest round\n    /// @return roundId The round ID\n    /// @return answer The data that this specific feed provides\n    /// @return startedAt Timestamp of when the round started\n    /// @return updatedAt Timestamp of when the round was updated\n    /// @return answeredInRound Deprecated. Previously used when answers could take multiple rounds to be computed\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "src/contracts/domain/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n/// @title IERC20\n/// @notice Interface for standard ERC20 implementation\ninterface IERC20 {\n    /// @notice Emmited when @param value tokens are moved @param from to @param to account\n    /// @dev `value` may be zero\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Emitted when the allowance of a @param spender for an @param owner is\n    /// set by a call to {approve}. @param value is the new allowance\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the name of the token\n    /// @return {string}\n    function name() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token\n    /// @return {uint8}\n    function decimals() external view returns (uint8);\n\n    /// @notice Returns the value of tokens in existence\n    /// @return {uint256}\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the value of tokens owned by @param _owner\n    /// @return {uint256}\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Moves a @param _value amount of tokens from the caller's account to @param _to\n    /// @return Returns a boolean value indicating whether the operation succeeded\n    /// @dev Emits a {Transfer} event\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    /// @notice Moves a @param _value amount of tokens from @param _from to @param _to using the\n    /// allowance mechanism. @param _value is then deducted from the caller's allowance\n    /// @return Returns a boolean value indicating whether the operation succeeded\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n    /// @notice Sets a @param _value amount of tokens as the allowance of @param _spender over the\n    /// caller's tokens\n    /// @return Returns a boolean value indicating whether the operation succeeded\n    /// @custom:security Beware that changing an allowance with this method brings the risk\n    /// that someone may use both the old and the new allowance by unfortunate transaction ordering.\n    /// One possible solution to mitigate this race condition is to first reduce the spender's\n    /// allowance to 0 and set the desired value afterwards:\n    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function allowance(address _owner, address _spender) external view returns (uint256);\n}\n"
    },
    "src/contracts/domain/interfaces/IMToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n/// @title IMToken\n/// @notice Interface for the interest-bearing token *mToken*\ninterface IMToken {\n    /// @notice Burns @param _amount of tokens from @param _from\n    function burn(address _from, uint256 _amount) external;\n}\n"
    },
    "src/contracts/domain/libraries/AssetsState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {LibDeposit} from \"./logic/LibDeposit.sol\";\nimport {LibBorrow} from \"./logic/LibBorrow.sol\";\nimport {LibRepay} from \"./logic/LibRepay.sol\";\nimport {LibWithdraw} from \"./logic/LibWithdraw.sol\";\nimport {LibLiquidation} from \"./logic/LibLiquidation.sol\";\nimport {LibCalculator} from \"./logic/LibCalculator.sol\";\nimport {IAggregatorV3} from \"../interfaces/IAggregatorV3.sol\";\nimport {DomainErrors} from \"../../helpers/Errors.sol\";\n\nusing LibDeposit for AssetsState global;\nusing LibBorrow for AssetsState global;\nusing LibRepay for AssetsState global;\nusing LibWithdraw for AssetsState global;\nusing LibLiquidation for AssetsState global;\nusing LibCalculator for AssetsState global;\n\n/// @notice Defines the properties for an allowed token\n/// @dev Parameters used for calculations are present in basis points. For example,\n/// 1000 basis points = a 10 % staking stable rate\nstruct AllowedToken {\n    /// @notice Used as a parameter (on withdrawing) for calculating the daily interest (in tokens)\n    /// for *solely* staking the token\n    uint16 stakeStableRate;\n    /// @notice Used as a parameter (on repaying) for calculating the daily interest (in tokens) to\n    /// be paid back for a borrowed token\n    uint16 borrowStableRate;\n    /// @notice The token's LTV ratio. Higher value — higher risk for the protocol's health\n    uint16 ltv;\n    /// @notice The token's liquidation threshold. If the borrowed amount in USD surpasses\n    /// this limit, the borrower should be liquidated\n    /// @dev 8_000 BPs = 80 % of the collateral\n    uint16 liquidationThreshold;\n    /// @notice Returns `true` if the token is allowed, otherwise `false`\n    bool isAllowed;\n    /// @notice The address of the token used for setting up the protocol's allowed tokens\n    address tokenAddress;\n    /// @notice The address of the Chainlink data feed\n    IAggregatorV3 dataFeed;\n}\n\n/// @notice Defines the properties for a staked token\nstruct StakedToken {\n    /// @notice The staked amount\n    uint256 amountStaked;\n    /// @notice Marks the start of the staking period, measured in seconds since the Unix epoch (block.timestamp)\n    uint256 startAccumulatingDay;\n    /// @notice Returns `true` if the token is staked, otherwise `false`\n    bool isStaked;\n    /// @notice Returns `true` if the token can be used as collateral for borrowing\n    bool isCollateralOn;\n    /// @notice Returns `true` if the token is currently used as collateral for a borrowed token\n    bool isCollateralInUse;\n}\n\n/// @notice Defines the properties for a borrowed token\nstruct BorrowedToken {\n    /// @notice The borrowed amount\n    uint256 amountBorrowed;\n    /// @notice Marks the start of the borrowing period, measured in seconds since the Unix epoch (block.timestamp)\n    uint256 startAccumulatingDay;\n    /// @notice Returns `true` if the token is borrowed, otherwise `false`\n    bool isBorrowed;\n    /// @notice The address of the used collateral\n    address collateralAddress;\n    /// @notice The amount tokens used for the borrow\n    uint256 collateralAmount;\n}\n\n/// @notice Struct defining the current assets state\n/// @custom:advice Consider creating a library with \"generic\" functions related to `AssetsState`\nstruct AssetsState {\n    /// @notice Protocol's allowed tokens data. Token address -> token data\n    mapping(address => AllowedToken) allowedTokenData;\n    /// @notice Protocol's allowed tokens\n    address[] allowedTokens;\n    // ======================= STAKE ===========================================================\n    /// @notice Account -> token address -> staking data\n    mapping(address => mapping(address => StakedToken)) stakedTokenData;\n    /// @notice Account -> array of staked token addresses\n    mapping(address => address[]) stakedTokens;\n    // ======================= BORROW ===========================================================\n    /// @notice Account -> token address -> borrowing data\n    mapping(address => mapping(address => BorrowedToken)) borrowedTokenData;\n    /// @notice Account -> array of borrowed token addressess\n    mapping(address => address[]) borrowedTokens;\n    /// @notice Protocol's borrowers\n    address[] borrowers;\n}\n\n/* ============================= Pointer =============================================================================== */\n\nbytes32 constant ASSETS_STORAGE_POSITION = keccak256(\"martinivv.assets.storage\");\n\n/// @notice Used as a shared storage\n/// @return ast Storage pointer to `AssetsState` struct\n/// @dev Any operation involving `ast` will read from or write to **storage**\nfunction a() pure returns (AssetsState storage ast) {\n    bytes32 position = ASSETS_STORAGE_POSITION;\n\n    assembly {\n        ast.slot := position\n    }\n}\n\n/* ============================= Modifiers =============================================================================== */\n\n/// @notice Includes modifiers shared across protocol's contracts\nabstract contract AssetsModifiers {\n    /* ============================= Deposit & Borrow =========================================================== */\n\n    /// @notice Checks if @param _tokenAddress is allowed and @param _tokenAmount is greater than 0\n    /// @custom:security Zero value ERC20 transfers are terminated in the protocol\n    modifier allowed(address _tokenAddress, uint256 _tokenAmount) {\n        if (!a().allowedTokenData[_tokenAddress].isAllowed) {\n            revert DomainErrors.TokenNotAllowed(msg.sender, _tokenAddress);\n        }\n        if (_tokenAmount == 0) revert DomainErrors.AmountShouldBePositive(msg.sender);\n        _;\n    }\n\n    /// @notice Looks the @param _tokenAddress's collateral option to be enabled\n    /// @custom:security When enabled, it is checked whether it is staked or not\n    modifier enabledCollateral(address _tokenAddress) {\n        if (!a().stakedTokenData[msg.sender][_tokenAddress].isCollateralOn) {\n            revert DomainErrors.CollateralNotEnabled(msg.sender, _tokenAddress);\n        }\n        _;\n    }\n\n    /// @notice Looks the @param _collateralAddress to not be currently in use\n    /// @custom:security The property `isCollateralInUse` is controlled in `BorrowFacet` and\n    /// `RepayFacet`, the necessary checks are made\n    modifier notInUseCollateral(address _collateralAddress) {\n        if (!a().stakedTokenData[msg.sender][_collateralAddress].isStaked) {\n            revert DomainErrors.TokenNotStaked(msg.sender, _collateralAddress);\n        }\n        if (a().stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse) {\n            revert DomainErrors.CollateralCurrentlyInUse();\n        }\n        _;\n    }\n\n    /* ============================= Repay =========================================================== */\n\n    /// @notice Looks @param _collateralAddress and @param _borrowedToken to be repayable\n    /// @custom:security Checking the validity of the `_collateralAddress` is crucial for the\n    /// protocol security, otherwise could lead to critical vulnerability\n    modifier repayableCollateral(address _collateralAddress, address _borrowedToken) {\n        if (a().borrowedTokenData[msg.sender][_borrowedToken].collateralAddress != _collateralAddress) {\n            revert DomainErrors.CollateralMismatch();\n        }\n        if (!a().stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse) {\n            revert DomainErrors.CollateralNotInUse();\n        }\n        _;\n    }\n\n    /* ============================= Liquidation =========================================================== */\n\n    /// @notice Looks @param _borrower and @param _borrowedToken to be liquidatable\n    modifier liquidatable(address _borrower, address _borrowedToken) {\n        if (msg.sender == _borrower) revert DomainErrors.SelfLiquidationNotAllowed();\n        if (!a().borrowedTokenData[_borrower][_borrowedToken].isBorrowed) {\n            revert DomainErrors.TokenNotBorrowed(msg.sender, _borrowedToken);\n        }\n        _;\n    }\n\n    /* ============================= Global =========================================================== */\n\n    /// @notice Looks @param _tokenAmount to be positive\n    modifier positiveAmount(uint256 _tokenAmount) {\n        if (_tokenAmount == 0) revert DomainErrors.AmountShouldBePositive(msg.sender);\n        _;\n    }\n}\n"
    },
    "src/contracts/domain/libraries/logic/LibBorrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {Array} from \"./utils/Array.sol\";\nimport {AssetsState, BorrowedToken} from \"../AssetsState.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {DomainErrors} from \"../../../helpers/Errors.sol\";\n\n/// @title LibBorrow\nlibrary LibBorrow {\n    using Array for address[];\n\n    /// @notice Verifies the truth of account parameters and records the borrow\n    /// @param _collateralAddress The address of the token used as collateral for the borrow\n    /// @param _tokenAddress The address of the borrowed token\n    /// @param _tokenAmount The amount to be borrowed\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\n    /// @custom:advice If `_tokenAmount` cannot be borrowed, consider implementing logic where\n    /// the maximum available token amount is passed to the `BorrowFacet`\n    /// @custom:exec Sanity checks (internal calls to `LibCalculator`) -> internal state updates\n    function verifyAndRecordBorrow(\n        AssetsState storage self,\n        address _collateralAddress,\n        address _tokenAddress,\n        uint256 _tokenAmount\n    ) internal returns (uint256 scaledAmount) {\n        /* ========================= Sanity checks ======================================================================== */\n\n        (uint256 collateralAmount, uint256 maxToBorrowInUsd) = self.getMaxAmountToBorrowInUsd(_collateralAddress);\n        uint256 amountToBeBorrowedInUsd = self.getNormalizedUsdEquivalent(_tokenAddress, _tokenAmount);\n\n        if (amountToBeBorrowedInUsd > maxToBorrowInUsd) {\n            revert DomainErrors.CannotBorrowAmount(msg.sender, maxToBorrowInUsd, amountToBeBorrowedInUsd);\n        }\n\n        IERC20 token = IERC20(_tokenAddress);\n        uint8 decimals = token.decimals();\n        scaledAmount = _tokenAmount * 10 ** decimals;\n\n        if (token.balanceOf(address(this)) < scaledAmount) revert DomainErrors.InsufficientProtocolFunds();\n\n        /* ========================= Updating internal state ======================================================================== */\n\n        BorrowedToken storage borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\n\n        bool isTokenBorrowed = borrowedToken.isBorrowed;\n\n        if (isTokenBorrowed) {\n            address collateralInUse = borrowedToken.collateralAddress;\n            if (_collateralAddress != collateralInUse) revert DomainErrors.CollateralMismatch();\n\n            borrowedToken.amountBorrowed += _tokenAmount;\n        } else {\n            BorrowedToken memory currentToken = BorrowedToken({\n                amountBorrowed: _tokenAmount,\n                startAccumulatingDay: block.timestamp,\n                isBorrowed: true,\n                collateralAddress: _collateralAddress,\n                collateralAmount: collateralAmount\n            });\n\n            // Always manage together!\n            self.borrowedTokenData[msg.sender][_tokenAddress] = currentToken;\n            self.borrowedTokens[msg.sender].push(_tokenAddress);\n            // =======\n            self.borrowers.safePush(msg.sender);\n\n            self.stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse = true;\n        }\n    }\n}\n"
    },
    "src/contracts/domain/libraries/logic/LibCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {AssetsState} from \"../AssetsState.sol\";\n// Add remappings\nimport {DomainConstants} from \"../../../helpers/Constants.sol\";\nimport {p} from \"../ProtocolState.sol\";\nimport {IAggregatorV3} from \"../../interfaces/IAggregatorV3.sol\";\nimport {DomainErrors} from \"../../../helpers/Errors.sol\";\n\n/// @title LibCalculator\n/// @custom:advice If needed, implement max ratio constant\nlibrary LibCalculator {\n    /// @notice Gets the borrowing power in USD\n    /// @param _collateralAddress The address of the used collateral for the borrow\n    /// @return collateralAmount The amount of the used collateral\n    /// @return maxToBorrowInUsd The maximum USD amount you can borrow\n    /// @dev LTV ratio is represented in basis points, 500 basis points = 5 %\n    /// @custom:security Reverts if the extraction in `value` results in a negative value\n    /// @custom:security The integral business model is not considered, may occur wrong calculations, loss of funds.\n    /// It's a demo version\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\n    /// closely/further monitored\n    /// @custom:exec Gets the USD equivalent of the collateral amount -> calculates the\n    /// max borrowing amount in USD\n    function getMaxAmountToBorrowInUsd(\n        AssetsState storage self,\n        address _collateralAddress\n    ) internal view returns (uint256 collateralAmount, uint256 maxToBorrowInUsd) {\n        collateralAmount = self.stakedTokenData[msg.sender][_collateralAddress].amountStaked;\n        uint256 collateralInUsd = getNormalizedUsdEquivalent(self, _collateralAddress, collateralAmount);\n        uint16 tokenLtv = self.allowedTokenData[_collateralAddress].ltv;\n\n        // Calculates the result of the expression `collateralInUsd - (collateralInUsd * tokenLtv / BASIS_POINTS)`.\n        // The calculation within the parentheses is rounded down\n        uint256 denominator = DomainConstants.BASIS_POINTS;\n        assembly {\n            let z := mul(collateralInUsd, tokenLtv)\n\n            if iszero(\n                and(iszero(iszero(denominator)), or(iszero(collateralInUsd), eq(div(z, collateralInUsd), tokenLtv)))\n            ) {\n                revert(0, 0)\n            }\n\n            z := div(z, denominator)\n            maxToBorrowInUsd := sub(collateralInUsd, z)\n        }\n    }\n\n    /// @notice Calculates the USD equivalent value of a token amount\n    /// @param _tokenAddress The token's address\n    /// @param _tokenAmount The token amount\n    /// @return value The normalized USD value obtained by `tokenAmount *\n    /// the token's USD price / decimals to be removed`\n    function getNormalizedUsdEquivalent(\n        AssetsState storage self,\n        address _tokenAddress,\n        uint256 _tokenAmount\n    ) internal view returns (uint256 value) {\n        (uint256 oracleResponse, uint8 decimals) = _getTokenPriceInUsd(self, _tokenAddress);\n\n        value = (_tokenAmount * oracleResponse) / (10 ** decimals);\n    }\n\n    /// @notice Gets the raw price and decimals of an allowed token\n    /// @param _tokenAddress The allowed token\n    /// @return oracleResponse Returns the raw price with `decimals`, not divided by a decimal point\n    /// @return decimals *Typically* comes with a value of 8\n    /// @custom:security Consider implementing backup oracle(-s) logic in case of failure;\n    /// TWAP or other verifiably secure options are recommended\n    function _getTokenPriceInUsd(\n        AssetsState storage state,\n        address _tokenAddress\n    ) private view returns (uint256 oracleResponse, uint8 decimals) {\n        IAggregatorV3 dataFeed = state.allowedTokenData[_tokenAddress].dataFeed;\n\n        try dataFeed.latestRoundData() returns (uint80 roundId, int256 answer, uint256, uint256 updatedAt, uint80) {\n            if (answer < 1) revert DomainErrors.AnswerShouldBePositiveNum(roundId, answer);\n\n            if (updatedAt == 0) revert DomainErrors.InvalidTime(roundId, updatedAt);\n\n            if (block.timestamp - updatedAt > p().answerStalenessThreshold) {\n                revert DomainErrors.StalePrice(roundId);\n            }\n\n            oracleResponse = uint256(answer);\n        } catch {\n            revert DomainErrors.OracleNotAvailable(dataFeed);\n        }\n\n        decimals = dataFeed.decimals();\n    }\n}\n"
    },
    "src/contracts/domain/libraries/logic/LibDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {SafeERC20} from \"../../vendor/SafeERC20.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {AssetsState, StakedToken} from \"../AssetsState.sol\";\nimport {p} from \"../ProtocolState.sol\";\nimport {DomainErrors} from \"../../../helpers/Errors.sol\";\nimport {DomainEvents} from \"../../../helpers/Events.sol\";\n\n/// @title LibDeposit\nlibrary LibDeposit {\n    using SafeERC20 for IERC20;\n\n    /// @notice Manages the deposit by changing the internal protocol state. Then sends mTokens\n    /// @param _tokenAddress The deposited token address\n    /// @param _tokenAmount The token amount without decimals\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\n    function manageDeposit(AssetsState storage self, address _tokenAddress, uint256 _tokenAmount) internal {\n        StakedToken storage stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\n\n        bool isTokenStaked = stakedToken.isStaked;\n\n        if (isTokenStaked) {\n            stakedToken.amountStaked += _tokenAmount;\n            stakedToken.startAccumulatingDay = block.timestamp;\n        } else {\n            StakedToken memory currentToken = StakedToken({\n                amountStaked: _tokenAmount,\n                startAccumulatingDay: block.timestamp,\n                isStaked: true,\n                isCollateralOn: false,\n                isCollateralInUse: false\n            });\n\n            // Always manage together!\n            self.stakedTokenData[msg.sender][_tokenAddress] = currentToken;\n            self.stakedTokens[msg.sender].push(_tokenAddress);\n            // =======\n        }\n\n        _sendMTokens(self, _tokenAddress, _tokenAmount);\n    }\n\n    /// @notice Sends mTokens; the interest-bearing token back for a deposited token\n    /// @param _tokenAddress The deposited token's address\n    /// @param _tokenAmount The deposited token's amount\n    /// @custom:security Ensure you're using the right decimals, otherwise this can lead\n    /// to wrong calculations, misleading errors, loss of funds\n    /// @custom:advice Consider implementing event monitoring for the interest-bearing token\n    function _sendMTokens(AssetsState storage state, address _tokenAddress, uint256 _tokenAmount) private {\n        // The price of the token amount without decimals\n        uint256 sendAmount = state.getNormalizedUsdEquivalent(_tokenAddress, _tokenAmount);\n\n        IERC20 mToken = IERC20(p().mTokenAddress);\n        uint8 decimals = mToken.decimals();\n\n        uint256 scaledAmount = sendAmount * 10 ** decimals;\n        if (scaledAmount > mToken.balanceOf(address(this))) revert DomainErrors.NotEnoughTokensInExistence();\n\n        emit DomainEvents.Deposit(_tokenAddress, _tokenAmount, msg.sender);\n        mToken.safeTransfer(msg.sender, scaledAmount);\n    }\n}\n"
    },
    "src/contracts/domain/libraries/logic/LibLiquidation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {Array} from \"./utils/Array.sol\";\nimport {AssetsState, BorrowedToken} from \"../AssetsState.sol\";\nimport {DomainConstants} from \"../../../helpers/Constants.sol\";\nimport {DomainErrors} from \"../../../helpers/Errors.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\n\n/// @title LibLiquidation\nlibrary LibLiquidation {\n    using Array for address[];\n\n    /// @notice Returns keeper's @return rewardInTokens, otherwise, if the @param _borrower is not\n    /// for liquidation, reverts\n    /// @param _borrowedToken The address of the borrowed token\n    /// @dev Calculations once again are in basis points. 8_000 BPs = 80 %\n    /// @custom:advice Consider adding another mechanism instead of reverting; if needed\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\n    /// closely/further monitored\n    /// @custom:security Gives 50 % (5_000 BPs) of the reward to the keeper to establish some form\n    /// of equilibrium in the protocol (pays interest to the supporters). Don't forget that this\n    /// is a DEFI protocol\n    function manageLiquidation(\n        AssetsState storage self,\n        address _borrower,\n        address _borrowedToken\n    ) internal view returns (address collateralAddress, uint256 rewardInTokens) {\n        BorrowedToken memory borrowedToken = self.borrowedTokenData[_borrower][_borrowedToken];\n\n        /* ==================================== Is liquidatable? =========================================================================== */\n\n        // ========== Collateral in USD ==============================\n        collateralAddress = borrowedToken.collateralAddress;\n        uint256 collateralAmount = self.stakedTokenData[_borrower][collateralAddress].amountStaked;\n        uint256 collateralInUsd = self.getNormalizedUsdEquivalent(collateralAddress, collateralAmount);\n\n        // ========== Borrowed in USD ==============================\n        uint256 borrowedAmount = borrowedToken.amountBorrowed;\n        uint256 borrowedInUsd = self.getNormalizedUsdEquivalent(_borrowedToken, borrowedAmount);\n\n        // ========== Finding the limit ==============================\n        uint16 collateralThreshold = self.allowedTokenData[collateralAddress].liquidationThreshold;\n        // For example. `8_000 * 1000 / 10_000` equals to `800`\n        uint256 limitInUsd = (collateralThreshold * collateralInUsd) / DomainConstants.BASIS_POINTS;\n        if (borrowedInUsd < limitInUsd) revert DomainErrors.NotLiquidatable(msg.sender);\n\n        /* =============================== Calculating the keeper reward ========================================================================== */\n\n        // `(5_000 * (2400 - 2000)) / 10_000` equals to `200`\n        uint256 rewardInUsd = (5_000 * (borrowedInUsd - limitInUsd)) / DomainConstants.BASIS_POINTS;\n        uint256 singleTokenPrice = rewardInUsd / borrowedAmount;\n        uint8 decimals = IERC20(_borrowedToken).decimals();\n        rewardInTokens = (rewardInUsd * 10 ** decimals) / singleTokenPrice;\n    }\n\n    /// @notice Records the liquidation into the internal state\n    /// @param _borrower The address of the borrower\n    /// @param _collateralAddress The address of the used collateral token\n    /// @param _borrowedToken The address of the borrowed token\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\n    function recordLiquidation(\n        AssetsState storage self,\n        address _borrower,\n        address _collateralAddress,\n        address _borrowedToken\n    ) internal {\n        delete self.stakedTokenData[_borrower][_collateralAddress];\n        self.stakedTokens[_borrower].remove(_collateralAddress);\n\n        delete self.borrowedTokenData[_borrower][_borrowedToken];\n        self.borrowedTokens[_borrower].remove(_borrowedToken);\n    }\n}\n"
    },
    "src/contracts/domain/libraries/logic/LibOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {AllowedToken, AssetsState, a} from \"../AssetsState.sol\";\nimport {DomainErrors} from \"../../../helpers/Errors.sol\";\n\n/// @title LibOwner\nlibrary LibOwner {\n    /// @notice Sets the allowed tokens for the protocol\n    /// @param _tokens Tokens to be allowed\n    /// @custom:security Security measures taken for the *for* loop:\n    /// 1. The array is cached outside, making it gas-optimized;\n    /// 2. There is no storage array that can grow infinitely;\n    /// 3. There are no external calls within the loop, potentially preventing a DoS attack\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\n    function setTokens(AllowedToken[] calldata _tokens) internal {\n        AssetsState storage ast = a();\n\n        uint256 length = _tokens.length;\n        if (length == 0) revert DomainErrors.NoTokensFound();\n\n        for (uint256 i; i < length; ) {\n            address tokenAddress = _tokens[i].tokenAddress;\n\n            bool isAdded = ast.allowedTokenData[tokenAddress].isAllowed;\n            if (!isAdded) {\n                // Always manage together!\n                ast.allowedTokenData[tokenAddress] = _tokens[i];\n                ast.allowedTokens.push(tokenAddress);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/domain/libraries/logic/LibRepay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {Array} from \"./utils/Array.sol\";\nimport {AssetsState, BorrowedToken} from \"../AssetsState.sol\";\nimport {DomainConstants} from \"../../../helpers/Constants.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {DomainErrors} from \"../../../helpers/Errors.sol\";\n\n/// @title LibRepay\nlibrary LibRepay {\n    using Array for address[];\n\n    /// @notice Makes internal changes\n    /// @param _collateralAddress The address of the used collateral token\n    /// @param _tokenAddress The address of the repaid token\n    /// @param _verifiedAmount The verified amount of the repaid token\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\n    /// @custom:security Can't occur the mapping/array vulnerability where the mapping/array remains accessible\n    /// even after deletion, because in this case it's not nested\n    function recordRepay(\n        AssetsState storage self,\n        address _collateralAddress,\n        address _tokenAddress,\n        uint256 _verifiedAmount\n    ) internal {\n        BorrowedToken storage borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\n\n        // Still hasn't been updated\n        uint256 currentAmount = borrowedToken.amountBorrowed;\n\n        if (_verifiedAmount == currentAmount) {\n            // Always manage together!\n            delete self.borrowedTokenData[msg.sender][_tokenAddress];\n            self.borrowedTokens[msg.sender].remove(_tokenAddress);\n            // =======\n            if (self.borrowedTokens[msg.sender].length == 0) self.borrowers.remove(msg.sender);\n\n            // Managing the collateral token\n            self.stakedTokenData[msg.sender][_collateralAddress].isCollateralInUse = false;\n        } else {\n            borrowedToken.amountBorrowed -= _verifiedAmount;\n        }\n    }\n\n    /// @notice Calculates the amount to be repaid\n    /// @param _tokenAddress The borrowed token\n    /// @param _tokenAmount The borrowed amount\n    /// @return verifiedAmount Ensures correct state changes in {recordRepay}\n    /// @return totalToRepay The amount with the right token decimals\n    /// @custom:security The integral business model is not considered; wrong calculations and loss of funds may occur.\n    /// Calculations are only used for demo purposes\n    /// @custom:security If `startAccumulatingDay` is in the current day, `verifiedNumDays` will receive a value of\n    /// 1 (day) to ensure proper calculations in the current version, thereby preventing a critical vulnerability\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\n    /// closely/further monitored\n    function calculateAmountToRepay(\n        AssetsState storage self,\n        address _tokenAddress,\n        uint256 _tokenAmount\n    ) internal view returns (uint256 verifiedAmount, uint256 totalToRepay) {\n        /* ============================== Setup =========================================================================== */\n\n        BorrowedToken memory borrowedToken = self.borrowedTokenData[msg.sender][_tokenAddress];\n\n        uint256 borrowedAmount = borrowedToken.amountBorrowed;\n\n        IERC20 token = IERC20(_tokenAddress);\n        uint8 decimals = token.decimals();\n\n        verifiedAmount = (_tokenAmount > borrowedAmount ? borrowedAmount : _tokenAmount);\n        uint256 scaledAmount = verifiedAmount * 10 ** decimals;\n\n        /* ============================== Interest =========================================================================== */\n\n        uint256 startAccumulatingDay = borrowedToken.startAccumulatingDay;\n        uint16 tokenBorrowStableRate = self.allowedTokenData[_tokenAddress].borrowStableRate;\n\n        uint256 numDays = (block.timestamp - startAccumulatingDay) / DomainConstants.SECONDS_PER_DAY;\n\n        uint256 verifiedNumDays = numDays > 0 ? numDays : 1;\n        // For example. `100e18 * 500 / 10_000` equals to `5e18`\n        uint256 dailyInterestInTokens = (scaledAmount * tokenBorrowStableRate) / DomainConstants.BASIS_POINTS;\n        // `15 * 5e18 / 365` equals to `(0.)205479452054794520`\n        uint256 accumulatedInterestInTokens = (verifiedNumDays * dailyInterestInTokens) / DomainConstants.DAYS_PER_YEAR;\n\n        /* ============================== Finalization =========================================================================== */\n\n        // `100e18 + 205479452054794520` equals to `100205479452054794520`\n        totalToRepay = scaledAmount + accumulatedInterestInTokens;\n\n        if (token.balanceOf(msg.sender) < totalToRepay) revert DomainErrors.InsufficientTokenAmount();\n    }\n}\n"
    },
    "src/contracts/domain/libraries/logic/LibUI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {AllowedToken, a, AssetsState, StakedToken, BorrowedToken} from \"../AssetsState.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {p} from \"../ProtocolState.sol\";\nimport {DomainErrors} from \"../../../helpers/Errors.sol\";\nimport {DomainConstants} from \"../../../helpers/Constants.sol\";\n\n/// @title LibUI\n/// @notice Methods that return requested data\nlibrary LibUI {\n    /// @notice Returned as a data in {batchAllowedTokens}\n    struct AllowedTokenData {\n        address tokenAddress;\n        uint16 stakeStableRate;\n        uint16 borrowStableRate;\n        uint16 ltv;\n        uint16 liquidationThreshold;\n        string name;\n    }\n\n    /// @notice Returned as a data in {batchStakedTokens}\n    struct StakedTokenData {\n        uint256 amountStaked;\n        uint256 startAccumulatingDay;\n        address tokenAddress;\n        bool isCollateralOn;\n        bool isCollateralInUse;\n        string name;\n    }\n\n    /// @notice Returned as a data in {batchBorrowedTokens}\n    struct BorrowedTokenData {\n        uint256 amountBorrowed;\n        uint256 startAccumulatingDay;\n        string name;\n        address tokenAddress;\n        address collateralAddress;\n        uint256 collateralAmount;\n    }\n\n    /// @notice Returned as a data in {accountData}\n    struct AccountData {\n        address[] stakedTokens;\n        address[] borrowedTokens;\n    }\n\n    /* ======================================= Global ============================================================================================ */\n\n    /// @notice Batches allowed tokens related info in @return data\n    function batchAllowedTokens() internal view returns (AllowedTokenData[] memory data) {\n        address[] memory tokens = a().allowedTokens;\n\n        uint256 length = tokens.length;\n        data = new AllowedTokenData[](length);\n\n        for (uint256 i; i < length; i++) {\n            address tokenAddr = tokens[i];\n            AllowedToken memory token = a().allowedTokenData[tokenAddr];\n\n            data[i] = AllowedTokenData({\n                tokenAddress: tokenAddr,\n                stakeStableRate: token.stakeStableRate,\n                borrowStableRate: token.borrowStableRate,\n                ltv: token.ltv,\n                liquidationThreshold: token.liquidationThreshold,\n                name: IERC20(tokenAddr).name()\n            });\n        }\n    }\n\n    /// @notice Returns the address of the interest-bearing token in @return data\n    function mTokenAddress() internal view returns (address data) {\n        data = p().mTokenAddress;\n    }\n\n    /* ======================================= User's ============================================================================================ */\n\n    /// @notice Calculates the maximum amount in USD that can be borrowed based on @param _collateralAddress\n    /// and @param _collateralAmount values\n    /// @return value as a whole number\n    function maxUsdToBorrow(\n        address _collateralAddress,\n        uint256 _collateralAmount\n    ) internal view returns (uint256 value) {\n        if (!a().allowedTokenData[_collateralAddress].isAllowed) {\n            revert DomainErrors.UI__TokenNotAllowed(msg.sender, _collateralAddress);\n        }\n\n        uint256 collateralInUsd = a().getNormalizedUsdEquivalent(_collateralAddress, _collateralAmount);\n        uint16 tokenLtv = a().allowedTokenData[_collateralAddress].ltv;\n\n        // Calculates the result of the expression `collateralInUsd - (collateralInUsd * tokenLtv / BASIS_POINTS)`.\n        // The calculation within the parentheses is rounded down\n        uint256 denominator = DomainConstants.BASIS_POINTS;\n        assembly {\n            let z := mul(collateralInUsd, tokenLtv)\n\n            if iszero(\n                and(iszero(iszero(denominator)), or(iszero(collateralInUsd), eq(div(z, collateralInUsd), tokenLtv)))\n            ) {\n                revert(0, 0)\n            }\n\n            z := div(z, denominator)\n            value := sub(collateralInUsd, z)\n        }\n    }\n\n    /// @notice Batches related info for the staked tokens of @param _account and returns it in @return data\n    function batchStakedTokens(address _account) internal view returns (StakedTokenData[] memory data) {\n        address[] memory tokens = a().stakedTokens[_account];\n\n        uint256 length = tokens.length;\n        data = new StakedTokenData[](length);\n\n        for (uint256 i; i < length; i++) {\n            address tokenAddr = tokens[i];\n            StakedToken memory token = a().stakedTokenData[_account][tokenAddr];\n\n            data[i] = StakedTokenData({\n                amountStaked: token.amountStaked,\n                startAccumulatingDay: token.startAccumulatingDay,\n                tokenAddress: tokenAddr,\n                isCollateralOn: token.isCollateralOn,\n                isCollateralInUse: token.isCollateralInUse,\n                name: IERC20(tokenAddr).name()\n            });\n        }\n    }\n\n    /// @notice Batches related info for the borrowed tokens of @param _account and returns it in @return data\n    function batchBorrowedTokens(address _account) internal view returns (BorrowedTokenData[] memory data) {\n        address[] memory tokens = a().borrowedTokens[_account];\n\n        uint256 length = tokens.length;\n        data = new BorrowedTokenData[](length);\n\n        for (uint256 i; i < length; i++) {\n            address tokenAddr = tokens[i];\n            BorrowedToken memory token = a().borrowedTokenData[_account][tokenAddr];\n\n            data[i] = BorrowedTokenData({\n                amountBorrowed: token.amountBorrowed,\n                startAccumulatingDay: token.startAccumulatingDay,\n                name: IERC20(tokenAddr).name(),\n                tokenAddress: tokenAddr,\n                collateralAddress: token.collateralAddress,\n                collateralAmount: token.collateralAmount\n            });\n        }\n    }\n\n    /* ======================================= Keeper's ============================================================================================ */\n\n    /// @notice Retrieve a list of all borrowers in the protocol as @return data\n    function allBorrowers() internal view returns (address[] memory data) {\n        address[] memory borrowers = a().borrowers;\n\n        data = new address[](borrowers.length);\n        data = borrowers;\n    }\n\n    /// @notice Batches relevant @param account data\n    function batchAccountData(address _account) internal view returns (AccountData memory data) {\n        data = AccountData({stakedTokens: a().stakedTokens[_account], borrowedTokens: a().borrowedTokens[_account]});\n    }\n\n    /// @notice Returns @return result indicating the outcome of the check\n    /// @param _account The address of the account\n    /// @param _collateralAddress The address of the collateral\n    /// @param _borrowedTokenAddress The address of the borrowed token\n    function isLiquidatable(\n        address _account,\n        address _collateralAddress,\n        address _borrowedTokenAddress\n    ) internal view returns (bool result) {\n        AssetsState storage ast = a();\n\n        // ========= Collateral ============================\n        uint256 collateralAmount = ast.stakedTokenData[_account][_collateralAddress].amountStaked;\n        uint256 collateralInUsd = ast.getNormalizedUsdEquivalent(_collateralAddress, collateralAmount);\n\n        // ========= Borrowed token ============================\n        uint256 borrowedAmount = ast.borrowedTokenData[_account][_borrowedTokenAddress].amountBorrowed;\n        uint256 borrowedInUsd = ast.getNormalizedUsdEquivalent(_borrowedTokenAddress, borrowedAmount);\n\n        // ========= Limit ============================\n        uint256 threshold = ast.allowedTokenData[_collateralAddress].liquidationThreshold;\n        uint256 limitInUsd = (threshold * collateralInUsd) / DomainConstants.BASIS_POINTS;\n\n        result = borrowedInUsd > limitInUsd - 1 ? true : false;\n    }\n}\n"
    },
    "src/contracts/domain/libraries/logic/LibWithdraw.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {Array} from \"./utils/Array.sol\";\nimport {AssetsState, StakedToken} from \"../AssetsState.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {DomainErrors} from \"../../../helpers/Errors.sol\";\nimport {DomainConstants} from \"../../../helpers/Constants.sol\";\n\n/// @title LibWithdraw\nlibrary LibWithdraw {\n    using Array for address[];\n\n    /// @notice Records the withdraw, applying the changes to the internal state\n    /// @param _tokenAddress The address of the withdrawn token\n    /// @param _verifiedAmount The verified amount of the withdrawn token\n    /// @custom:security When you're managing parallel data structures, it's crucial to ensure they are always synchronized.\n    /// Otherwise, it can result in a critical bug. Make sure they're always managed together\n    /// @custom:security Can't occur the mapping/array vulnerability where the mapping/array remains accessible\n    /// even after deletion, because in this case it's not nested\n    function recordWithdraw(AssetsState storage self, address _tokenAddress, uint256 _verifiedAmount) internal {\n        StakedToken storage stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\n\n        uint256 currentAmount = stakedToken.amountStaked;\n\n        if (_verifiedAmount == currentAmount) {\n            // Always manage together!\n            delete self.stakedTokenData[msg.sender][_tokenAddress];\n            self.stakedTokens[msg.sender].remove(_tokenAddress);\n            // =======\n        } else {\n            stakedToken.amountStaked -= _verifiedAmount;\n        }\n    }\n\n    /// @notice Calculates @return withdrawAmount and @return mTokensToBurn. @return verifiedAmount ensures\n    /// correct state changes in {recordWithdraw}\n    /// @param _tokenAddress The address of the token to be withdrawn\n    /// @param _tokenAmount The amount of the token to be withdrawn\n    /// @custom:security The correct decimals are applied\n    /// @custom:security The integral business model is not considered; wrong calculations and loss of funds may occur.\n    /// Calculations are only used for demo purposes\n    /// @custom:security If `startAccumulatingDay` is in the current day, `verifiedNumDays` will receive a value of\n    /// 1 (day) to ensure proper calculations in the current version, thereby preventing a critical vulnerability\n    /// @custom:security Performs calculations with a different bit size than `(uint)256`. Should be\n    /// closely/further monitored\n    function calculateWithdraw(\n        AssetsState storage self,\n        address _tokenAddress,\n        uint256 _tokenAmount\n    ) internal view returns (uint256 verifiedAmount, uint256 withdrawAmount, uint256 mTokensToBurn) {\n        /* ========================== Setup ======================================================================== */\n\n        StakedToken memory stakedToken = self.stakedTokenData[msg.sender][_tokenAddress];\n\n        uint256 stakedAmount = stakedToken.amountStaked;\n\n        IERC20 token = IERC20(_tokenAddress);\n        uint8 decimals = token.decimals();\n\n        // In order to burn the correct amount\n        verifiedAmount = (_tokenAmount > stakedAmount ? stakedAmount : _tokenAmount);\n        uint256 scaledWithdraw = verifiedAmount * 10 ** decimals;\n\n        /* ========================== Interest, withdrawable amount ======================================================================== */\n\n        if (!stakedToken.isCollateralOn) {\n            uint32 tokenStakeStableRate = self.allowedTokenData[_tokenAddress].stakeStableRate;\n\n            uint256 numDays = (block.timestamp - stakedToken.startAccumulatingDay) / DomainConstants.SECONDS_PER_DAY;\n\n            uint256 verifiedNumDays = numDays > 0 ? numDays : 1;\n            // For example. `100e18 * 1000 / 10_000` equals to `10e18`\n            uint256 dailyInterestInTokens = (scaledWithdraw * tokenStakeStableRate) / DomainConstants.BASIS_POINTS;\n            // `15 * 10e18 / 365` equals to `(0.)410958904109589041`\n            uint256 accumulatedInterestInTokens = (verifiedNumDays * dailyInterestInTokens) /\n                DomainConstants.DAYS_PER_YEAR;\n\n            // `100e18 += 410958904109589041` equals to `100410958904109589041`\n            withdrawAmount = accumulatedInterestInTokens;\n        }\n\n        withdrawAmount += scaledWithdraw;\n        if (token.balanceOf(address(this)) < withdrawAmount) revert DomainErrors.InsufficientProtocolFunds();\n\n        /* ========================== mTokens ======================================================================== */\n\n        mTokensToBurn = (self.getNormalizedUsdEquivalent(_tokenAddress, verifiedAmount)) * 10 ** decimals;\n    }\n}\n"
    },
    "src/contracts/domain/libraries/logic/utils/Array.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\n// Consider adding remappings\nimport {DomainErrors} from \"../../../../helpers/Errors.sol\";\n\n/// @title Array\n/// @notice Array helper utils\nlibrary Array {\n    /// @notice Removes @param _address from @param _arr\n    /// @custom:exec Gets the index of `tokenAddress` -> moves the element in the last index, if\n    /// it's not already there -> removes the last index\n    function remove(address[] storage _arr, address _address) internal {\n        uint256 index = _indexOf(_arr, _address);\n        if (index == 404) revert DomainErrors.Error404();\n\n        uint256 lastIndex = _arr.length - 1;\n\n        if (index != lastIndex) _arr[index] = _arr[lastIndex];\n\n        _arr.pop();\n    }\n\n    /// @notice Pushes @param _address in @param _arr, if doesn't occur\n    function safePush(address[] storage _arr, address _address) internal {\n        uint256 index = _indexOf(_arr, _address);\n\n        if (index == 404) {\n            _arr.push(_address);\n        } else {\n            revert DomainErrors.TokenAlreadyThere();\n        }\n    }\n\n    /// @notice Returns the index of @param _address in @param _arr\n    /// @return i The index of the token's address, otherwise `404`, referencing the popular *Error404*\n    /// @custom:security Security measures taken for the *for* loop:\n    /// 1. The array is cached outside, making it gas-optimized;\n    /// 2. There is no storage array that can grow infinitely;\n    /// 3. There are no external calls within the loop, potentially preventing a DoS attack\n    function _indexOf(address[] memory _arr, address _address) private pure returns (uint256 i) {\n        uint256 length = _arr.length;\n\n        for (i; i < length; i++) {\n            if (_arr[i] == _address) return i;\n        }\n\n        i = 404;\n    }\n}\n"
    },
    "src/contracts/domain/libraries/ProtocolState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {DomainConstants} from \"../../helpers/Constants.sol\";\nimport {DomainErrors} from \"../../helpers/Errors.sol\";\nimport {d} from \"../../diamond/libraries/DiamondState.sol\";\n\n/// @notice Struct defining the current protocol state\n/// @custom:advice Consider creating a library with \"generic\" functions related to `ProtocolState`\nstruct ProtocolState {\n    /// @notice Reentrancy guard's property\n    uint256 reentrancyStatus;\n    /// @notice The address of the interest-bearing token\n    address mTokenAddress;\n    /// @notice Staleness prevention for the Chainlink oracle response\n    uint32 answerStalenessThreshold;\n}\n\n/* ============================= Pointer ============================================================================= */\n\nbytes32 constant PROTOCOL_STORAGE_POSITION = keccak256(\"martinivv.protocol.storage\");\n\n/// @notice Used as a shared storage among libraries\n/// @return ps Storage pointer to `DiamondState` struct\n/// @dev Any operation involving `ps` will read from or write to **storage**\nfunction p() pure returns (ProtocolState storage ps) {\n    bytes32 position = PROTOCOL_STORAGE_POSITION;\n\n    assembly {\n        ps.slot := position\n    }\n}\n\n/* ============================= Modifiers ============================================================================= */\n\n/// @notice Includes modifiers shared across protocol's contracts\n/// @custom:advice Consider adding more robust access control management\nabstract contract ProtocolModifiers {\n    /// @notice Prevents a contract from calling itself, over and over, directly or indirectly\n    /// @dev Forked OZ implementation. Avoids state storage collision within diamond\n    /// @dev By storing the original value once again at the end, a refund is triggered (see\n    /// https://eips.ethereum.org/EIPS/eip-2200)\n    modifier nonReentrant() {\n        if (p().reentrancyStatus == DomainConstants._ENTERED) revert DomainErrors.ReentrantCall();\n\n        p().reentrancyStatus = DomainConstants._ENTERED;\n        _;\n\n        p().reentrancyStatus = DomainConstants._NOT_ENTERED;\n    }\n\n    /// @notice Access control modifier. Ensures that the method is called only by the diamond owner\n    modifier onlyOwner() {\n        d().enforceIsContractOwner();\n        _;\n    }\n\n    /// @notice Initializes reentrancy guard on diamond deployment\n    function _initReentrancyGuard() internal {\n        p().reentrancyStatus = DomainConstants._NOT_ENTERED;\n    }\n}\n"
    },
    "src/contracts/domain/test/tokens/TokenA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable state-visibility\n\npragma solidity =0.8.20;\n\nimport {ERC20} from \"../../vendor/ERC20.sol\";\n\n/// @title TokenA\n/// @notice Used as an allowed token when tested on a local network\ncontract TokenA is ERC20 {\n    /// @notice Initial supply amount\n    uint256 constant SUPPLY = 100_000_000 * 1e18;\n\n    /// @notice Contract constructor\n    constructor() ERC20(\"TokenA\", \"AAA\") {\n        _mint(msg.sender, SUPPLY);\n    }\n}\n"
    },
    "src/contracts/domain/test/tokens/TokenB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable state-visibility\n\npragma solidity =0.8.20;\n\nimport {ERC20} from \"../../vendor/ERC20.sol\";\n\n/// @title TokenB\n/// @notice Used as an allowed token when tested on a local network\ncontract TokenB is ERC20 {\n    /// @notice Initial supply amount\n    uint256 constant SUPPLY = 100_000_000 * 1e18;\n\n    /// @notice Contract constructor\n    constructor() ERC20(\"TokenB\", \"BBB\") {\n        _mint(msg.sender, SUPPLY);\n    }\n}\n"
    },
    "src/contracts/domain/vendor/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n\n/**\n * @title ERC20\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n * @custom:advice If your project's complexity requires it, consider creating your own, more robust, implementation.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "src/contracts/domain/vendor/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.20;\n\nimport {IAggregatorV3} from \"../interfaces/IAggregatorV3.sol\";\n\n/**\n * @title MockV3Aggregator\n * @notice Based on the FluxAggregator contract\n * @notice Use this contract when you need to test\n * other contract's ability to read data from an\n * aggregator contract, but how the aggregator got\n * its answer is unimportant\n * @custom:advice If your project requires it, consider creating your own version\n */\ncontract MockV3Aggregator is IAggregatorV3 {\n    uint8 public override decimals;\n    int256 public latestAnswer;\n    uint256 public latestTimestamp;\n    uint256 public latestRound;\n\n    mapping(uint256 => int256) public getAnswer;\n    mapping(uint256 => uint256) public getTimestamp;\n    mapping(uint256 => uint256) private getStartedAt;\n\n    constructor(uint8 _decimals, int256 _initialAnswer) {\n        decimals = _decimals;\n        updateAnswer(_initialAnswer);\n    }\n\n    function updateAnswer(int256 _answer) public {\n        latestAnswer = _answer;\n        latestTimestamp = block.timestamp;\n        latestRound++;\n        getAnswer[latestRound] = _answer;\n        getTimestamp[latestRound] = block.timestamp;\n        getStartedAt[latestRound] = block.timestamp;\n    }\n\n    function updateRoundData(uint80 _roundId, int256 _answer, uint256 _timestamp, uint256 _startedAt) public {\n        latestRound = _roundId;\n        latestAnswer = _answer;\n        latestTimestamp = _timestamp;\n        getAnswer[latestRound] = _answer;\n        getTimestamp[latestRound] = _timestamp;\n        getStartedAt[latestRound] = _startedAt;\n    }\n\n    /// @inheritdoc IAggregatorV3\n    function latestRoundData()\n        external\n        view\n        override\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n    {\n        return (\n            uint80(latestRound),\n            getAnswer[latestRound],\n            getStartedAt[latestRound],\n            getTimestamp[latestRound],\n            uint80(latestRound)\n        );\n    }\n}\n"
    },
    "src/contracts/domain/vendor/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n/* solhint-disable avoid-low-level-calls */\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "src/contracts/helpers/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable one-contract-per-file\n// solhint-disable state-visibility\n\npragma solidity =0.8.20;\n\n/// @title DiamondConstants\n/// @notice Constants used all around the Diamond logic\nlibrary DiamondConstants {\n    /// @notice Diamond's property\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    /// @notice Diamond's property\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n}\n\n/// @title DomainConstants\n/// @notice Constants used all around the Domain logic\nlibrary DomainConstants {\n    /// @notice Used for handling calculations with basis points\n    uint256 constant BASIS_POINTS = 10_000;\n    /// @notice One day in seconds\n    uint256 constant SECONDS_PER_DAY = 1 days;\n    /// @notice Days in a year. Yeap years are ignored\n    uint256 constant DAYS_PER_YEAR = 365;\n    /// @notice ReentrancyGuard's property\n    uint256 constant _NOT_ENTERED = 1;\n    /// @notice ReentrancyGuard's property\n    uint256 constant _ENTERED = 2;\n}\n"
    },
    "src/contracts/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable one-contract-per-file\n\npragma solidity =0.8.20;\n\nimport {IAggregatorV3} from \"../domain/interfaces/IAggregatorV3.sol\";\n\n/// @title DiamondErrors\n/// @notice Errors used all around the Diamond logic\nlibrary DiamondErrors {\n    error FunctionDoesNotExist();\n    error TooManyFunctionsInAFacet();\n    error NoZeroAddressOwner();\n    error NoSelectorFound();\n    error FunctionAlreadyExists();\n    error ImmutableFunctionDetected();\n    error CannotReplaceTheSameFunction();\n    error MustBeZeroAddress(address _newFacetAddress);\n    error IncorrectFacetCutAction(uint8 _actionNum);\n    error InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n    error MustBeDiamondOwner(address _caller);\n    error TransferFailed();\n}\n\n/// @title DomainErrors\n/// @notice Errors used all around the Domain logic\n/// @custom:advice Use distinct naming for the errors if your error monitoring model requires it\nlibrary DomainErrors {\n    // =============== Protocol ========================================\n    error ReentrantCall();\n    // =============== Deposit ========================================\n    error TokenNotAllowed(address _caller, address _tokenAddress);\n    error AmountShouldBePositive(address _caller);\n    error NotEnoughTokensInExistence();\n    error TokenNotStaked(address _caller, address _tokenAddress);\n    error CollateralAlreadyOn();\n    error CollateralNotEnabled(address _caller, address _tokenAddress);\n    error CollateralCurrentlyInUse();\n    // =============== Borrow ========================================\n    error NoAmountAvailable();\n    error CannotBorrowAmount(address _caller, uint256 maxAmountToBorrowInUsd, uint256 amountToBeBorrowedInUsd);\n    error InsufficientProtocolFunds();\n    error CollateralMismatch();\n    // =============== Repay ========================================\n    error TokenNotBorrowed(address _caller, address _tokenAddress);\n    error CollateralNotInUse();\n    error InsufficientTokenAmount();\n    error Error404();\n    error TokenAlreadyThere();\n    error NoTokensFound();\n    // =============== Liquidation ========================================\n    error SelfLiquidationNotAllowed();\n    error NotLiquidatable(address _caller);\n    // =============== LibCalculator ========================================\n    error AnswerShouldBePositiveNum(uint80 roundId, int256 answer);\n    error InvalidTime(uint80 roundId, uint256 updatedAt);\n    error StalePrice(uint80 roundId);\n    error OracleNotAvailable(IAggregatorV3 dataFeed);\n    // =============== UI ========================================\n    error UI__TokenNotAllowed(address _caller, address _tokenAddress);\n}\n"
    },
    "src/contracts/helpers/Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable one-contract-per-file\n\npragma solidity =0.8.20;\n\nimport {IDiamondCutFacet} from \"../diamond/interfaces/IDiamondCutFacet.sol\";\n\n/// @title DiamondEvents\n/// @notice Events used all around the Diamond logic\nlibrary DiamondEvents {\n    /// @notice Emitted on a successful cut\n    event DiamondCut(IDiamondCutFacet.FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n\n/// @title DomainEvents\n/// @notice Events used all around the Domain logic\nlibrary DomainEvents {\n    /// @notice Emitted on a successful deposit/stake in the protocol\n    event Deposit(address _depositedToken, uint256 _depositedAmount, address indexed _depositor);\n    /// @notice Emitted on a successful collateral activation\n    event CollateralOn(address _tokenAddress, address _depositor);\n    /// @notice Emitted on a successful collateral deactivation\n    event CollateralOff(address _tokenAddress, address _depositor);\n    /// @notice Emitted on a successful borrow from the protocol\n    event Borrow(address borrowedToken, uint256 _borrowedAmount, address indexed _borrower);\n    /// @notice Emitted on a successful repayment to the protocol\n    event Repay(address borrowedToken, uint256 _repayedAmount, address indexed _borrower);\n    /// @notice Emitted on a successful withdrawal from the protocol\n    event Withdraw(address token, uint256 amount, address indexed _depositor);\n    /// @notice Emitted on a successful liquidation\n    event Liquidation(address indexed _borrower, address indexed borrowedToken, uint256 keeperReward, address _keeper);\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 600
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}